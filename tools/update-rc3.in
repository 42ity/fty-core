#!/bin/bash
#
# WARNING: Bash-specific syntax is in fact used below
#
# Copyright (C) 2015-2020 Eaton
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
#! \file    update-rc3
#  \brief   Helper script to manage download of new images initiated from RC3
#  \author  Jim Klimov <EvgenyKlimov@Eaton.com>
#  \author  Michal Hrusecky <MichalHrusecky@Eaton.com>
#  \author  Tomas Halman <TomasHalman@Eaton.com>
#  \author  Arnaud Quette <ArnaudQuette@Eaton.com>
#

# Important bashism
set -o pipefail

is_set() (
    # NOTE: Bash-specific syntax may be in use below
    # Verify that variable named in "$1" is defined (may be empty).
    # Note that value of "$1" must be a single token (bash varname).
    # Below, ${!varname} causes BASH to expand variable named "varname"
    # and ${...+X} causes it to resolve to "X" only if the named variable
    # was not set.
    # TRUE if variable has a value, or is "set" and is NULL
    # FALSE if empty and unset
    [[ -n "${!1-}" ]] || \
    [[ -z ${!1-} && ${!1+X} ]] 2>/dev/null >/dev/null
)

config_defaults() {
    # This routine sets variables required for the script to work
    # They can be set earlier by configuration files or caller's env

    # Default values matching Eaton internal (at the moment) resources
    # The actual RC3 should be reconfigured to refer some customer-local mirror
    # or an external Eaton resource, done by snippets in /etc/update-rc3.d/*.conf
    is_set IMGTYPE || IMGTYPE="deploy"

    # Prefix and suffix around $IMGTYPE in the URL directory component
    # and the image filename (at the moment, at least, applies to both)
    is_set IMGTYPE_PREFIX || IMGTYPE_PREFIX=""
    is_set IMGTYPE_SUFFIX || IMGTYPE_SUFFIX="-image"

    # We have several rounds of QA in the CI system; if the IMGQALEVEL is
    # defined then this sub-path including a slash is added into the URL.
    # Currently defined values include "master", "pre-rc" and finally "rc".
    # We only spend our ARM cycles to build the latter two; we have all
    # builds available on x86_64.
    is_set ARCH || ARCH="`uname -m`"
    is_set IMGQALEVEL || case "$ARCH" in
        *arm*) IMGQALEVEL="rc" ;;
        *86*)  IMGQALEVEL="master" ;;
        *)     IMGQALEVEL="master" ;;
    esac
    # The RC3 base OS ensures support for squashfs and overlay(fs)
    is_set EXT || EXT="squashfs"
    # TODO: Eventually default to "sha256" or better,
    # but do not enforce too many breaking changes right now
    is_set CHECKSUM_ALGO_DEFAULT || CHECKSUM_ALGO_DEFAULT="md5"
    is_set CHECKSUM_ALGOLIST_DEFAULT || CHECKSUM_ALGOLIST_DEFAULT="md5 sha256 cksum"
    is_set CHECKSUM_REQUIRED || CHECKSUM_REQUIRED='true'

    # This value comes down from OBS target name into many corners of the multiverse
    is_set OSIMAGE_DISTRO || OSIMAGE_DISTRO="Debian_8.0"

    # This script is intended as the downloader tool for both CI/dev-workstation
    # hosts and the ultimate devices. Most of the logic is the same, but there are
    # a few differences. File and directory naming is one of them :
    # Our CI farm deployments mimic the build farm paths - with IMGTYPE/ARCH/filename.ext
    # The RC3 units expect a flat directory structure rootfs/filename.ext so
    # the details (especially IMGTYPE) should end up in the flat filename - as
    # ...__${ARCH}__${IMGTYPE}.${EXT} or ${IMGTYPE}..._${ARCH}.${EXT}
    # (rc3/virthost) If set to "no", use original filenames from the source server
    # FLAG_FLATTEN_FILENAMES is overridable by CLI option "--(no-)flatten-filenames"
    # The base filename pattern for an OS image as a shell glob, without the extension
    # on the download server.
    # is_set SOURCESITEROOT_OSIMAGE_FILENAMEPATTERN || SOURCESITEROOT_OSIMAGE_FILENAMEPATTERN="*"
    # is_set SOURCESITEROOT_OSIMAGE_FILENAMEPATTERN || SOURCESITEROOT_OSIMAGE_FILENAMEPATTERN="simpleimage*"
    # is_set FLAG_FLATTEN_FILENAMES || FLAG_FLATTEN_FILENAMES="yes"

    # Apparently, the new smarter build-names do not require flattery.
    # See findnewest_osimage() for subsequent filter over indexed filenames.
    is_set SOURCESITEROOT_OSIMAGE_FILENAMEPATTERN || SOURCESITEROOT_OSIMAGE_FILENAMEPATTERN="${IMGTYPE_PREFIX}${IMGTYPE}${IMGTYPE_SUFFIX}"'-*_'"${ARCH}"
    is_set FLAG_FLATTEN_FILENAMES || FLAG_FLATTEN_FILENAMES="no"

    ### Values below can be changed by command-line choices, and some defaults
    ### may be overridden by config files before CLI choices
    # (dev) If set to "no", then do not remove files even if deemed broken or old
    # Overridable by CLI option "--(no-)remove-files" which is somewhat different
    # from "--(no-)removeold-images" that only impacts old-image removal after a
    # successful download of new image(s)
    is_set FLAG_CAN_REMOVE_IMAGES || FLAG_CAN_REMOVE_IMAGES="yes"

    # Should we do a factory reset (erase all userdata)?
    is_set FLAG_ERASE_FACTORYRESET || FLAG_ERASE_FACTORYRESET="unset"
    # Should we clear the flag about a previously failed factory reset (assuming admin took care of it now)?
    is_set FLAG_ERASE_FACTORYRESETFAILED || FLAG_ERASE_FACTORYRESETFAILED="unset"

    # Should we do an erase_all (erase all userdata AND (re-)format /mnt/nand)?
    is_set FLAG_ERASE_ALL || FLAG_ERASE_ALL="unset"

    # See also comments at fetch_file()
    is_set SOURCESITEROOT || SOURCESITEROOT="http://obs.roz.lab.etn.com/images/${OSIMAGE_DISTRO}"
    is_set SOURCESITEROOT_OSIMAGE || SOURCESITEROOT_OSIMAGE="$SOURCESITEROOT/${IMGTYPE_PREFIX}${IMGTYPE}${IMGTYPE_SUFFIX}/${IMGQALEVEL:+$IMGQALEVEL/}$ARCH"

    is_set SOURCESITEROOTFW || SOURCESITEROOTFW="http://obs.roz.lab.etn.com/flash-rc3/recovery"
    is_set SOURCESITEROOTFW_UBOOT || SOURCESITEROOTFW_UBOOT="$SOURCESITEROOTFW"
    is_set SOURCESITEROOTFW_UIMAGE || SOURCESITEROOTFW_UIMAGE="$SOURCESITEROOTFW"
    is_set SOURCESITEROOTFW_MODULES || SOURCESITEROOTFW_MODULES="$SOURCESITEROOTFW/modules"

    # Recovery location (on MMC or mSATA) - for downloads
    is_set DOWNLOADROOT || DOWNLOADROOT="@URC3_DOWNLOADROOT@"
    is_set DOWNLOADROOT_OSIMAGE || DOWNLOADROOT_OSIMAGE="@URC3_DOWNLOADROOT_OSIMAGE@"
    is_set DOWNLOADROOTFW_UBOOT || DOWNLOADROOTFW_UBOOT="@URC3_DOWNLOADROOTFW_UBOOT@"
    is_set DOWNLOADROOTFW_UIMAGE || DOWNLOADROOTFW_UIMAGE="@URC3_DOWNLOADROOTFW_UIMAGE@"
    is_set DOWNLOADROOTFW_MODULES || DOWNLOADROOTFW_MODULES="@URC3_DOWNLOADROOTFW_MODULES@"

    # Deployment location (on SPI flash in production) - for boot-mounted OS image
    is_set DEPLOYMENTROOT || DEPLOYMENTROOT="@URC3_DEPLOYMENTROOT@"
    is_set DEPLOYMENTROOT_OSIMAGE || DEPLOYMENTROOT_OSIMAGE="@URC3_DEPLOYMENTROOT_OSIMAGE@"
    is_set DEPLOYMENTROOTFW_UBOOT || DEPLOYMENTROOTFW_UBOOT="@URC3_DEPLOYMENTROOTFW_UBOOT@"
    is_set DEPLOYMENTROOTFW_UIMAGE || DEPLOYMENTROOTFW_UIMAGE="@URC3_DEPLOYMENTROOTFW_UIMAGE@"
    is_set DEPLOYMENTROOTFW_MODULES || DEPLOYMENTROOTFW_MODULES="@URC3_DEPLOYMENTROOTFW_MODULES@"

    [ -z "${http_proxy-}" -o x"${http_proxy-}" = x- ] && http_proxy=""
    [ -z "${https_proxy-}" ] && https_proxy="$http_proxy"
    [ -z "${ftp_proxy-}" ]   && ftp_proxy="$http_proxy"
    [ -z "${ftps_proxy-}" ]  && ftps_proxy="$http_proxy"
    [ x"${https_proxy-}" = x- ] && https_proxy=""
    [ x"${ftp_proxy-}" = x- ]   && ftp_proxy=""
    [ x"${ftps_proxy-}" = x- ]  && ftps_proxy=""
    export http_proxy https_proxy ftp_proxy ftps_proxy

    # The RC3 SPI flash partitioning determines these sizes, value hardcoded in the
    # default installation routines as well as the init/upgrade script in uImage.
    # These numbers are used for "padded" checksum calculations.
    UIMAGE_MAX_SIZE_RC3=3145728
    UBOOT_MAX_SIZE_RC3=1048576
    is_set UIMAGE_MAX_SIZE || UIMAGE_MAX_SIZE="$UIMAGE_MAX_SIZE_RC3"
    is_set UBOOT_MAX_SIZE || UBOOT_MAX_SIZE="$UBOOT_MAX_SIZE_RC3"

    # /dev/mtdX numbers for RC3 partitions
    ROOT_MTD=5
    KERNEL_MTD=4
    UBOOTCFG_MTD=3
    UBOOT_MTD=2

    is_set WANT_REBOOT || WANT_REBOOT=no

    PATH="/sbin:/usr/sbin:/usr/local/sbin:/bin:/usr/bin:/usr/local/bin:$PATH"
    export PATH
}

### NOTE: This script can be copied to VM hosts and used standalone, so we do
### not depend it on scriptlib.sh or anything else. Implement a few bits here.

### This is prefixed before ERROR, WARN, INFO tags in the logged messages
LOGMSG_PREFIX="BIOS-UPDATE-RC3-"

### Store some important CLI values
is_set _SCRIPT_PATH || _SCRIPT_PATH="$0"
is_set _SCRIPT_NAME || _SCRIPT_NAME="`basename "${_SCRIPT_PATH}"`"
_SCRIPT_ARGS="$*"
_SCRIPT_ARGC="$#"

usage() {
    echo "Usage: ${_SCRIPT_NAME} [options...]"
    echo "Options:"
    echo "  --help | -help | -h       Display this hep and exit"
    echo "  --config | -c {path}      Source an additional config file (beside looking in"
    echo "                            standard locations e.g. '/etc/update-rc3.d/*.conf')"
    echo '  --no-config-file          Do not source default /etc/update-rc3.d/*.conf files'
    echo "  -ls              List remote images (except standard checksum files) and do an"
    echo "                   estimate if the newest differ from local copies. Effect and"
    echo "                   exitcodes similar to --check* below but with different output."
    echo "  --(no-)check-image-os, --(no-)check-image-fw, --(no-)check-images"
    echo "                   Only check the source location if new images are available"
    echo "                   and exit, whatever the outcome (see below for returned codes)"
    echo "  --dry-run | -n            Alias to --check-images (check both OS and FW)"
    echo "  --(no-)download-image-os  Enable or disable downloading of OS images"
    test -z "$DOWNLOADROOTFW_UBOOT" || \
    echo "  --(no-)download-image-fw  Likewise for downloading of uBoot, uImage+modules"
    echo "  --(no-)download-images|-N Enable or disable downloading of all image types"
    test -z "$DOWNLOADROOTFW_UBOOT" || \
    echo "  --fw-only                 Alias to --no-download-image-os --download-image-fw"
    echo "  --os-only                 Alias to --download-image-os --no-download-image-fw"
    echo "  --(no-)removeold-image-os, --(no-)removeold-image-fw, --(no-)removeold-images"
    echo "                   If download-image of this type was requested and successful,"
    echo "                   or if download was not requested at all, remove all but the"
    echo "                   newest (alphabetcally) image file from the recovery location"
    echo "                   NOTE: For flat namespace, removes all 'other' image types!"
    echo "  --(no-)remove-files       Skip removing image files deemed corrupt or obsolete"
    echo "  --(no-)flatten-filenames  Skip renaming image files to include ARCH and TYPE"
    echo "                            for easier differentiation in the flat storage dirs"
    echo "For the check* and download* methods, you can specify a full URL to the image"
    echo "file which you want rather than trying to detect the newest one available, with"
    echo "the following arguments ('raw' firmwares are the non-tarballed singular files):"
    echo "  --url-image-os|-U {URL} (expected checksum patterns should still exist nearby)"
    test -z "$DOWNLOADROOTFW_UBOOT" || \
    echo "  --url-image-fw-raw-uboot --url-image-fw-raw-uimage --url-image-fw-raw-modules"
    echo "  --(no-)erase-factory-reset If a new OS image downloaded successfully, touch"
    echo "                   the control file so 'init' does a factory reset after reboot"
    echo "                   Note: '-NR' alias to --no-erase-factory-reset can cancel a"
    echo "                   previously-requested factory reset if you changed your mind"
    echo "  --touch-factory-reset|-FR  Enforce a factory-reset to be done during next boot"
    echo "  --clear-failed-factory-reset|-FFR  Clear the flag-file about a previously"
    echo "                   failed factory-reset, after an admin has taken care of this"
    echo "  --(no-)erase-all           If a new OS image downloaded successfully, then"
    echo "                   request a factory reset and(!) NAND format after reboot"
    echo "  --touch-erase-all          Enforce a factory reset + NAND format next boot"
    echo "  --forceflash | -FF, --forceflash-image-os | -FFo, --forceflash-image-fw | -FFf"
    echo "      --forceflash-image-u-Boot | -FFb, --forceflash-image-uImage | -FFi"
    echo "                   Touch the .forceflash flag-files for corresponding new image"
    echo "  --no-forceflash | -NFF      Remove all existing .forceflash flag-files before"
    echo "                   anything else (if other --forceflash* options are enabled,"
    echo "                   they can later repopulate corresponding touch-files)"
    echo "  --reboot | -r | -R         If a new image (OS, FW) downloaded successfully"
    echo "                   request an immediate reboot as part of this script"
    echo "                   With '-R' this reboots the system in either non-error case"
    echo "For OEM factory procedures to complete in a standard manner, there is a flag:"
    echo "  --oem-finish     Request a factory reset and MMCp1 reformat during next"
    echo "                   boot, and power off the box gracefully"
    echo "For HTTP(S) or FTP(S) based delivery, do not forget to set http_proxy URL as"
    echo "applicable for your environment. Current value is '$http_proxy'."
    echo "RETURN CODES: This script returns 0 if no newer images were found to download"
    echo "42 if there is something new to download (in case of check-only, or if that"
    echo "'something new' was successfully downloaded in case of download actions so you"
    echo "may reboot the system to apply new updates), or other codes for errors."
# TODO(recurring) Maintain usage() as CLI options get added to the script
}

SCRIPTDIR=$(realpath "`dirname ${_SCRIPT_PATH}`") || \
    SCRIPTDIR=$(cd "`dirname ${_SCRIPT_PATH}`" && pwd)
SCRIPTPWD="`pwd`"
if [ -z "$CHECKOUTDIR" ] ; then
    CHECKOUTDIR=$(realpath "$SCRIPTDIR/../..") || \
        CHECKOUTDIR=$(cd "$SCRIPTDIR/../.." && pwd)
fi
[ "$CHECKOUTDIR" = / -o ! -d "$CHECKOUTDIR/tests/CI" ] && CHECKOUTDIR=""
is_set BUILDSUBDIR || BUILDSUBDIR="$CHECKOUTDIR"
export CHECKOUTDIR BUILDSUBDIR

is_set LANG || LANG=C
is_set LANGUAGE || LANGUAGE=C
is_set LC_ALL || LC_ALL=C
is_set TZ || TZ=UTC
export LANG LANGUAGE LC_ALL TZ

logmsg_info() {
    echo "${LOGMSG_PREFIX}INFO:" "$1"
    shift
    for L in "$@" ; do echo "$L"; done
    return 0
}

logmsg_warn() {
    echo "${LOGMSG_PREFIX}WARN:" "$1" >&2
    shift
    for L in "$@" ; do echo "$L"; done >&2
    return 0
}

logmsg_error() {
    echo "${LOGMSG_PREFIX}ERROR:" "$1" >&2
    shift
    for L in "$@" ; do echo "$L"; done >&2
    return 0
}

die() {
    CODE="${CODE-1}"
    [ "$CODE" -ge 0 ] 2>/dev/null || CODE=1
    for LINE in "$@" ; do
        echo "${LOGMSG_PREFIX}FATAL:" "$LINE" >&2
    done
    exit $CODE
}

settraps() {
    # Not all trap names are recognized by all shells consistently
    # Note: slight difference from scriptlib.sh, we trap ERR too by default
    [ -z "${TRAP_SIGNALS-}" ] && TRAP_SIGNALS="ERR  EXIT QUIT TERM HUP INT"
    for P in "" SIG; do for S in $TRAP_SIGNALS ; do
        case "$1" in
        -|"") trap "$1" $P$S 2>/dev/null || true ;;
        *)    trap 'ERRCODE=$?; ('"$*"'); exit $ERRCODE;' $P$S 2>/dev/null || true ;;
        esac
    done; done
}

##############################################################################
get_csalgo_from_filename() {
    # Parse (extensions of) the filename in "$1" to retrieve the
    # checksum algo (if any); set of supported algos and extensions
    # is to be kept in sync with remove_image() below.
    # TODO: Handle *.squashfs-manifest.json files as a SHA256 checksum carrier with a file-size field?..
    _A="`echo "$1" | tr '[A-Z]' '[a-z]' | sed -e 's,\.tmp$,,' -e 's,^.*\.\([^\.]*\)$,\1,' -e 's,-padded$,,'`" || _A=""

    case "${_A}" in
        md5|sha|sha1|sha224|sha256|sha384|sha512|cksum)
            echo "${_A}"
            unset _A
            return 0 ;;
        "") logmsg_error "Could not extract checksum algorithm from filename '$1'"
            unset _A
            return 31 ;;
        *)  logmsg_error "Unrecognized checksum algorithm: '${_A}'"
            unset _A
            return 32 ;;
    esac
}

calculate_stream_checksum() {
    # Calculate and print to stdout checksum of the stdin stream using algo "$1"
    # Use the function above to validate known algorithm names
    # We expect to have either ${ALGO}sum program or openssl support for ${ALGO}
    if [ -z "${1-}" ]; then
        ALGO="${CHECKSUM_ALGO_DEFAULT}"
    else
        ALGO="`get_csalgo_from_filename "$1"`" || return $?
    fi

    if [ "$ALGO" = cksum ] ; then
        # piped cmd output (with size in $2):   2851979510 532
        # TODO: Generalize into checking expected file lengths too
        #cksum | awk '{print $1}'
        # TODO: For now, collapse checksum and length fields into one for caching etc
        cksum | awk '{print $1"_"$2}'
        return $?
    fi

    if [ -x "`which openssl`" ] 2>/dev/null ; then
        # piped cmd output:   (stdin)= b39fd8ccd434b6e934cfd4016db3475c
        openssl dgst -"${ALGO}" | awk '{print $NF}'
        return $?
    fi

    # piped cmd output:   b39fd8ccd434b6e934cfd4016db3475c  -
    ${ALGO}sum | awk '{print $1}'
    return $?
}

expected_checksum() (
    # Extracts precalculated checksum of file "$1" recorded in file "$2"
    AWK_LIST='$1'
    expALGO="`get_csalgo_from_filename "$2"`" && \
    case "$expALGO" in
        cksum) AWK_LIST='$1"_"$2' ;;
    esac

    CHECKSUM_EXP="$(grep -i "`basename "$1"`" < "$2" | awk '{print '"$AWK_LIST"'}')" 2>/dev/null
    if [ $? != 0 -o -z "$CHECKSUM_EXP" ] && [ "`wc -l < "$2"`" -eq 1 ] ; then
        # Maybe the whole file content is one line with the value without name
        CHECKSUM_EXP="`awk '{print '"$AWK_LIST"'}' < "$2" | sed 's,_*$,,'`"
    fi
    [ -n "$CHECKSUM_EXP" ] && echo "$CHECKSUM_EXP"
    # If the value is empty, this statement returns an error exit-code
)

# Colon-separated values: CHECKSUM:LENGTH:ALGO:PATHNAME
# Length of -1 means full file or device byte-range
CHECKSUM_CACHE=""
find_checksum_cache() {
    # Finds from the cache the entry with given pathname $3 and algo $2 and length $1
    [ $# != 3 ] && return 22
    [ -z "${CHECKSUM_CACHE}" ] && return 1
    echo "$CHECKSUM_CACHE" | egrep '^[^\:]+'":$1:$2:$3"'$' | awk -F: '{print $1}'
}

remove_checksum_cache() {
    # Removes from the cache the entry with given pathname $3 and algo $2 and length $1
    #logmsg_warn "Consider removing from checksum cache: path='$3' len='$1' algo='$2'"
    [ $# != 3 ] && return 22
    [ -z "${CHECKSUM_CACHE}" ] && return 0
    CHECKSUM_CACHE1="`echo "$CHECKSUM_CACHE" | egrep -v '^[^\:]+'":$1:$2:$3"'$'`"
    [ x"$CHECKSUM_CACHE1" != x"$CHECKSUM_CACHE" ] && \
        logmsg_info "Removed item from checksum cache: path='$3' len='$1' algo='$2'"
    CHECKSUM_CACHE="$CHECKSUM_CACHE1"
    unset CHECKSUM_CACHE1
}

add_checksum_cache() {
    # Adds to the cache if the given pathname and algo and length are missing
    # If a value exists, it is replaced
    # Arguments $1..$4 are same as in CHECKSUM_CACHE definition above:
    #logmsg_warn "Consider adding to checksum cache: path='$4' len='$2' algo='$3' sum='$1'"
    [ $# != 4 ] && return 22
    if [ -z "${CHECKSUM_CACHE}" ]; then
        CHECKSUM_CACHE="$1:$2:$3:$4"
    else
        CHECKSUM_CACHE="`echo "$CHECKSUM_CACHE" | egrep -v '^[^\:]+'":$2:$3:$4"'$'`
$1:$2:$3:$4"
    fi
}

remove_image() {
    # Remove the image file "$1" and its possible checksum patterns,
    # and the optional explicit checksum filename that can be in "$2"
    # If the RETAIN_FILES variable is set, keep this file list (e.g.
    # a downloaded new CS, or secure a recent OS image with metadata)
    [ x"${FLAG_CAN_REMOVE_IMAGES-}" = xno ] && \
        logmsg_info "FLAG_CAN_REMOVE_IMAGES=$FLAG_CAN_REMOVE_IMAGES so do not remove_image($*)" && \
        return 0

    if [ -n "$RETAIN_FILES" ] ; then
        for RETAIN_FILE in ${RETAIN_FILES} ; do
            [ -s "$RETAIN_FILE" ] \
                && logmsg_info "Retaining '$RETAIN_FILE' during remove_image($*)" \
                && mv -f "$RETAIN_FILE" "$RETAIN_FILE.$$"
	done
    fi

    remove_checksum_cache '[^\:]*' '[^\:]*' "$1"
    remove_checksum_cache '[^\:]*' '[^\:]*' "$1"'\.[^\:]*'
    rm -f "$1"{,.md5,.sha,.sha1,.sha224,.sha256,.sha384,.sha512,.cksum}{,-padded}{,.tmp} ${2:+"$2"}

    # ...and update the SW package manifest
    # WARNING: this MUST be done before package manifest deletion!
    # TODO: By the licensing-aware updates design, the new candidate image's
    # copy of the generalized upgradeability validation routine should be
    # called, probably via chroot, applying that new version's concepts of
    # what is valid - which our old deployed version just can not know.
    # This chroot should happen after the currently deployed version has
    # confirmed trust to that new image, however (checksums/signatures).
    etn-sw-update --delete-image "$1"
    # Also remove the image file manifest, if present
    rm -f "$1"{,-manifest.json}

    if [ -n "$RETAIN_FILES" ] ; then
        for RETAIN_FILE in ${RETAIN_FILES} ; do
            [ -s "$RETAIN_FILE.$$" ] \
                && logmsg_info "Restoring retained '$RETAIN_FILE' during remove_image($*)" \
                && mv -f "$RETAIN_FILE.$$" "$RETAIN_FILE" \
                || rm -f "$1.forceflash"
	done
    fi
}

verify_checksum() {
    # Compares actual checksum of file "$1" with value recorded in file "$2"
    # with optional algorithm in "$3" (defaults to CHECKSUM_ALGO_DEFAULT='md5')
    # TODO: add generalized support for .${CHECKSUM_ALGO_DEFAULT}-padded checksum files (firmware imgs)
    # TODO (later): Support file sizes as part of checksum info
    FILENAME_DATA="$1"
    FILENAME_CSUM="${2-}"
    [ -n "$FILENAME_CSUM" ] || \
        FILENAME_CSUM="$FILENAME_DATA.${CHECKSUM_ALGO_DEFAULT}"
    if [ -z "${3-}" ]; then
        CHECKSUM_ALGO="`get_csalgo_from_filename "$FILENAME_CSUM"`"
        [ $? = 0 -a -n "$CHECKSUM_ALGO" ] || \
            CHECKSUM_ALGO="${CHECKSUM_ALGO_DEFAULT}"
    else
        CHECKSUM_ALGO="$3"
    fi
    LOGINTRO="Checksum validation of '$FILENAME_DATA' against value in '$FILENAME_CSUM' ($CHECKSUM_ALGO)"

    if [ -n "$FILENAME_DATA" ] && [ -n "$FILENAME_CSUM" ] && \
       [ -s "$FILENAME_DATA" -o -c "$FILENAME_DATA" -o -b "$FILENAME_DATA" ] && \
       [ -s "$FILENAME_CSUM" ] \
    ; then
        logmsg_info "Beginning $LOGINTRO..."

        CHECKSUM_EXP="`expected_checksum "$FILENAME_DATA" "$FILENAME_CSUM"`"
        if [ $? != 0 -o -z "$CHECKSUM_EXP" ]; then
            logmsg_warn "$LOGINTRO SKIPPED (can not detect expected value)"
            return 0
        fi

        CHECKSUM_ACT="`find_checksum_cache '-1' "${CHECKSUM_ALGO}" "${FILENAME_DATA}"`" && \
            [ -n "${CHECKSUM_ACT}" ] && logmsg_info "Got cached checksum (${CHECKSUM_ALGO}) for ${FILENAME_DATA}" \
            || CHECKSUM_ACT=""
        if [ -z "$CHECKSUM_ACT" ]; then
            CHECKSUM_ACT="`calculate_stream_checksum ${CHECKSUM_ALGO} < "$FILENAME_DATA"`"
            if [ $? = 0 ] && [ -n "$CHECKSUM_ACT" ]; then
                # TODO: Actually employ data-file length field
                # TODO: Compare data-file length field to value in .cksum files
                # TODO: Use data-length field from manifest files?
                add_checksum_cache "${CHECKSUM_ACT}" "-1" "${CHECKSUM_ALGO}" "${FILENAME_DATA}"
            else
                CHECKSUM_ACT=""
            fi
        fi
        if [ -z "$CHECKSUM_ACT" ]; then
            logmsg_warn "$LOGINTRO SKIPPED (can not calculate actual value)"
            return 0
        fi

        if [ x"$CHECKSUM_ACT" = x"$CHECKSUM_EXP" ]; then
            logmsg_info "$LOGINTRO SUCCEEDED!"
            return 0
        fi

        logmsg_error "$LOGINTRO FAILED (mismatch)!"
        echo "ACTUAL: $CHECKSUM_ACT" >&2
        echo "EXPECT: $CHECKSUM_EXP" >&2
        return 1
    fi
    logmsg_warn "$LOGINTRO SKIPPED (one of the files is missing)"
    return 0
}

ensure_checksum() {
    # A destructive wrapper of verify_checksum(), destroys bad downloads
    if ! verify_checksum "$@" ; then
        logmsg_warn "Removing broken file: '$1' and its checksum(s)"
        remove_image "$@" || return $?
        return 1
    fi
    return 0
}

verify_threeway_checksum() {
    # We can have (or not) a local copy of the data file "$2", a local copy
    # of the checksum file "$3", and a freshly fetched copy of remote checksum
    # file "$4" (usually an *.algo.tmp); all previously downloaded by caller
    # from URL in "$1".
    # Return codes:
    #   0       OK, local data and checksum files are (now) consistent, keep'em
    #   1       ERROR, local files inconsistent (removed), re-pull from remote!
    #   2       ERROR, some prerequisites missing, etc.
    # Verify if any of these files match together (in a destructive manner):
    # * If some of the files are not available:
    # ** data file - fail (must download all bits)
    # ** both checksums - fail (legacy mode allowed no checksums, now not so)
    # ** local checksum - fall through (only compare to remote checksum then)
    # ** remote checksum - fall through (only compare to local checksum then)
    # * If two checksums are the same (both in algo and value), remove the
    #   newly downloaded one and fall through for verifications
    # * If the remote checksum file exists (thus different from local) and
    #   a checksum value is detected from it:
    # ** If the remote checksum value does match the file - assume it to be
    #    authoritative and local one possibly broken (overwrite checksum file)
    # ** If the remote checksum does not match, assume the source file updated
    #    in-place on the remote source - kill local data and return error
    #    (caller would pull remote files)
    # * If the local CS+DATA do NOT match together, kill them and return error
    # * If neither checksum matches - kill local data and return error

    # The IMAGE_URL_BASENAME_EXT (on remote site with hierarchical structure)
    # may be different from local FILE_DATA name (with flattened structure).
    local IMAGE_URL="$1"
    local IMAGE_URL_BASENAME
    local IMAGE_URL_BASENAME_EXT
    # Basenames of data and checksum files (under current dir set by caller
    # or absolute - e.g. for recovery vs. deployed storage locations).
    # Theoretically checksums may be from different algorithms (see extension).
    local FILE_DATA="$2"
    local FILE_CSOLD="$3"
    local FILE_CSNEW="$4"

    local CSNEW CSOLD CSNEWALGO CSOLDALGO

    local FILE_DIR="`pwd`"
    case "$FILE_DATA" in
        /*) FILE_DIR="`dirname "$FILE_DATA"`";;
        ./*|../*) FILE_DIR="`pwd`/`dirname "$FILE_DATA"`"; FILE_DATA="$FILE_DIR/`basename "$FILE_DATA"`";;
        *) FILE_DATA="$FILE_DIR/$FILE_DATA" ;;
    esac
    case "$FILE_CSOLD" in
        /*) ;;
        ./*|../*) FILE_CSOLD="`pwd`/$FILE_CSOLD";;
        *) FILE_CSOLD="$FILE_DIR/$FILE_CSOLD" ;;
    esac
    case "$FILE_CSNEW" in
        /*) ;;
        ./*|../*) FILE_CSNEW="`pwd`/$FILE_CSNEW";;
        *) FILE_CSNEW="$FILE_DIR/$FILE_CSNEW" ;;
    esac

    [ -n "$IMAGE_URL" ] && \
    IMAGE_URL_BASENAME="`basename "$IMAGE_URL" ".${EXT}"`" && \
    [ -n "$IMAGE_URL_BASENAME" ] && \
    IMAGE_URL_BASENAME_EXT="${IMAGE_URL_BASENAME}${EXT:+.$EXT}" || \
        { logmsg_warn "Could not resolve IMAGE_URL value '$IMAGE_URL' into a filename"
          IMAGE_URL=""; IMAGE_URL_BASENAME=""; IMAGE_URL_BASENAME_EXT=""; }

    if [ ! -s "$FILE_DATA" ] && [ ! -c "$FILE_DATA" ] && [ ! -b "$FILE_DATA" ] ; then
        logmsg_info "Local data file '$FILE_DATA' is missing"
        return 2
    fi

    if [ ! -s "$FILE_CSOLD" ] && [ ! -s "$FILE_CSNEW" ] ; then
        logmsg_info "Both checksum files '$FILE_CSOLD' and '$FILE_CSNEW' are missing"
        return 2
    fi

    # If checksum files are available, try to get checksum values using the
    # current (local) or maybe original (remote from IMAGE_URL) filename.
    [ -s "$FILE_CSOLD" ] && \
        CSOLDALGO="`get_csalgo_from_filename "$FILE_CSOLD"`" && \
        { CSOLD="`expected_checksum "$FILE_DATA" "$FILE_CSOLD"`" || \
          CSOLD="`[ -z "$IMAGE_URL_BASENAME_EXT" ] && [ x"$FILE_DATA" != x"$IMAGE_URL_BASENAME_EXT" ] && expected_checksum "$IMAGE_URL_BASENAME_EXT" "$FILE_CSOLD"`" ; } || \
        { CSOLD=""; CSOLDALGO=""; logmsg_info "Local checksum file '$FILE_CSOLD' is missing"; }

    [ -s "$FILE_CSNEW" ] && \
        CSNEWALGO="`get_csalgo_from_filename "$FILE_CSNEW"`" && \
        { CSNEW="`expected_checksum "$FILE_DATA" "$FILE_CSNEW"`" || \
          CSNEW="`[ -z "$IMAGE_URL_BASENAME_EXT" ] && [ x"$FILE_DATA" != x"$IMAGE_URL_BASENAME_EXT" ] && expected_checksum "$IMAGE_URL_BASENAME_EXT" "$FILE_CSNEW"`" ; } || \
        { CSNEW=""; CSNEWALGO=""; logmsg_info "Remote checksum file '$FILE_CSNEW' is missing"; }

    if [ -z "$CSNEW" ] && [ -z "$CSOLD" ]; then
        logmsg_info "Could not get usable checksum values from both checksum files: '$FILE_CSOLD' and '$FILE_CSNEW'"
        return 2
    fi

    # Now that we have a validated request, do the actual suite of comparisons.
    if [ -n "$CSNEWALGO" ] && [ -n "$CSNEW" ] && \
       [ -n "$CSOLDALGO" ] && [ -n "$CSOLD" ] \
    ; then
        if [ x"$CSNEWALGO" = x"$CSOLDALGO" ]; then
            if [ x"$CSNEW" = x"$CSOLD" ]; then
                logmsg_info "Old and new checksum values are the same; keeping old checksum file and discarding new one"
                rm -f "$FILE_CSNEW"
                CSNEW=""
                CSNEWALGO=""
            else
                logmsg_warn "Old and new checksum values differ with same algo ($CSOLDALGO): '$CSOLD' vs '$CSNEW'"
            fi
        else
            logmsg_warn "Old and new checksum files have different algorithms: '$CSOLDALGO' vs '$CSNEWALGO' (so values are not comparable directly)"
        fi
    fi

    [ -n "$CSNEW" ] && \
    if verify_checksum "$FILE_DATA" "$FILE_CSNEW" ; then
        if [ x"${REPLACE_MISSING_CHECKSUM-}" = xno ] && [ ! -f "$FILE_CSOLD" ] ; then
            logmsg_info "Remote checksum is good in '$FILE_CSNEW' and local copy was missing - not installing new checksum file"
        else
            logmsg_info "Remote checksum is good in '$FILE_CSNEW', local copy was corrupted or missing - replacing checksum file"
            mv -f "$FILE_CSNEW" "$FILE_CSOLD"
        fi && \
            logmsg_info "The newest available remote image is '$IMAGE_URL' and we already have a good copy (as '$FILE_DATA')"
        return $?
    else
        # In-place changes are not nice but can happen e.g. for FW images
        logmsg_info "Remote checksum in '$FILE_CSNEW' is not good for '$FILE_DATA', local file is corrupted or obsolete and should be re-downloaded from '$IMAGE_URL'"
        if [ ! -c "$FILE_DATA" ] && [ ! -b "$FILE_DATA" ] ; then
            RETAIN_FILES="$FILE_CSNEW" remove_image "$FILE_DATA"
        fi
        return 1
    fi

    # Here we do not have a new checksum value for whatever reason
    [ -n "$CSOLD" ] && \
    if verify_checksum "$FILE_DATA" "$FILE_CSOLD" ; then
        logmsg_info "Local checksum matched for '$FILE_CSOLD'"
        return 0
    else
        # Verifying against old checksum failed, so data file and its related
        # files (checksums) should be removed; keep the FILE_CSNEW if available
        logmsg_info "Local checksum mismatched for '$FILE_CSOLD', local file is corrupted and should be re-downloaded from '$IMAGE_URL'"
        if [ ! -c "$FILE_DATA" ] && [ ! -b "$FILE_DATA" ] ; then
            RETAIN_FILES="$FILE_CSNEW" remove_image "$FILE_DATA"
        fi
        return 1
    fi

    logmsg_info "Neither path of three-way verification has succeeded for '$FILE_DATA', it should be re-downloaded from '$IMAGE_URL'"
    if [ ! -c "$FILE_DATA" ] && [ ! -b "$FILE_DATA" ] ; then
        RETAIN_FILES="$FILE_CSNEW" remove_image "$FILE_DATA"
    fi
    return 1
}

##################################################

fetch_file() {
    # Caller can provide envvars CHECK_ONLY=yes (globally to not download
    # for updating) and MAYBE_EMPTY=yes to allow empty files (by default not)
    # and FETCH_VERBOSE=yes/no.
    # TODO: TFTP support, busybox can do it
    # TODO: Test with https - can require custom CA trust configuration, etc.
    # TODO: Use our common requester as a wrapper for real/busybox wget/curl
    # TODO: Make a common routine to list remote directories (e.g. http-dir parsing, ftp, tftp, localfs...)
    local URL="$1"
    local FILE="$2"
    local RES=0
    local FETCH_FLAGS=""
    local FETCHER=wget

    case "$FETCHER" in
        # TODO : Generalize for curl, local "cp", tftp...
        wget*)
            if [ x"${FETCH_VERBOSE-}" = xyes ] ; then
                FETCH_FLAGS="-O -"
            else
                FETCH_FLAGS="-q -O -"
            fi
            ;;
    esac

    logmsg_info "Downloading '${URL}' (if any) into '${FILE}'..."
    if [ x"$FILE" = x- ] || [ x"$FILE" = x ] || [ x"$FILE" = xstdout ] ; then
        FILE=stdout
        $FETCHER $FETCH_FLAGS "${URL}" || RES=$?
    else
        if [ -d "`dirname "${FILE}"`" ]; then
            rm -f "${FILE}" || true
            $FETCHER $FETCH_FLAGS "${URL}" > "${FILE}" || RES=$?
        else
            logmsg_error "Could not save '${URL}' into '${FILE}': target directory is missing"
            RES=2
        fi
    fi

    if [ "$RES" != 0 ] ; then
        logmsg_error "Could not save '${URL}' into '${FILE}' (see errors above)"
    fi

    if [ x"${MAYBE_EMPTY=}" != xyes ] && [ "${FILE}" != stdout ] && [ ! -s "${FILE}" ] ; then
        logmsg_error "Got empty output trying to save '${URL}' into '${FILE}'"
        RES=1
    fi

    if [ "$RES" != 0 ] ; then
        if [ x"$FILE" != xstdout ]; then
            rm -f "${FILE}" || true
        fi
        if [ x"${CHECK_ONLY-}" = xyes ]; then
            die "Got an error while checking if there is something new to download, so no reason to proceed"
        fi
        return $RES
    fi

    return 0
}

# Routines below come from bios-boot::init codebase
readbytes() {
    # Input: "$1" == total size in bytes to copy from stdin to stdout;
    # chunked by $BS as much as possible for speed
    [ "$1" -ge 0 ] || \
        { echo "readbytes(): bad input size '$1'" ; return 1; }
    BS=16384
    if [ "$1" -le "$BS" ]; then
        dd bs=1 count="$1"
        return $?
    else
        dd bs="$BS" count="`expr $1 / $BS`" && \
        dd bs=1 count="`expr $1 % $BS`"
        return $?
    fi 2>/dev/null
}

calculate_stream_checksum_bytes() {
    # Calculate and print to stdout checksum of "$1" bytes from the stdin
    # stream using algo "$2" (or default algo, if not specified)
    readbytes "$1" | calculate_stream_checksum $2
}

filesize() {
    # Prints logical size of file in "$1", avoids dependency on ext.parsers
    ls -lHd "$1" | while \
        read _P _I _U _G _SZ _D1 _D2 _D3 _N; do echo ${_SZ}; done
}


##################################################

lshost_http() (
    # List the remote resource "$1" which is an apache-style http directory
    # (HTML) and return links that are relative or under the same virtserver
    REMOTE_DIR="`echo "$1" | sed 's,/$,,g'`"
    REMOTE_ROOTURL="`echo "$REMOTE_DIR" | sed 's,^\(.*://[^/]*\)/.*$,\1,'`"
    # Hostname from the URL, without schema and port
    REMOTE_VIRTHOST="`echo "$REMOTE_DIR" | sed 's,^.*://\([^/:]*\)[/:].*$,\1,'`"
    { CHECK_ONLY="notnow" fetch_file "$REMOTE_DIR"/ - || \
        { logmsg_error "lshost_http(): Could not request listing of URL ${REMOTE_DIR}"
          return 22; }
    } | \
        sed -n 's|.*href="\([^\"]*\)".*|\1|pg' | \
    while read URL ; do
#        echo "DEBUG: lshost_http(): got URL='$URL'" >&2
        case "$URL" in
            "[Hh][Tt]|[Tt][Pp]?([Ss])://${REMOTE_VIRTHOST}[:/]"*)
                # URL is under this virthost
                echo "$URL" ;;
            "[Hh][Tt][Tt][Pp]?([Ss])://"*)
                # URL is under some other virthost
                ;;
            *://*)
                # URL is under some unknown schema (e.g. FTP)
                ;;
            /*)  # Assume relative URL under server root
                echo "${REMOTE_ROOTURL}/${URL}" ;;
            *)  # Assume relative URL under current dir
                echo "${REMOTE_DIR}/${URL}" ;;
        esac
    done | sed 's,\([^:]\)//,\1/,g' || \
        { logmsg_error "lshost_http(): Could not parse listing of URL ${REMOTE_DIR}"
          return 23; }
)

lsdir_http() (
    # List the remote resource "$1/" which is an apache-style http directory
    # and selects URLs starting with this "$1/"
    REMOTE_DIR="`echo "$1" | sed 's,/$,,g'`"
    lshost_http "$REMOTE_DIR" | egrep -i "^$REMOTE_DIR/"
)

lsdir_http_pattern() {
    # List the remote directory resource "$1/" and select sub-files by glob $2
    # See "Pathname Expansion" in `man bash` for syntax details
    REMOTE_DIR="`echo "$1" | sed 's,/$,,g'`"
    REMOTE_GLOB="$2"
    lsdir_http "$REMOTE_DIR" | while read URL; do
#        echo "DEBUG: lsdir_http_pattern('$REMOTE_DIR', '$REMOTE_GLOB'): got URL='$URL'" >&2
        case "$URL" in
            $REMOTE_DIR/$REMOTE_GLOB) echo "$URL" ;;
        esac
    done
}

##################################################

download_rawfwimage_generic() (
    # This routine generalizes the download of a firmware image that is
    # checked against a raw partition content (u-Boot and uImage on IPC)
    # including padding of "empty" tail of allocated partition data if
    # a not-empty RAW_DEVICE_NODE is passed, or of a file like modules
    # archive if the RAW_DEVICE_NODE is empty.
    # It does not currently cover OS images that may have also complicated
    # filename conversions ("flattening") for some legacy project releases.
    #
    # If the caller sets CHECK_ONLY=yes and no copy of the remote image is
    # found on this local system, then the routine just returns code "42"
    # instead of downloading this detected new image otherwise.
    # A successful download of an image (consistent non-empty file) is 42 too

    local CALLER_ROUTINE="$1" ; shift
    local REPORT_IMAGETYPE="$1" ; shift
    local REFER_NEWEST="$1" ; shift
    local DOWNLOADROOT_THISIMAGE_VARNAME="$1" ; shift
    local DOWNLOADROOT_THISIMAGE="$1" ; shift
    local DEPLOYMENTROOT_THISIMAGE_VARNAME="$1" ; shift
    local DEPLOYMENTROOT_THISIMAGE="$1" ; shift
    local SOURCESITEROOT_THISIMAGE="$1" ; shift
    local IMAGEFINDER_ROUTINE="$1" ; shift
    local RAW_DEVICE_NODE="$1" ; shift
    local LOCAL_CHECKSUMS_MATCHED

    [ -n "${REFER_NEWEST}" ] && rm -f "${REFER_NEWEST}"

    cd "${DOWNLOADROOT_THISIMAGE}" || \
    cd "${DEPLOYMENTROOT_THISIMAGE}" || die "Can not use DOWNLOADROOT_THISIMAGE_VARNAME='$DOWNLOADROOT_THISIMAGE' nor DEPLOYMENTROOT_THISIMAGE_VARNAME='$DEPLOYMENTROOT_THISIMAGE'"

    case "${1-}" in
        *://*)
            logmsg_info "${CALLER_ROUTINE}() was asked to try downloading '$1' as the ${RAW_DEVICE_NODE:+raw }$REPORT_IMAGETYPE"
            IMAGE_URL="$1" ;;
        "")
            logmsg_info "Fetching newest remote filename for the ${RAW_DEVICE_NODE:+raw }$REPORT_IMAGETYPE..."
            IMAGE_URL="`${IMAGEFINDER_ROUTINE}`" && [ -n "$IMAGE_URL" ] \
            && logmsg_info "${CALLER_ROUTINE}() detected '$IMAGE_URL' as the newest remote ${RAW_DEVICE_NODE:+raw }$REPORT_IMAGETYPE" \
            || { logmsg_error "Could not find any remote ${RAW_DEVICE_NODE:+raw }$REPORT_IMAGETYPE"; IMAGE_URL="";} ;;
        *)  logmsg_error "${CALLER_ROUTINE}() got an unsupported argument: $*"
            IMAGE_URL=""
            ;;
    esac

    [ -n "$IMAGE_URL" ] && \
    rIMAGE_URL_BASENAME="`basename "${IMAGE_URL}"`" && \
        [ -n "${rIMAGE_URL_BASENAME}" ] || \
        die "Can not find the remote image URL"

    # TODO: Currently hardcoded for md5 accompanying checksums only
    # TODO (later): Support presence of multiple checksum files (e.g. sha* and md5)
    # TODO: Also support checksum-verifying against the flashed partition bits
    declare -A  IMAGE_CSURL
    declare -A rIMAGE_CSOLD
    declare -A aIMAGE_CSNEW
    declare -A aIMAGE_CSOLD
    declare -A aIMAGE_CSOLD_PADDED
    for IMAGE_CSALGO in ${CHECKSUM_ALGOLIST_DEFAULT} ; do
        # NOTE: "Old" filename and checksum are basenames that can be located under
        # different directories ("r"elative varnames), but e.g. a "new" checksum is
        # ensured to be in a temporary location and a newly downloaded file should
        # land into the recovery location ("a"bsolute varnames)
        IMAGE_CSURL["$IMAGE_CSALGO"]="${IMAGE_URL}.${IMAGE_CSALGO}"
        rIMAGE_CSOLD["$IMAGE_CSALGO"]="${rIMAGE_URL_BASENAME}.${IMAGE_CSALGO}"
        aIMAGE_CSNEW["$IMAGE_CSALGO"]="${TEMP_DATA}/${rIMAGE_URL_BASENAME}.$$.${IMAGE_CSALGO}.tmp"

        if [ -n "${RAW_DEVICE_NODE-}" ]; then
            IMAGE_CSURL_PADDED["$IMAGE_CSALGO"]="${IMAGE_URL}.${IMAGE_CSALGO}-padded"
            rIMAGE_CSOLD_PADDED["$IMAGE_CSALGO"]="${rIMAGE_URL_BASENAME}.${IMAGE_CSALGO}-padded"
            aIMAGE_CSNEW_PADDED["$IMAGE_CSALGO"]="${TEMP_DATA}/${rIMAGE_URL_BASENAME}.$$.${IMAGE_CSALGO}-padded.tmp"
        else
            IMAGE_CSURL_PADDED["$IMAGE_CSALGO"]=''
            rIMAGE_CSOLD_PADDED["$IMAGE_CSALGO"]=''
            aIMAGE_CSNEW_PADDED["$IMAGE_CSALGO"]=''
        fi
    done

    trap 'TRAPCODE=$?; rm -f "${aIMAGE_CSNEW[@]}" "${aIMAGE_CSNEW_PADDED[@]}"; exit $TRAPCODE' 0

    # TODO noted below: optionally check that we have at least one checksum
    # file; do not fail for legacy releases that e.g. only have one if the
    # option CHECKSUM_REQUIRED==false ...
    LOCAL_CHECKSUMS_MATCHED=-1
    for IMAGE_CSALGO in ${CHECKSUM_ALGOLIST_DEFAULT} ; do
        if [ "$LOCAL_CHECKSUMS_MATCHED" = -1 ] ; then LOCAL_CHECKSUMS_MATCHED=0 ; fi
        logmsg_info "Downloading '${IMAGE_CSURL["$IMAGE_CSALGO"]}' (if any) into '${aIMAGE_CSNEW["$IMAGE_CSALGO"]}'..."
        fetch_file "${IMAGE_CSURL["$IMAGE_CSALGO"]}" "${aIMAGE_CSNEW["$IMAGE_CSALGO"]}" || true
        #TODO# ... || if [ "${CHECKSUM_REQUIRED-}" = true ]; then ... ; fi

        if [ -n "${RAW_DEVICE_NODE-}" ]; then
            logmsg_info "Downloading '${IMAGE_CSURL_PADDED["$IMAGE_CSALGO"]}' (if any) into '${aIMAGE_CSNEW_PADDED["$IMAGE_CSALGO"]}'..."
            fetch_file "${IMAGE_CSURL_PADDED["$IMAGE_CSALGO"]}" "${aIMAGE_CSNEW_PADDED["$IMAGE_CSALGO"]}" || true
        fi

        # Try the filenames in local directories
        logmsg_info "Verifying if we locally have $IMAGE_CSALGO checksum and corresponding file under original name in base dir..."
        verify_threeway_checksum "${IMAGE_URL}" "${rIMAGE_URL_BASENAME}" "${rIMAGE_CSOLD["$IMAGE_CSALGO"]}" "${aIMAGE_CSNEW["$IMAGE_CSALGO"]}" \
             || LOCAL_CHECKSUMS_MATCHED=$?
    done

    case "$LOCAL_CHECKSUMS_MATCHED" in
        -1)  # Should not happen unless CHECKSUM_ALGOLIST_DEFAULT is empty
             logmsg_warn "Local checksums were not tested for local copy of '${IMAGE_URL}'" ;;
        0)   # At least one was tested, and all present checksums were ok
             echo "`pwd`/${rIMAGE_URL_BASENAME}" > "${REFER_NEWEST}"
             return 0
             ;;
        # Non-zeroes are not a problem, this is what the rest of routine is for
    esac

    if [ -d "${DEPLOYMENTROOT_THISIMAGE}" ] ; then
        if [ -n "${RAW_DEVICE_NODE-}" ]; then
            LOCAL_CHECKSUMS_MATCHED=-1
            for IMAGE_CSALGO in ${CHECKSUM_ALGOLIST_DEFAULT} ; do
                if [ "$LOCAL_CHECKSUMS_MATCHED" = -1 ] ; then LOCAL_CHECKSUMS_MATCHED=0 ; fi

                if [ -s "${aIMAGE_CSNEW_PADDED["$IMAGE_CSALGO"]}" ] && [ -c "${RAW_DEVICE_NODE}" ]; then
                    logmsg_info "Verify padded ${IMAGE_CSALGO} checksum against a raw $REPORT_IMAGETYPE partition with flashed bits here ..."
                    REPLACE_MISSING_CHECKSUM="no" \
                    FLAG_CAN_REMOVE_IMAGES="no" verify_threeway_checksum "${IMAGE_URL}" \
                        "${RAW_DEVICE_NODE}" \
                        "${DEPLOYMENTROOT_THISIMAGE}/${rIMAGE_CSOLD_PADDED["$IMAGE_CSALGO"]}" \
                        "${aIMAGE_CSNEW_PADDED["$IMAGE_CSALGO"]}" \
                    || LOCAL_CHECKSUMS_MATCHED=$?
                fi

                logmsg_info "Verify non-padded ${IMAGE_CSALGO} checksum against a raw $REPORT_IMAGETYPE partition with flashed bits here ..."
                REPLACE_MISSING_CHECKSUM="no" \
                FLAG_CAN_REMOVE_IMAGES="no" verify_threeway_checksum "${IMAGE_URL}" \
                        "${RAW_DEVICE_NODE}" \
                        "${DEPLOYMENTROOT_THISIMAGE}/${rIMAGE_CSOLD["$IMAGE_CSALGO"]}" \
                        "${aIMAGE_CSNEW["$IMAGE_CSALGO"]}" \
                    || logmsg_warn "TODO: If we can detect the file size of the remote image, use calculate_stream_checksum_bytes() to verify flashed bits vs ${IMAGE_CSALGO} checksum file"
	    done

            case "$LOCAL_CHECKSUMS_MATCHED" in
                -1)  # Should not happen unless CHECKSUM_ALGOLIST_DEFAULT is empty
                     logmsg_warn "Local checksums were not tested for raw $REPORT_IMAGETYPE partition" ;;
                0)   # At least one was tested, and all present checksums were ok
                     echo "${RAW_DEVICE_NODE}" > "${REFER_NEWEST}"
                     return 0
                     ;;
                # Non-zeroes are not a problem, this is what the rest of routine is for
            esac
        else # Not raw device node
            # Do not remove deployed files!
            LOCAL_CHECKSUMS_MATCHED=-1
            for IMAGE_CSALGO in ${CHECKSUM_ALGOLIST_DEFAULT} ; do
                if [ "$LOCAL_CHECKSUMS_MATCHED" = -1 ] ; then LOCAL_CHECKSUMS_MATCHED=0 ; fi
                logmsg_info "Verifying if we have ${IMAGE_CSALGO} checksum and corresponding file already deployed for $REPORT_IMAGETYPE..."
                FLAG_CAN_REMOVE_IMAGES="no" verify_threeway_checksum "${IMAGE_URL}" \
                        "${DEPLOYMENTROOT_THISIMAGE}/${rIMAGE_URL_BASENAME}" \
                        "${DEPLOYMENTROOT_THISIMAGE}/${rIMAGE_CSOLD["$IMAGE_CSALGO"]}" \
                        "${aIMAGE_CSNEW["$IMAGE_CSALGO"]}" \
                    || LOCAL_CHECKSUMS_MATCHED=$?
            done

            case "$LOCAL_CHECKSUMS_MATCHED" in
                -1)  # Should not happen unless CHECKSUM_ALGOLIST_DEFAULT is empty
                     logmsg_warn "Local checksums were not tested for $REPORT_IMAGETYPE" ;;
                0)   # At least one was tested, and all present checksums were ok
                     echo "${DEPLOYMENTROOT_THISIMAGE}/${rIMAGE_URL_BASENAME}" > "${REFER_NEWEST}"
                     return 0
                     ;;
                # Non-zeroes are not a problem, this is what the rest of routine is for
            esac
        fi
    fi

    if [ x"${CHECK_ONLY-}" = xyes ]; then
        logmsg_info "According to checksums, the remote resource '$IMAGE_URL' points to a $REPORT_IMAGETYPE content which we do not have on this system"
        return 42
    fi

    # If we are here, the IMAGE_URL is valid and points to a different content
    # than what we already have; the aTGT_FILE names the ultimate local filename
    aTGT_FILE="`pwd`/${rIMAGE_URL_BASENAME}"
    for IMAGE_CSALGO in ${CHECKSUM_ALGOLIST_DEFAULT} ; do
        aIMAGE_CSOLD["$IMAGE_CSALGO"]="`pwd`/${rIMAGE_CSOLD["$IMAGE_CSALGO"]}"

        if [ ! -s "${aIMAGE_CSOLD["$IMAGE_CSALGO"]}" ]; then
            [ -s "${aIMAGE_CSNEW["$IMAGE_CSALGO"]}" ] && cp -f "${aIMAGE_CSNEW["$IMAGE_CSALGO"]}" "${aIMAGE_CSOLD["$IMAGE_CSALGO"]}"
        fi

        if [ -n "${RAW_DEVICE_NODE-}" ]; then
            aIMAGE_CSOLD_PADDED["$IMAGE_CSALGO"]="`pwd`/${rIMAGE_CSOLD_PADDED["$IMAGE_CSALGO"]}"
            if [ ! -s "${aIMAGE_CSOLD_PADDED["$IMAGE_CSALGO"]}" ]; then
                [ -s "${aIMAGE_CSNEW_PADDED["$IMAGE_CSALGO"]}" ] && cp -f "${aIMAGE_CSNEW_PADDED["$IMAGE_CSALGO"]}" "${aIMAGE_CSOLD_PADDED["$IMAGE_CSALGO"]}"
            fi
        else
            aIMAGE_CSOLD_PADDED["$IMAGE_CSALGO"]=""
        fi
    done

    logmsg_info "Downloading '$IMAGE_URL' into '$aTGT_FILE'..."
    FETCH_VERBOSE=yes fetch_file "$IMAGE_URL" "${aTGT_FILE}" || \
        { remove_image "$aTGT_FILE"; die "Could not download '$IMAGE_URL' into '$aTGT_FILE'"; }
    remove_checksum_cache '[^\:]*' '[^\:]*' "${aTGT_FILE}"

    HELPER_PATTERN=''
    for IMAGE_CSALGO in ${CHECKSUM_ALGOLIST_DEFAULT} ; do
        [ -n "${HELPER_PATTERN-}" ] \
	    && HELPER_PATTERN="${HELPER_PATTERN}|${IMAGE_CSURL["$IMAGE_CSALGO"]}" \
	    || HELPER_PATTERN="${IMAGE_CSURL["$IMAGE_CSALGO"]}"
        if [ -n "${RAW_DEVICE_NODE-}" ]; then
            HELPER_PATTERN="${HELPER_PATTERN}|${IMAGE_CSURL_PADDED["$IMAGE_CSALGO"]}"
        fi
    done
    HELPER_PATTERN="^${HELPER_PATTERN}"'$'

    lsdir_http_pattern "${SOURCESITEROOT_THISIMAGE}" "`basename ${IMAGE_URL}`"'*' | egrep "^${IMAGE_URL}\." | \
        egrep -v "${HELPER_PATTERN}" | \
        while read U ; do
            # Note these are helper files, e.g. a padded checksum or some
            # touched-flags (may even be empty) and not fatal if missing
            aBU="`pwd`/`basename "$U"`"
            logmsg_info "Downloading optional additional file '$U' into '$aBU'..."
            MAYBE_EMPTY=yes fetch_file "${U}" "${aBU}" || true
        done

    LOCAL_CHECKSUMS_MATCHED=-1
    for IMAGE_CSALGO in ${CHECKSUM_ALGOLIST_DEFAULT} ; do
        if [ -s "${aIMAGE_CSOLD["$IMAGE_CSALGO"]}" ] \
        || [ -s "${aIMAGE_CSNEW["$IMAGE_CSALGO"]}" ] \
        || [ -s "${DEPLOYMENTROOT_THISIMAGE}/${rIMAGE_CSOLD["$IMAGE_CSALGO"]}" ] \
        ; then
            if [ "$LOCAL_CHECKSUMS_MATCHED" = -1 ] ; then LOCAL_CHECKSUMS_MATCHED=0 ; fi
            FLAG_CAN_REMOVE_IMAGES="no" verify_threeway_checksum "${IMAGE_URL}" \
                "${aTGT_FILE}" \
                "${aIMAGE_CSOLD["$IMAGE_CSALGO"]}" \
                "${DEPLOYMENTROOT_THISIMAGE}/${rIMAGE_CSOLD["$IMAGE_CSALGO"]}" || \
            verify_threeway_checksum "${IMAGE_URL}" \
                "${aTGT_FILE}" \
                "${aIMAGE_CSOLD["$IMAGE_CSALGO"]}" \
                "${aIMAGE_CSNEW["$IMAGE_CSALGO"]}" || return $?
        else
            # Optional requirement that (at least one) checksum is downloadable
            if [ "${CHECKSUM_REQUIRED-}" != true ]; then
                logmsg_warn "Generating '${aIMAGE_CSOLD["$IMAGE_CSALGO"]}' because there was none at the source..."
                echo "`calculate_stream_checksum "${IMAGE_CSALGO}" < "${aTGT_FILE}"` `basename "$aTGT_FILE"`" > "${aIMAGE_CSOLD["$IMAGE_CSALGO"]}" || \
                { rm -f "${aIMAGE_CSOLD["$IMAGE_CSALGO"]}"; die "Could not generate '${aIMAGE_CSOLD["$IMAGE_CSALGO"]}'"; }
            fi
        fi
    done

    case "$LOCAL_CHECKSUMS_MATCHED" in
        -1)  # Should not happen unless CHECKSUM_ALGOLIST_DEFAULT is empty
             logmsg_warn "Downloaded checksums were not tested for $REPORT_IMAGETYPE"
             if [ "${CHECKSUM_REQUIRED-}" != true ]; then
                die "At least one checksum should be downloadable (and matching) for '${aTGT_FILE}'"
             fi
             ;;
        0)   ;; # At least one was tested, and all present checksums were ok
        *)   # Should not get here due to return above
             die "At least one checksum did not match for '${aTGT_FILE}'"
             ;;
    esac

    # Finally check that expected files are all here - and note at this
    # point it includes the whole CHECKSUM_ALGOLIST_DEFAULT matrix
    # TODO: Verify file size against partition size (flashability after reboot)
    [ -s "${aTGT_FILE}" ] \
        || die "Could not find '${aTGT_FILE}' or it was found empty"

    for IMAGE_CSALGO in ${CHECKSUM_ALGOLIST_DEFAULT} ; do
        [ -s "${aIMAGE_CSOLD["$IMAGE_CSALGO"]}" ] \
        && touch -r "${aTGT_FILE}" "${aIMAGE_CSOLD["$IMAGE_CSALGO"]}" \
        || die "Could not touch '${aIMAGE_CSOLD["$IMAGE_CSALGO"]}' or it was found empty"
    done

    logmsg_info "Got $REPORT_IMAGETYPE OK:" && \
    ls -ld "${aTGT_FILE}" "${aIMAGE_CSOLD[@]}" && \
    cat "${aIMAGE_CSOLD[@]}" && \
    { echo "${aTGT_FILE}" > "${REFER_NEWEST}" ;
      return 42 ; }
    # If some of the above fails, return non-zero non-42 result code
)

##################################################

sort_osimage_names() {
    # ASSUMPTION: we don't have over 999 rebuilds of the same baseline image ;)
    # ASSUMPTION2: all image builds have a rebuild-index suffix for the same
    # baseline, or there is one old image for a baseline without a suffix.
    # NOTE: Over project lifetime, the rebuild numbers were separated by "dash"
    # or by "plus" so we support both below.
    ### sort
    ### sort -n
    sed -e 's,-\([[:digit:]][[:digit:]]\.[[:digit:]][[:digit:]]\.[[:digit:]][[:digit:]]\)_,-\1-0_,' \
        -e 's,\([\-\+]\)\([[:digit:]]\)_,\10\2_,' \
        -e 's,\([\-\+]\)\([[:digit:]][[:digit:]]\)_,\10\2_,' \
    | sort -n | \
    sed -e 's,\([\-\+]\)0*\([123456789][[:digit:]]*\)_,\1\2_,' \
        -e 's,\([\-\+]\)00*_,_,'
}

findnewest_osimage() (
    # Echo the URL to the newest OS image file found on remote resource, if any
    # Note: currently expects certain filename patterns and http-dir listing markup
    IMAGE_URL="`lsdir_http_pattern "${SOURCESITEROOT_OSIMAGE}" "${SOURCESITEROOT_OSIMAGE_FILENAMEPATTERN}.${EXT}" | sort_osimage_names | tail -1`"
    if [ $? = 0 -a x"$IMAGE_URL" != x ]; then
        [ x"`basename "$IMAGE_URL" .${EXT}`" != x ] && \
        echo "$IMAGE_URL" && return 0
    fi
    logmsg_error "Error looking up remote file: Make sure your settings (including proxy if needed) are correct."
    return 1
)

download_osimage() (
    # If the caller sets CHECK_ONLY=yes and no copy of the remote image is
    # found on this local system, then the routine just returns code "42"
    # instead of downloading this detected new image otherwise.
    # A successful download of an image (consistent non-empty file) is 42 too
    local REPORT_IMAGETYPE='OS image'
    local LOCAL_CHECKSUMS_MATCHED

    REFER_NEWEST="${TEMP_DATA}/.newest-osimage"
    rm -f "${REFER_NEWEST}"

    # We do not download OS images into NAND (like FW image fallback),
    # not by easy default at least
    cd "${DOWNLOADROOT_OSIMAGE}" || {
        if [ x"${CHECK_ONLY-}" = xyes ]; then
            cd "${DOWNLOADROOTFW_OSIMAGE}" || die "Can not use DOWNLOADROOT_OSIMAGE='$DOWNLOADROOT_OSIMAGE' or DOWNLOADROOTFW_OSIMAGE='$DOWNLOADROOTFW_OSIMAGE'"
        else
            die "Can not use DOWNLOADROOT_OSIMAGE='$DOWNLOADROOT_OSIMAGE'"
        fi
    }

    case "${1-}" in
            *://*)
                logmsg_info "download_osimage() was asked to try downloading '$1' as the ${IMGTYPE} $REPORT_IMAGETYPE for ${ARCH}"
                IMAGE_URL="$1" ;;
            "")
                logmsg_info "Fetching newest remote filename for ${ARCH} $REPORT_IMAGETYPE of type ${IMGTYPE}..."
                IMAGE_URL="`findnewest_osimage`" && [ -n "$IMAGE_URL" ] \
                && logmsg_info "download_osimage() detected '$IMAGE_URL' as the newest remote ${IMGTYPE} $REPORT_IMAGETYPE for ${ARCH}" \
                || { logmsg_error "Could not find any remote $REPORT_IMAGETYPE"; IMAGE_URL="";} ;;
            *)  logmsg_error "download_osimage() got an unsupported argument: $*"
                IMAGE_URL=""
                ;; # This dies a bit below
    esac

    case "$IMAGE_URL" in
            *"${IMGTYPE}"*) ;;
            "") ;; # This dies a bit below
            *)  logmsg_warn "The string IMAGE_URL='$IMAGE_URL' does not contain IMGTYPE='$IMGTYPE'!" \
                    "You may have explicitly requested to download something different from you are running or expecting..."
                sleep 5 ;;
    esac

    case "$IMAGE_URL" in
            *"${ARCH}"*) ;;
            "") ;; # This dies a bit below
            *)  logmsg_warn "The string IMAGE_URL='$IMAGE_URL' does not contain ARCH='$ARCH'!" \
                    "You may have explicitly requested to download something different from you are running or expecting..."
                sleep 5 ;;
    esac

    [ -n "$IMAGE_URL" ] && \
    rIMAGE_URL_BASENAME="`basename "$IMAGE_URL" ".${EXT}"`" && \
        [ -n "$rIMAGE_URL_BASENAME" ] && \
        rIMAGE_URL_BASENAME_EXT="${rIMAGE_URL_BASENAME}${EXT:+.$EXT}" || \
        die "Can not find the remote image URL"

    # TODO: Currently hardcoded for md5 accompanying checksums only
    # TODO (later): Support presence of multiple checksum files (e.g. sha* and md5)
    declare -A  IMAGE_CSURL
    declare -A rIMAGE_CSOLD
    declare -A aIMAGE_CSOLD
    declare -A aIMAGE_CSNEW
    declare -A rTGT_FILE_CSOLD
    declare -A aTGT_FILE_CSOLD
    declare -A aTGT_FILE_CSNEW

    for IMAGE_CSALGO in ${CHECKSUM_ALGOLIST_DEFAULT} ; do
        # NOTE: "Old" filename and checksum are basenames that can be located under
        # different directories ("r"elative varnames), but e.g. a "new" checksum is
        # ensured to be in a temporary location and a newly downloaded file should
        # land into the recovery location ("a"bsolute varnames)
        IMAGE_CSURL["$IMAGE_CSALGO"]="${IMAGE_URL}.${IMAGE_CSALGO}"
        rIMAGE_CSOLD["$IMAGE_CSALGO"]="${rIMAGE_URL_BASENAME_EXT}.${IMAGE_CSALGO}"
        aIMAGE_CSNEW["$IMAGE_CSALGO"]="${TEMP_DATA}/${rIMAGE_URL_BASENAME_EXT}.$$.${IMAGE_CSALGO}.tmp"
    done

    # We rename the incoming image to include the type in flat directory space
    rTGT_FILE="${rIMAGE_URL_BASENAME_EXT}"
    case "${rIMAGE_URL_BASENAME}" in
        *__${ARCH}__${IMGTYPE}|*${IMGTYPE}*-*_${ARCH}) # Already good and flat
            ;;
        *)  if [ x"$FLAG_FLATTEN_FILENAMES" = xyes ]; then
                rTGT_FILE="${rIMAGE_URL_BASENAME}__${ARCH}__${IMGTYPE}${EXT:+.$EXT}" && \
                [ -n "$rTGT_FILE" ] || \
                die "Can not produce the relative TGT_FILE value to save into"
            fi
            ;;  # Had to define TGT_FILE different from rIMAGE_URL_BASENAME
    esac

    for IMAGE_CSALGO in ${CHECKSUM_ALGOLIST_DEFAULT} ; do
        rTGT_FILE_CSOLD["$IMAGE_CSALGO"]="${rTGT_FILE}.${IMAGE_CSALGO}"
        aTGT_FILE_CSNEW["$IMAGE_CSALGO"]="${TEMP_DATA}/${rTGT_FILE}.$$.${IMAGE_CSALGO}.tmp"
    done

    trap 'TRAPCODE=$?; rm -f "${aTGT_FILE_CSNEW[@]}" "${aIMAGE_CSNEW[@]}"; exit $TRAPCODE' 0
    # TODO noted below: optionally check that we have at least one checksum
    # file; do not fail for legacy releases that e.g. only have one if the
    # option CHECKSUM_REQUIRED==false ...
    LOCAL_CHECKSUMS_MATCHED=-1
    for IMAGE_CSALGO in ${CHECKSUM_ALGOLIST_DEFAULT} ; do
        if [ "$LOCAL_CHECKSUMS_MATCHED" = -1 ] ; then LOCAL_CHECKSUMS_MATCHED=0 ; fi
        logmsg_info "Downloading $IMAGE_CSALGO checksum '${IMAGE_CSURL["$IMAGE_CSALGO"]}' (if any) into '${aIMAGE_CSNEW["$IMAGE_CSALGO"]}'..."
        fetch_file "${IMAGE_CSURL["$IMAGE_CSALGO"]}" "${aIMAGE_CSNEW["$IMAGE_CSALGO"]}" || true
            # Errors reported inside, missing data is deemed bearable
            # TODO: ... || LOCAL_CHECKSUMS_MATCHED=$?

        if [ ! -s "${aTGT_FILE_CSNEW["$IMAGE_CSALGO"]}" ] ; then
            logmsg_info "Processing '${IMAGE_CSURL["$IMAGE_CSALGO"]}' (if any) to flatten the names into '${aTGT_FILE_CSNEW["$IMAGE_CSALGO"]}'..."
            { [ -s "${aIMAGE_CSNEW["$IMAGE_CSALGO"]}" ] && cat "${aIMAGE_CSNEW["$IMAGE_CSALGO"]}" || fetch_file "${IMAGE_CSURL["$IMAGE_CSALGO"]}" - ; } | \
            sed 's,  .*$,  '"`basename "$rTGT_FILE"`", > "${aTGT_FILE_CSNEW["$IMAGE_CSALGO"]}" || \
                { logmsg_error "Could not save and process '${IMAGE_CSURL["$IMAGE_CSALGO"]}' into '${aTGT_FILE_CSNEW["$IMAGE_CSALGO"]}'"
                  rm -f "${aTGT_FILE_CSNEW["$IMAGE_CSALGO"]}"
                }
            # TODO: ... || LOCAL_CHECKSUMS_MATCHED=$?
        fi
    done
    #TODO# ... || if [ "${CHECKSUM_REQUIRED-}" = true ] && [ "${LOCAL_CHECKSUMS_MATCHED}" != 0 ]; then ... ; fi

    # Due to legacy reasons, we juggle "flattened file" vs structured-directory
    # pathnames below. With introduction of multiple checksum types to check
    # the possible combinations matrix got even worse, so we could only extend
    # the existing approach (thus all checksum/data file name patterns must be
    # consistent)... TODO: maybe track hitting a IMAGE_CSALGO in an array with
    # some data filename value to save as REFER_NEWEST?

    # First try the modified filenames in local directories: more probable hit
    if [ x"${rTGT_FILE}" != x"${rIMAGE_URL_BASENAME_EXT}" ] ; then
        # #1: verify if all available checksums match for flattened
        # filenames of both the OS image data and checksum file
        # where aTGT_FILE_CSNEW!=aIMAGE_CSNEW
        LOCAL_CHECKSUMS_MATCHED=-1
        for IMAGE_CSALGO in ${CHECKSUM_ALGOLIST_DEFAULT} ; do
            if [ -s "${aTGT_FILE_CSNEW["$IMAGE_CSALGO"]}" ] \
            && [ x"${aTGT_FILE_CSNEW["$IMAGE_CSALGO"]}" != x"${aIMAGE_CSNEW["$IMAGE_CSALGO"]}" ] \
            ; then
                if [ "$LOCAL_CHECKSUMS_MATCHED" = -1 ] ; then LOCAL_CHECKSUMS_MATCHED=0 ; fi
                logmsg_info "Verifying if we have the $IMAGE_CSALGO checksum and corresponding file under flat name of data and checksum files for ${IMGTYPE} $REPORT_IMAGETYPE for ${ARCH}..."
                verify_threeway_checksum "${IMAGE_URL}" "${rTGT_FILE}" \
                        "${rTGT_FILE_CSOLD["$IMAGE_CSALGO"]}" \
                        "${aTGT_FILE_CSNEW["$IMAGE_CSALGO"]}" \
                    || LOCAL_CHECKSUMS_MATCHED=$?
            fi
        done
        case "$LOCAL_CHECKSUMS_MATCHED" in
            -1) # Should not happen unless CHECKSUM_ALGOLIST_DEFAULT is empty
                logmsg_warn "Local checksums were not tested for flat-named $REPORT_IMAGETYPE and checksum filenames" ;;
            0)  # At least one was tested, and all present checksums were ok
                echo "`pwd`/${rTGT_FILE}" > "${REFER_NEWEST}"
                return 0
                ;;
            # Non-zeroes are not a problem, this is what the rest of routine is for
        esac

        # #2: verify if all available checksums match for not-flattened
        # deployed filenames of both the OS image data and checksum file
        # where aTGT_FILE_CSNEW!=aIMAGE_CSNEW
        if [ -d "${DEPLOYMENTROOT_OSIMAGE}" ] ; then
            LOCAL_CHECKSUMS_MATCHED=-1
            for IMAGE_CSALGO in ${CHECKSUM_ALGOLIST_DEFAULT} ; do
                if [ -s "${aTGT_FILE_CSNEW["$IMAGE_CSALGO"]}" ] \
                && [ x"${aTGT_FILE_CSNEW["$IMAGE_CSALGO"]}" != x"${aIMAGE_CSNEW["$IMAGE_CSALGO"]}" ] \
                ; then
                    if [ "$LOCAL_CHECKSUMS_MATCHED" = -1 ] ; then LOCAL_CHECKSUMS_MATCHED=0 ; fi

                    # Do not remove deployed files!
                    logmsg_info "Verifying if we have the $IMAGE_CSALGO checksum and corresponding file already deployed for ${IMGTYPE} $REPORT_IMAGETYPE for ${ARCH}..."
                    FLAG_CAN_REMOVE_IMAGES="no" verify_threeway_checksum "${IMAGE_URL}" \
                        "${DEPLOYMENTROOT_OSIMAGE}/${rTGT_FILE}" \
                        "${DEPLOYMENTROOT_OSIMAGE}/${rTGT_FILE_CSOLD["$IMAGE_CSALGO"]}" \
                        "${aTGT_FILE_CSNEW["$IMAGE_CSALGO"]}" \
                    || LOCAL_CHECKSUMS_MATCHED=$?
                fi
            done
            case "$LOCAL_CHECKSUMS_MATCHED" in
                -1) # Should not happen unless CHECKSUM_ALGOLIST_DEFAULT is empty
                    logmsg_warn "Local checksums were not tested for already-deployed $REPORT_IMAGETYPE" ;;
                0)  # At least one was tested, and all present checksums were ok
                    echo "${DEPLOYMENTROOT_OSIMAGE}/${rTGT_FILE}" > "$DOWNLOADROOT_OSIMAGE/.newest-osimage"
                    echo "${DEPLOYMENTROOT_OSIMAGE}/${rTGT_FILE}" > "${REFER_NEWEST}"
                    return 0
                    ;;
                # Non-zeroes are not a problem, this is what the rest of routine is for
            esac
        fi

        # #3: verify if all available checksums match for flattened
        # filename of the OS image data and original name of checksum
        LOCAL_CHECKSUMS_MATCHED=-1
        for IMAGE_CSALGO in ${CHECKSUM_ALGOLIST_DEFAULT} ; do
            logmsg_info "Verifying if we have the $IMAGE_CSALGO checksum and corresponding file under flat name of data and original name of checksum file..."
            verify_threeway_checksum "${IMAGE_URL}" "${rTGT_FILE}" \
                    "${rTGT_FILE_CSOLD["$IMAGE_CSALGO"]}" \
                    "${aIMAGE_CSNEW["$IMAGE_CSALGO"]}" \
                || LOCAL_CHECKSUMS_MATCHED=$?
        done
        case "$LOCAL_CHECKSUMS_MATCHED" in
            -1) # Should not happen unless CHECKSUM_ALGOLIST_DEFAULT is empty
                logmsg_warn "Local checksums were not tested for flat-named $REPORT_IMAGETYPE and original checksum filenames" ;;
            0)  # At least one was tested, and all present checksums were ok
                echo "`pwd`/${rTGT_FILE}" > "${REFER_NEWEST}"
                return 0
                ;;
            # Non-zeroes are not a problem, this is what the rest of routine is for
        esac

        # #4: verify if all available checksums match for not-flattened
        # deployed filenames of both the OS image data and checksum file
        if [ -d "${DEPLOYMENTROOT_OSIMAGE}" ] ; then
            LOCAL_CHECKSUMS_MATCHED=-1
            for IMAGE_CSALGO in ${CHECKSUM_ALGOLIST_DEFAULT} ; do
                if [ "$LOCAL_CHECKSUMS_MATCHED" = -1 ] ; then LOCAL_CHECKSUMS_MATCHED=0 ; fi
                # Do not remove deployed files!
                logmsg_info "Verifying if we have the $IMAGE_CSALGO checksum and corresponding file already deployed for ${IMGTYPE} $REPORT_IMAGETYPE for ${ARCH}..."
                FLAG_CAN_REMOVE_IMAGES="no" verify_threeway_checksum "${IMAGE_URL}" \
                        "${DEPLOYMENTROOT_OSIMAGE}/${rTGT_FILE}" \
                        "${DEPLOYMENTROOT_OSIMAGE}/${rTGT_FILE_CSOLD["$IMAGE_CSALGO"]}" \
                        "${aIMAGE_CSNEW["$IMAGE_CSALGO"]}" \
                    || LOCAL_CHECKSUMS_MATCHED=$?
            done
            case "$LOCAL_CHECKSUMS_MATCHED" in
                -1) # Should not happen unless CHECKSUM_ALGOLIST_DEFAULT is empty
                    logmsg_warn "Local checksums were not tested for already-deployed $REPORT_IMAGETYPE" ;;
                0)  # At least one was tested, and all present checksums were ok
                    echo "${DEPLOYMENTROOT_OSIMAGE}/${rTGT_FILE}" > "$DOWNLOADROOT_OSIMAGE/.newest-osimage"
                    echo "${DEPLOYMENTROOT_OSIMAGE}/${rTGT_FILE}" > "${REFER_NEWEST}"
                    return 0
                    ;;
                # Non-zeroes are not a problem, this is what the rest of routine is for
            esac
        fi
    fi

    # If we got here, let's try unmodified filenames in local directories
    # (e.g. looking at a USB download), first in the base directory...
    LOCAL_CHECKSUMS_MATCHED=-1
    for IMAGE_CSALGO in ${CHECKSUM_ALGOLIST_DEFAULT} ; do
        if [ "$LOCAL_CHECKSUMS_MATCHED" = -1 ] ; then LOCAL_CHECKSUMS_MATCHED=0 ; fi
        logmsg_info "Verifying if we have the $IMAGE_CSALGO checksum and corresponding file under original name in base dir..."
        verify_threeway_checksum "${IMAGE_URL}" "${rIMAGE_URL_BASENAME_EXT}" \
                "${rIMAGE_CSOLD["$IMAGE_CSALGO"]}" \
                "${aIMAGE_CSNEW["$IMAGE_CSALGO"]}" \
            || LOCAL_CHECKSUMS_MATCHED=$?
    done
    case "$LOCAL_CHECKSUMS_MATCHED" in
        -1) # Should not happen unless CHECKSUM_ALGOLIST_DEFAULT is empty
            logmsg_warn "Local checksums were not tested for $REPORT_IMAGETYPE under original name in base dir" ;;
        0)  # At least one was tested, and all present checksums were ok
            [ -d "${DEPLOYMENTROOT_OSIMAGE}" ] \
                && echo "${rIMAGE_URL_BASENAME_EXT}" > "${DOWNLOADROOT_OSIMAGE}/.newest-osimage"
            echo "`pwd`/${rIMAGE_URL_BASENAME_EXT}" > "${REFER_NEWEST}"
            return 0
            ;;
        # Non-zeroes are not a problem, this is what the rest of routine is for
    esac

    # ...next in the deployed directory...
    if [ -d "${DEPLOYMENTROOT_OSIMAGE}" ] ; then
        LOCAL_CHECKSUMS_MATCHED=-1
        for IMAGE_CSALGO in ${CHECKSUM_ALGOLIST_DEFAULT} ; do
            if [ "$LOCAL_CHECKSUMS_MATCHED" = -1 ] ; then LOCAL_CHECKSUMS_MATCHED=0 ; fi
            # Do not remove deployed files!
            logmsg_info "Verifying if we have the $IMAGE_CSALGO checksum and corresponding file already deployed..."
            FLAG_CAN_REMOVE_IMAGES="no" verify_threeway_checksum "${IMAGE_URL}" \
                    "${DEPLOYMENTROOT_OSIMAGE}/${rIMAGE_URL_BASENAME_EXT}" \
                    "${DEPLOYMENTROOT_OSIMAGE}/${rIMAGE_CSOLD["$IMAGE_CSALGO"]}" \
                    "${aIMAGE_CSNEW["$IMAGE_CSALGO"]}" \
                || LOCAL_CHECKSUMS_MATCHED=$?
        done
        case "$LOCAL_CHECKSUMS_MATCHED" in
            -1) # Should not happen unless CHECKSUM_ALGOLIST_DEFAULT is empty
                logmsg_warn "Local checksums were not tested for $REPORT_IMAGETYPE under original name in base dir" ;;
            0)  # At least one was tested, and all present checksums were ok
                echo "${DEPLOYMENTROOT_OSIMAGE}/${rIMAGE_URL_BASENAME_EXT}" > "$DOWNLOADROOT_OSIMAGE/.newest-osimage"
                echo "${DEPLOYMENTROOT_OSIMAGE}/${rIMAGE_URL_BASENAME_EXT}" > "${REFER_NEWEST}"
                return 0
                ;;
            # Non-zeroes are not a problem, this is what the rest of routine is for
        esac
    fi

    # ...next in a structured directory sub-tree...
    if [ -d "./${IMGTYPE}/${ARCH}/" ]; then
        # Bit of support for container hosts
        LOCAL_CHECKSUMS_MATCHED=-1
        for IMAGE_CSALGO in ${CHECKSUM_ALGOLIST_DEFAULT} ; do
            if [ "$LOCAL_CHECKSUMS_MATCHED" = -1 ] ; then LOCAL_CHECKSUMS_MATCHED=0 ; fi
            logmsg_info "Verifying if we have the $IMAGE_CSALGO checksum and corresponding file under original name in hierarchy..."
            verify_threeway_checksum "${IMAGE_URL}" \
                    "./${IMGTYPE}/${ARCH}/${rIMAGE_URL_BASENAME_EXT}" \
                    "./${IMGTYPE}/${ARCH}/${rIMAGE_CSOLD["$IMAGE_CSALGO"]}" \
                    "${aIMAGE_CSNEW["$IMAGE_CSALGO"]}" \
                || LOCAL_CHECKSUMS_MATCHED=$?
        done
        case "$LOCAL_CHECKSUMS_MATCHED" in
            -1) # Should not happen unless CHECKSUM_ALGOLIST_DEFAULT is empty
                logmsg_warn "Local checksums were not tested for $REPORT_IMAGETYPE under original name in base dir" ;;
            0)  # At least one was tested, and all present checksums were ok
                echo "`pwd`/${IMGTYPE}/${ARCH}/${rIMAGE_URL_BASENAME_EXT}" > "$DOWNLOADROOT_OSIMAGE/.newest-osimage"
                echo "`pwd`/${IMGTYPE}/${ARCH}/${rIMAGE_URL_BASENAME_EXT}" > "${REFER_NEWEST}"
                return 0
                ;;
            # Non-zeroes are not a problem, this is what the rest of routine is for
        esac
    fi

    if [ x"${CHECK_ONLY-}" = xyes ]; then
        logmsg_info "According to checksums, the remote resource '$IMAGE_URL' points to an $REPORT_IMAGETYPE we do not have on this system"
        return 42
    fi

    # If we are here, the IMAGE_URL is valid and points to a different content
    # than what we already have; the TGT_FILE names the ultimate local filename
    if [ -d "./${IMGTYPE}/${ARCH}" ]; then
        aTGT_FILE="`pwd`/${IMGTYPE}/${ARCH}/${rTGT_FILE}"
    else
        aTGT_FILE="`pwd`/${rTGT_FILE}"
    fi

    for IMAGE_CSALGO in ${CHECKSUM_ALGOLIST_DEFAULT} ; do
        if [ -d "./${IMGTYPE}/${ARCH}" ]; then
            aTGT_FILE_CSOLD["$IMAGE_CSALGO"]="`pwd`/${IMGTYPE}/${ARCH}/${rTGT_FILE_CSOLD["$IMAGE_CSALGO"]}"
        else
            aTGT_FILE_CSOLD["$IMAGE_CSALGO"]="`pwd`/${rTGT_FILE_CSOLD["$IMAGE_CSALGO"]}"
        fi

        if [ x"${aTGT_FILE_CSNEW["$IMAGE_CSALGO"]}" != x"${aIMAGE_CSNEW["$IMAGE_CSALGO"]}" ] \
        && [ -s "${aIMAGE_CSNEW["$IMAGE_CSALGO"]}" ] \
        && [ -s "${aTGT_FILE_CSNEW["$IMAGE_CSALGO"]}" ] \
        ; then
            # We have both a flat and original checksum files; keep one
            if [ x"$FLAG_FLATTEN_FILENAMES" = xyes ]; then
                rm -f "${aIMAGE_CSNEW["$IMAGE_CSALGO"]}"
            else
                rm -f "${aTGT_FILE_CSNEW["$IMAGE_CSALGO"]}"
            fi
        fi

        if [ ! -s "${aTGT_FILE_CSOLD["$IMAGE_CSALGO"]}" ]; then
            [ -s "${aIMAGE_CSNEW["$IMAGE_CSALGO"]}" ] \
                && cp -f "${aIMAGE_CSNEW["$IMAGE_CSALGO"]}" "${aTGT_FILE_CSOLD["$IMAGE_CSALGO"]}"
            [ -s "${aTGT_FILE_CSNEW["$IMAGE_CSALGO"]}" ] \
                && cp -f "${aTGT_FILE_CSNEW["$IMAGE_CSALGO"]}" "${aTGT_FILE_CSOLD["$IMAGE_CSALGO"]}"
        fi
    done

    # Take care of image manifest file
    aTGT_FILE_MANIFEST="${aTGT_FILE}-manifest.json"
    aTGT_FILE_MANIFEST_NEW="${TEMP_DATA}/${rTGT_FILE}-manifest.json.$$.tmp" # like aTGT_FILE_CSNEW
    IMAGE_MANIFEST_URL="${IMAGE_URL}-manifest.json" # like IMAGE_CSURL
    rIMAGE_MANIFEST_OLD="${rIMAGE_URL_BASENAME_EXT}-manifest.json" # like rIMAGE_CSOLD
    aIMAGE_MANIFEST_NEW="${TEMP_DATA}/${rIMAGE_URL_BASENAME_EXT}-manifest.json.$$.tmp" # like aIMAGE_CSNEW

    logmsg_info "Downloading '$IMAGE_MANIFEST_URL' into '$aIMAGE_MANIFEST_NEW'..."
    fetch_file "${IMAGE_MANIFEST_URL}" "${aIMAGE_MANIFEST_NEW}" || true

    if [ ! -s "${aTGT_FILE_MANIFEST}" ]; then
        [ -s "${aIMAGE_MANIFEST_NEW}" ] \
            && cp -f "${aIMAGE_MANIFEST_NEW}" "${aTGT_FILE_MANIFEST}"
        [ -s "${aTGT_FILE_MANIFEST_NEW}" ] \
            && cp -f "${aTGT_FILE_MANIFEST_NEW}" "${aTGT_FILE_MANIFEST}"
    fi

    logmsg_info "Downloading '$IMAGE_URL' into '$aTGT_FILE'..."
    FETCH_VERBOSE=yes fetch_file "$IMAGE_URL" "${aTGT_FILE}" || \
        { remove_image "$aTGT_FILE"; die "Could not download '$IMAGE_URL' into '$aTGT_FILE'"; }

    # If we are here, new image file was fetched (along with small
    # metadata files). Clear our checksum cache to do clean checks.
    remove_checksum_cache '[^\:]*' '[^\:]*' "${aTGT_FILE}"

    LOCAL_CHECKSUMS_MATCHED=-1
    for IMAGE_CSALGO in ${CHECKSUM_ALGOLIST_DEFAULT} ; do
        if [ -s "${aTGT_FILE_CSOLD["$IMAGE_CSALGO"]}" ]; then
            if [ "$LOCAL_CHECKSUMS_MATCHED" = -1 ] ; then LOCAL_CHECKSUMS_MATCHED=0 ; fi
            ensure_checksum "${aTGT_FILE}" "${aTGT_FILE_CSOLD["$IMAGE_CSALGO"]}" || return $?
        else
            # Optional requirement that (at least one) checksum is downloadable
            if [ "${CHECKSUM_REQUIRED-}" != true ]; then
                logmsg_warn "Generating '${aTGT_FILE_CSOLD["$IMAGE_CSALGO"]}' because there was none at the source..."
                echo "`calculate_stream_checksum "${IMAGE_CSALGO}" < "$aTGT_FILE"`  `basename "$aTGT_FILE"`" > "${aTGT_FILE_CSOLD["$IMAGE_CSALGO"]}" || \
                { rm -f "${aTGT_FILE_CSOLD["$IMAGE_CSALGO"]}";
                  die "Could not generate '${aTGT_FILE_CSOLD["$IMAGE_CSALGO"]}'"; }
            fi
        fi
    done
    case "$LOCAL_CHECKSUMS_MATCHED" in
        -1) # Should not happen unless CHECKSUM_ALGOLIST_DEFAULT is empty
            logmsg_warn "Downloaded checksums were not tested for $REPORT_IMAGETYPE"
            if [ "${CHECKSUM_REQUIRED-}" != true ]; then
                die "At least one checksum should be downloadable (and matching) for '${aTGT_FILE}'"
            fi
            ;;
        0)  ;; # At least one was tested, and all present checksums were ok
        *)  # Should not get here due to return above
            die "At least one checksum did not match for '${aTGT_FILE}'"
            ;;
    esac

    # Finally check that expected files are all here - and note at this
    # point it includes the whole CHECKSUM_ALGOLIST_DEFAULT matrix
    # TODO: Verify file size against partition size (flashability after reboot)
    [ -s "${aTGT_FILE}" ] \
        || die "Could not find '${aTGT_FILE}' or it was found empty"

    [ -s "${aTGT_FILE_MANIFEST}" ] \
        && touch -r "${aTGT_FILE}" "${aTGT_FILE_MANIFEST}" \
        || logmsg_warn "Could not find manifest file '${aTGT_FILE_MANIFEST}' or it was found empty"

    for IMAGE_CSALGO in ${CHECKSUM_ALGOLIST_DEFAULT} ; do
        [ -s "${aTGT_FILE_CSOLD["$IMAGE_CSALGO"]}" ] \
        && touch -r "${aTGT_FILE}" "${aTGT_FILE_CSOLD["$IMAGE_CSALGO"]}" \
        || die "Could not touch '${aTGT_FILE_CSOLD["$IMAGE_CSALGO"]}' or it was found empty"
    done

    # TODO: This should be created and properly owned via systemd-tmpfiles
    # TODO: By the licensing-aware updates design, the new candidate image's
    # copy of the generalized upgradeability validation routine should be
    # called, probably via chroot, applying that new version's concepts of
    # what is valid - which our old deployed version just can not know.
    # This chroot should happen after the currently deployed version has
    # confirmed trust to that new image, however (checksums/signatures).
    mkdir -p /var/lib/fty/sw-update/ && \
    ( etn-sw-update --add-image "${aTGT_FILE}" || echo "$?" > "/var/lib/fty/sw-update/activation_requested" ) && \
    logmsg_info "Got $REPORT_IMAGETYPE OK:" && \
    ls -ld "${aTGT_FILE}" "${aTGT_FILE_CSOLD[@]}" "${aTGT_FILE_MANIFEST}" && \
    cat "${aTGT_FILE_CSOLD[@]}" && \
    { echo "${aTGT_FILE}" > "${DOWNLOADROOT_OSIMAGE}/.newest-osimage";
      echo "${aTGT_FILE}" > "${REFER_NEWEST}";
      return 42; }
)

removeold_osimage() (
    local REPORT_IMAGETYPE='OS image'
    cd "${DOWNLOADROOT_OSIMAGE}" || die "Can not use DOWNLOADROOT_OSIMAGE='$DOWNLOADROOT_OSIMAGE'"
    # Sort of implementation for BIOS-1566 snatched from bios-boot::Makefile
    # This removes all but the newest (alphabetically) files for the pattern
    # TODO: add support for hierarchical namespace (container hosts) with
    #       flattened or original filenames inside
    if [ -z "$DOWNLOADED_OS_IMAGE" ] && [ "$ACTION_DOWNLOAD_OSIMAGE" != "no" ] ; then
        [ -s "${TEMP_DATA}/.newest-osimage" ] \
        && DOWNLOADED_OS_IMAGE="`head -1 "${TEMP_DATA}/.newest-osimage"`" \
        && [ -n "$DOWNLOADED_OS_IMAGE" ] && [ -s "$DOWNLOADED_OS_IMAGE" ] \
        || DOWNLOADED_OS_IMAGE=""
    fi
    VICTIMS=0
    VICTIMPATHS=""
    if [ x"$FLAG_FLATTEN_FILENAMES" = xno ] ; then
        [ -d "./$IMGTYPE/$ARCH" ] && cd "./$IMGTYPE/$ARCH"
        # Alphabetic sort, per timestamps from the builder host
        # but considering the rebuild-suffixes of same baseline
        # Note that if there is a mix of images from different
        # products, then the "newest" one alphabetically may be
        # from a different line-up and not quite the one we
        # could have intended to keep. A forceflash file can
        # fix which image must be applied during next boot
        # (and others deleted by low-level init-script).
        for F in `ls -1d *.${EXT} 2>/dev/null | grep -v _ | sort_osimage_names | head -n -1` ; do
            [ -n "$F" ] && [ -f "$F" ] && \
            if [ -n "$DOWNLOADED_OS_IMAGE" ] && [ -s "$DOWNLOADED_OS_IMAGE" ] && \
                [ "$F" = "`basename "$DOWNLOADED_OS_IMAGE"`" ]; then
                    logmsg_info "Keeping the just-downloaded $REPORT_IMAGETYPE: '$DOWNLOADED_OS_IMAGE'"
            else
                logmsg_info "Removing older $REPORT_IMAGETYPE: '`pwd`/$F' and its checksum(s)"
                remove_image "$F"
                VICTIMS=$(($VICTIMS+1))
                VICTIMPATHS="$VICTIMPATHS $F*"
            fi
        done
    fi

    # For flattened filenames, including those fetched like this from the build
    # server, the "other" image types can block automated updates after reboot
    # (e.g. `devel` always begins alphabetically "newer" than `deploy`).
    # Here we choose the file to keep by timestamp (from the source server).
    for F in \
        `ls -1dt *__${ARCH}__${IMGTYPE}.${EXT} ${IMGTYPE}-*_${ARCH}.${EXT} 2>/dev/null | tail -n +2` \
        `ls -1d *__${ARCH}__*.${EXT} 2>/dev/null | grep -v "__${ARCH}__${IMGTYPE}.${EXT}"` \
        `ls -1d *_${ARCH}.${EXT} 2>/dev/null | grep -v "${IMGTYPE}-.*_${ARCH}.${EXT}"` \
    ; do
        [ -n "$F" ] && [ -f "$F" ] && \
        logmsg_info "Removing older $REPORT_IMAGETYPE: '`pwd`/$F' and its checksum(s)" && \
        if [ -n "$DOWNLOADED_OS_IMAGE" ] && [ -s "$DOWNLOADED_OS_IMAGE" ] && \
            [ "$F" = "`basename "$DOWNLOADED_OS_IMAGE"`" ]; then
                logmsg_info "Keeping the just-downloaded $REPORT_IMAGETYPE: '$DOWNLOADED_OS_IMAGE'"
        else
            remove_image "$F"
            VICTIMS=$(($VICTIMS+1))
            VICTIMPATHS="$VICTIMPATHS $F*"
        fi
    done

    [ "$VICTIMS" -eq 0 ] && logmsg_info "removeold_osimage() had nothing to remove" || \
        logmsg_info "removeold_osimage() requested to remove $VICTIMS file(s): $VICTIMPATHS"
    return 0
)

##################################################

findnewest_rawfwimage_uboot() (
    # Echo the URL to the newest "raw" (not tarballed, only one)
    # uBoot image file found on remote resource, if any
    # Note: currently expects certain filename patterns and http-dir listing markup
    for P in 'u-Boot' 'uBoot' ; do
        IMAGE_URL="`lsdir_http_pattern "${SOURCESITEROOTFW_UBOOT}" "$P" | sort -n | tail -1`"
        if [ $? = 0 -a x"$IMAGE_URL" != x ]; then
            echo "$IMAGE_URL" && return 0
        fi
    done
    logmsg_error "Error looking up remote file: Make sure your settings (including proxy if needed) are correct."
    return 1
)

download_rawfwimage_uboot() (
    download_rawfwimage_generic \
        'download_rawfwimage_uboot' \
        'u-Boot loader image' \
        "${TEMP_DATA}/.newest-uboot" \
        "DOWNLOADROOTFW_UBOOT" "${DOWNLOADROOTFW_UBOOT}" \
        "DEPLOYMENTROOTFW_UBOOT" "${DEPLOYMENTROOTFW_UBOOT}" \
        "${SOURCESITEROOTFW_UBOOT}" \
        'findnewest_rawfwimage_uboot' \
        "/dev/mtd$UBOOT_MTD"
)

removeold_rawfwimage_uboot() (
    local REPORT_IMAGETYPE='u-Boot loader image'
    cd "${DOWNLOADROOTFW_UBOOT}" || \
    cd "${DEPLOYMENTROOTFW_UBOOT}" || die "Can not use DOWNLOADROOTFW_UBOOT='$DOWNLOADROOTFW_UBOOT' nor DEPLOYMENTROOTFW_UBOOT='$DEPLOYMENTROOTFW_UBOOT'"
    if [ -z "$DOWNLOADED_FW_UBOOT" ] ; then
        [ -s "${TEMP_DATA}/.newest-uboot" ] \
        && DOWNLOADED_FW_UBOOT="`head -1 "${TEMP_DATA}/.newest-uboot"`" \
        && [ -n "$DOWNLOADED_FW_UBOOT" ] && [ -s "$DOWNLOADED_FW_UBOOT" ] \
        || DOWNLOADED_FW_UBOOT=""
    fi
    VICTIMS=0
    VICTIMPATHS=""
    for F in `ls -1d "${DOWNLOADROOTFW_UBOOT}"/u-Boot "${DEPLOYMENTROOTFW_UBOOT}"/u-Boot 2>/dev/null` ; do
        [ -n "$DOWNLOADED_FW_UBOOT" ] && [ -s "$DOWNLOADED_FW_UBOOT" ] && [ "$DOWNLOADED_FW_UBOOT" = "$F" ] && \
            { logmsg_info "Keeping the just-downloaded $REPORT_IMAGETYPE: '$DOWNLOADED_FW_UBOOT'" ; continue ; }
        logmsg_info "Removing older $REPORT_IMAGETYPE: '$F' and its checksum(s)"
        remove_image "$F"
        VICTIMS=$(($VICTIMS+1))
        VICTIMPATHS="$VICTIMPATHS $F*"
    done
    [ "$VICTIMS" -eq 0 ] && logmsg_info "removeold_rawfwimage_uboot() had nothing to remove" || \
        logmsg_info "removeold_rawfwimage_uboot() requested to remove $VICTIMS file(s): $VICTIMPATHS"
    return 0
)


##################################################

findnewest_rawfwimage_uimage() (
    # Echo the URL to the newest "raw" (not tarballed, only one)
    # uImage image file found on remote resource, if any
    # Note: currently expects certain filename patterns and http-dir listing markup
    IMAGE_URL="`lsdir_http_pattern "${SOURCESITEROOTFW_UIMAGE}" "uImage" | sort -n | tail -1`"
    if [ $? = 0 -a x"$IMAGE_URL" != x ]; then
        echo "$IMAGE_URL" && return 0
    fi
    logmsg_error "Error looking up remote file: Make sure your settings (including proxy if needed) are correct."
    return 1
)

download_rawfwimage_uimage() (
    download_rawfwimage_generic \
        'download_rawfwimage_uimage' \
        'kernel uImage' \
        "${TEMP_DATA}/.newest-uimage" \
        "DOWNLOADROOTFW_UIMAGE" "${DOWNLOADROOTFW_UIMAGE}" \
        "DEPLOYMENTROOTFW_UIMAGE" "${DEPLOYMENTROOTFW_UIMAGE}" \
        "${SOURCESITEROOTFW_UIMAGE}" \
        'findnewest_rawfwimage_uimage' \
        "/dev/mtd$KERNEL_MTD"
)

removeold_rawfwimage_uimage() (
    local REPORT_IMAGETYPE='kernel uImage'
    cd "${DOWNLOADROOTFW_UIMAGE}" || \
    cd "${DEPLOYMENTROOTFW_UIMAGE}" || die "Can not use DOWNLOADROOTFW_UIMAGE='$DOWNLOADROOTFW_UIMAGE' nor DEPLOYMENTROOTFW_UIMAGE='$DEPLOYMENTROOTFW_UIMAGE'"
    if [ -z "$DOWNLOADED_FW_UIMAGE" ] ; then
        [ -s "${TEMP_DATA}/.newest-uimage" ] \
        && DOWNLOADED_FW_UIMAGE="`head -1 "${TEMP_DATA}/.newest-uimage"`" \
        && [ -n "$DOWNLOADED_FW_UIMAGE" ] && [ -s "$DOWNLOADED_FW_UIMAGE" ] \
        || DOWNLOADED_FW_UIMAGE=""
    fi
    VICTIMS=0
    VICTIMPATHS=""
    for F in `ls -1d "${DOWNLOADROOTFW_UIMAGE}"/uImage "${DEPLOYMENTROOTFW_UIMAGE}"/uImage 2>/dev/null` ; do
        [ -n "$DOWNLOADED_FW_UIMAGE" ] && [ -s "$DOWNLOADED_FW_UIMAGE" ] && [ "$DOWNLOADED_FW_UIMAGE" = "$F" ] && \
            { logmsg_info "Keeping the just-downloaded $REPORT_IMAGETYPE: '$DOWNLOADED_FW_UIMAGE'" ; continue ; }
        logmsg_info "Removing older $REPORT_IMAGETYPE: '`pwd`/$F' and its checksum(s)"
        remove_image "$F"
        VICTIMS=$(($VICTIMS+1))
        VICTIMPATHS="$VICTIMPATHS $F*"
    done
    [ "$VICTIMS" -eq 0 ] && logmsg_info "removeold_rawfwimage_uimage() had nothing to remove" || \
        logmsg_info "removeold_rawfwimage_uimage() requested to remove $VICTIMS file(s): $VICTIMPATHS"
    return 0
)

##################################################

sort_module_names() (
    # ASSUMPTION: we don't have over 99999 positions in a kernel version number
    # Alas, greedy-match does not work well when the two hits overlap (3.18.44
    # with two two-digit hits), so we have to loop like below.
    while IFS='' read INLINE ; do
        LN="$INLINE"
        LO=""
        for RE in \
            's,\([\.\-]\)\([[:digit:]][[:digit:]][[:digit:]][[:digit:]]\)\(\.\),\1_0\2_\3,g' \
            's,\([\.\-]\)\([[:digit:]][[:digit:]][[:digit:]]\)\(\.\),\1_00\2_\3,g' \
            's,\([\.\-]\)\([[:digit:]][[:digit:]]\)\(\.\),\1_000\2_\3,g' \
            's,\([\.\-]\)\([[:digit:]]\)\(\.\),\1_0000\2_\3,g' \
        ; do
            LO=""
            while [ x"$LN" != x"$LO" ]; do
                LO="$LN"
                LN="`echo "$LO" | sed "$RE"`"
            done
        done
        echo "$LN"
    done \
    | sort -n | \
    sed -e 's,\([\.\-]\)_0*\([123456789][[:digit:]]*\)_,\1\2,g' \
        -e 's,\([\.\-]\)_00*_,\10,'
)

findnewest_rawfwimage_modules() (
    # Echo the URL to the newest "raw" (not tarballed, only one)
    # uImage image file found on remote resource, if any
    # Note: currently expects certain filename patterns and http-dir listing markup
    IMAGE_URL="`lsdir_http_pattern "${SOURCESITEROOTFW_MODULES}" "*[0-9].[0-9]*.${EXT}" | sort_module_names | tail -1`"
    if [ $? = 0 -a x"$IMAGE_URL" != x ]; then
        echo "$IMAGE_URL" && return 0
    fi
    logmsg_error "Error looking up remote file: Make sure your settings (including proxy if needed) are correct."
    return 1
)

download_rawfwimage_modules() (
    download_rawfwimage_generic \
        'download_rawfwimage_modules' \
        'kernel modules archive' \
        "${TEMP_DATA}/.newest-modules" \
        "DOWNLOADROOTFW_MODULES" "${DOWNLOADROOTFW_MODULES}" \
        "DEPLOYMENTROOTFW_MODULES" "${DEPLOYMENTROOTFW_MODULES}" \
        "${SOURCESITEROOTFW_MODULES}" \
        'findnewest_rawfwimage_modules' \
        ""
)

removeold_rawfwimage_modules() (
    local REPORT_IMAGETYPE='kernel modules archive'
    cd "${DOWNLOADROOTFW_MODULES}" || \
    cd "${DEPLOYMENTROOTFW_MODULES}" || die "Can not use DOWNLOADROOTFW_MODULES='$DOWNLOADROOTFW_MODULES' nor DEPLOYMENTROOTFW_MODULES='$DEPLOYMENTROOTFW_MODULES'"
    if [ -z "$DOWNLOADED_FW_MODULES" ] ; then
        [ -s "${TEMP_DATA}/.newest-modules" ] \
        && DOWNLOADED_FW_MODULES="`head -1 "${TEMP_DATA}/.newest-modules"`" \
        && [ -n "$DOWNLOADED_FW_MODULES" ] && [ -s "$DOWNLOADED_FW_MODULES" ] \
        || DOWNLOADED_FW_MODULES=""
    fi
    VICTIMS=0
    VICTIMPATHS=""
    for F in `ls -1d "${DOWNLOADROOTFW_MODULES}"/*[0-9]*.*[0-9]*.${EXT} "${DEPLOYMENTROOTFW_MODULES}"/*[0-9]*.*[0-9]*.${EXT} 2>/dev/null` ; do
        [ -n "$DOWNLOADED_FW_MODULES" ] && [ -s "$DOWNLOADED_FW_MODULES" ] && [ "$DOWNLOADED_FW_MODULES" = "$F" ] && \
            { logmsg_info "Keeping the just-downloaded $REPORT_IMAGETYPE: '$DOWNLOADED_FW_MODULES'" ; continue ; }
        logmsg_info "Removing older $REPORT_IMAGETYPE: '`pwd`/$F' and its checksum(s)"
        remove_image "$F"
        VICTIMS=$(($VICTIMS+1))
        VICTIMPATHS="$VICTIMPATHS $F*"
    done
    [ "$VICTIMS" -eq 0 ] && logmsg_info "removeold_rawfwimage_modules() had nothing to remove" || \
        logmsg_info "removeold_rawfwimage_modules() requested to remove $VICTIMS file(s): $VICTIMPATHS"
    return 0
)

# Value discovered below, after all settings are slurped
FACTORY_RESET_TTL_EXPIRED=""
process_FACTORY_RESET_TTL_EXPIRED() {
	# If files exist... report them or wipe...
	if [ -n "$FACTORY_RESET_TTL_EXPIRED" ]; then
		if [ "$FLAG_ERASE_FACTORYRESETFAILED" = yes ]; then
			logmsg_info "Per administrative request, removing flag-file(s) about previously failed factory reset:" \
				"`ls -la $FACTORY_RESET_TTL_EXPIRED 2>/dev/null`"
			rm -f $FACTORY_RESET_TTL_EXPIRED
		else
			logmsg_warn "Found flag-file(s) about previously failed factory reset:" \
				"`ls -la $FACTORY_RESET_TTL_EXPIRED 2>/dev/null`" \
				"You can clear this warning with $0 --clear-failed-factory-reset"
		fi
	fi
}

# Discover recent download/check "best candidates" results
# and populate corresponding variables
learn_downloaded_images() {
	[ -s "${TEMP_DATA}/.newest-osimage" ] && \
		DOWNLOADED_OS_IMAGE="`head -1 "${TEMP_DATA}/.newest-osimage"`" && \
		[ -n "$DOWNLOADED_OS_IMAGE" ] && [ -s "$DOWNLOADED_OS_IMAGE" ] || \
		DOWNLOADED_OS_IMAGE=""
	if [ -z "$DOWNLOADED_OS_IMAGE" ] ; then
		[ -s "$DOWNLOADROOT_OSIMAGE/.newest-osimage" ] && \
		DOWNLOADED_OS_IMAGE="`head -1 "$DOWNLOADROOT_OSIMAGE/.newest-osimage"`" && \
		[ -n "$DOWNLOADED_OS_IMAGE" ] && [ -s "$DOWNLOADED_OS_IMAGE" ] || \
		DOWNLOADED_OS_IMAGE=""
	fi

	[ -s "${TEMP_DATA}/.newest-uboot" ] && \
		DOWNLOADED_FW_UBOOT="`head -1 "${TEMP_DATA}/.newest-uboot"`" && \
		[ -n "$DOWNLOADED_FW_UBOOT" ] && [ -s "$DOWNLOADED_FW_UBOOT" ] || \
		DOWNLOADED_FW_UBOOT=""

	[ -s "${TEMP_DATA}/.newest-uimage" ] && \
		DOWNLOADED_FW_UIMAGE="`head -1 "${TEMP_DATA}/.newest-uimage"`" && \
		[ -n "$DOWNLOADED_FW_UIMAGE" ] && [ -s "$DOWNLOADED_FW_UIMAGE" ] || \
		DOWNLOADED_FW_UIMAGE=""

	[ -s "${TEMP_DATA}/.newest-modules" ] && \
		DOWNLOADED_FW_MODULES="`head -1 "${TEMP_DATA}/.newest-modules"`" && \
		[ -n "$DOWNLOADED_FW_MODULES" ] && [ -s "$DOWNLOADED_FW_MODULES" ] || \
		DOWNLOADED_FW_MODULES=""
}

###########################################################################
### Start of application logic
###########################################################################

logmsg_info "`date`: Starting ${_SCRIPT_PATH} ${_SCRIPT_ARGS}"

case "$*" in
	*--no-config-file*) logmsg_info "NOT sourcing configs from /etc/update-rc3.d/" ;;
	*)
		if [ -d "/etc/update-rc3.d/" ]; then
			for F in "/etc/update-rc3.d/"*.conf ; do
				if [ -s "$F" ] && [ -r "$F" ] ; then
					logmsg_info "Sourcing configuration file: '$F' ..."
					. "$F" || logmsg_error "Possibly got an error sourcing '$F', see above..."
				fi
			done
		fi
		;;
esac
# After loading what was defined, if anything, set up the yet-unknown values:
config_defaults

# TODO: Locking against multiple runs
# TODO: define CLI methods for status/size/... checks per BIOS-1563
# TODO: Free space verification before download - BIOS-1562?
# TODO: Expose more methods via CLI, e.g. to verify checksums of an image file
# TODO: Methods to compare if we have a candidate image newer than flashed bits
#       (and so if the user should reboot)

ACTION_DOWNLOAD_OSIMAGE="yes"
ACTION_DOWNLOAD_FWIMAGE="yes"

ACTION_CHECK_OSIMAGE="no"
ACTION_CHECK_FWIMAGE="no"

# If any of these is "yes", and a corresponding image was downloaded during
# this run (or validated as still up-to-date), touch its ".forceflash" file
# after removing any existing ".forceflash" files for this category, if any.
# No-op if nothing was downloaded/validated during this run for the category.
ACTION_FORCEFLASH_OSIMAGE="no"
ACTION_FORCEFLASH_FWIMAGE_UBOOT="no"
ACTION_FORCEFLASH_FWIMAGE_UIMAGE="no"
# Remove any existing .forceflash flag-files before any check or download
# (does not fire for a mere "-ls" activity)
ACTION_FORCEFLASH_CLEANUP="no"

# The routines can force a specific URL rather than detecting the "newest" one
[ -z "${URL_DOWNLOAD_OSIMAGE-}" ] &&                URL_DOWNLOAD_OSIMAGE=""
[ -z "${URL_DOWNLOAD_FWIMAGE_RAW_UBOOT-}" ] &&      URL_DOWNLOAD_FWIMAGE_RAW_UBOOT=""
[ -z "${URL_DOWNLOAD_FWIMAGE_RAW_UIMAGE-}" ] &&     URL_DOWNLOAD_FWIMAGE_RAW_UIMAGE=""
[ -z "${URL_DOWNLOAD_FWIMAGE_RAW_MODULES-}" ] &&    URL_DOWNLOAD_FWIMAGE_RAW_MODULES=""

ACTION_REMOVEOLD_OSIMAGE="yes"
# This is currently no-op because we only track "raw" FW images which have one
# data file per fwimage sub-type, unpacked on remote server
# TODO: Support creation, download and installation of timestamped FW tarballs
ACTION_REMOVEOLD_FWIMAGE="no"

# Ultimate exit code of the script
ACTION_RESULT=0

# Exclude this (base) filename from removeold_*image() hit-list
# since it was downloaded and/or tested OK during this run.
# Also used to set forceflash flags, if requested.
DOWNLOADED_OS_IMAGE=""
DOWNLOADED_FW_UBOOT=""
DOWNLOADED_FW_UIMAGE=""
DOWNLOADED_FW_MODULES=""
export DOWNLOADED_OS_IMAGE DOWNLOADED_FW_UBOOT DOWNLOADED_FW_UIMAGE DOWNLOADED_FW_MODULES

# Note: /mnt/ext is in the list just in case rogue data is around.
FACTORY_RESET_TTL_EXPIRED=""
for F in \
	/mnt/ext/recovery/factory_reset \
	/mnt/nand/factory_reset \
	/mnt/mmc/recovery/factory_reset \
	"$DEPLOYMENTROOT/factory_reset" \
	"$DOWNLOADROOT/factory_reset" \
; do
        [ -f "$F.ttl-expired" ] && FACTORY_RESET_TTL_EXPIRED="`echo "$F.ttl-expired
$FACTORY_RESET_TTL_EXPIRED" | sort | uniq`"
done

# Hold small recent downloads, reference files, etc.
TEMP_DATA="`mktemp -d /var/run/.update-rc3.$$.XXXXXX`" && [ -n "$TEMP_DATA" ] && [ -d "$TEMP_DATA" ] \
|| { TEMP_DATA="`mktemp -d /tmp/.update-rc3.$$.XXXXXX`" && [ -n "$TEMP_DATA" ] && [ -d "$TEMP_DATA" ] ; } \
|| { TEMP_DATA="/tmp/.update-rc3.$$" && rm -rf "${TEMP_DATA}" && mkdir -p "$TEMP_DATA" ; } \
|| die "Can not make a TEMP_DATA directory"
export TEMP_DATA
TRAP_SIGNALS="HUP INT QUIT TERM EXIT" settraps "rm -rf '${TEMP_DATA}'"

while [ $# -gt 0 ]; do
	case "${1-}" in
		-h|--help|-help)        usage; exit 0 ;;
		--debug-calls|--debug-calls-x)
		    if [ $# -eq 1 ]; then
		        die "The '$1' option requires further arguments"
		    fi
		    [ "$1" = "--debug-calls" ] && shift || { shift; set -xv; }
		    "$@" ; exit $? ;;
		-c|--config) [ -n "$2" ] && [ -s "$2" ] && [ -r "$2" ] && \
		        logmsg_info "Sourcing configuration file: '$2' ..." && \
		        . "$2" || die "Possibly got an error sourcing '$2', see above..."
		    shift ;;
		--no-config-file) ;; # Processed above
		-ls)
			RES=0
			lsdir_http_pattern "${SOURCESITEROOTFW_UBOOT}" "uBoot*" \
				| egrep -v '\.(md5|sha256|cksum'"${CHECKSUM_ALGO_DEFAULT:+|$CHECKSUM_ALGO_DEFAULT}"')$' || RES=$?
			lsdir_http_pattern "${SOURCESITEROOTFW_UBOOT}" "u-Boot*" \
				| egrep -v '\.(md5|sha256|cksum'"${CHECKSUM_ALGO_DEFAULT:+|$CHECKSUM_ALGO_DEFAULT}"')$' || RES=$?
			lsdir_http_pattern "${SOURCESITEROOTFW_UIMAGE}" "uImage*" \
				| egrep -v '\.(md5|sha256|cksum'"${CHECKSUM_ALGO_DEFAULT:+|$CHECKSUM_ALGO_DEFAULT}"')$' || RES=$?
			lsdir_http_pattern "${SOURCESITEROOTFW_MODULES}" "*[0-9].[0-9]*.${EXT}*" \
				| egrep -v '\.(md5|sha256|cksum'"${CHECKSUM_ALGO_DEFAULT:+|$CHECKSUM_ALGO_DEFAULT}"')$' || RES=$?
			lsdir_http_pattern "${SOURCESITEROOT_OSIMAGE}" "${SOURCESITEROOT_OSIMAGE_FILENAMEPATTERN}.${EXT}" \
				| sort_osimage_names \
				| egrep -v '\.(md5|sha256|cksum'"${CHECKSUM_ALGO_DEFAULT:+|$CHECKSUM_ALGO_DEFAULT}"')$' || RES=$?

			summarize_check() {
				IMG="$1"
				shift
				OUT="`CHECK_ONLY=yes "$@" 2>&1`"
				sRES=$?
				case "$sRES" in
					0) echo "$IMG: Local is up-to-date" ;;
					42) echo "$IMG: Newest remote is different";;
					*) echo "$IMG: Some error ($sRES):"; echo "$OUT";;
				esac
				return $sRES
			}

			summarize_check "OSIMAGE" download_osimage $URL_DOWNLOAD_OSIMAGE &
			PID1=$!
			summarize_check "KERNEL-UIMAGE"  download_rawfwimage_uimage  $URL_DOWNLOAD_FWIMAGE_RAW_UIMAGE &
			PID2=$!
			summarize_check "KERNEL-MODULES" download_rawfwimage_modules $URL_DOWNLOAD_FWIMAGE_RAW_MODULES &
			PID3=$!
			summarize_check "LOADER-UBOOT"   download_rawfwimage_uboot   $URL_DOWNLOAD_FWIMAGE_RAW_UBOOT &
			PID4=$!
			for P in $PID1 $PID2 $PID3 $PID4 ; do wait $P || RES=$? ; done
			wait || RES=$?
			process_FACTORY_RESET_TTL_EXPIRED
			exit $RES
			;;
		--remove-files)         FLAG_CAN_REMOVE_IMAGES="yes";;
		--no-remove-files)      FLAG_CAN_REMOVE_IMAGES="no";;
		--flatten-filenames)    FLAG_FLATTEN_FILENAMES="yes";;
		--no-flatten-filenames) FLAG_FLATTEN_FILENAMES="no";;
		--download-image-os)    ACTION_DOWNLOAD_OSIMAGE="yes";;
		--download-image-fw)    ACTION_DOWNLOAD_FWIMAGE="yes";;
		--download-images)      ACTION_DOWNLOAD_OSIMAGE="yes"; ACTION_DOWNLOAD_FWIMAGE="yes";;
		--no-download-image-os) ACTION_DOWNLOAD_OSIMAGE="no"; ACTION_REMOVEOLD_OSIMAGE="no";;
		--no-download-image-fw) ACTION_DOWNLOAD_FWIMAGE="no";;
		--no-download-images|-N)ACTION_DOWNLOAD_OSIMAGE="no"; ACTION_REMOVEOLD_OSIMAGE="no"; ACTION_DOWNLOAD_FWIMAGE="no";;
		--fw-only)              ACTION_DOWNLOAD_OSIMAGE="no"; ACTION_REMOVEOLD_OSIMAGE="no"; ACTION_DOWNLOAD_FWIMAGE="yes";;
		--os-only)              ACTION_DOWNLOAD_OSIMAGE="yes"; ACTION_DOWNLOAD_FWIMAGE="no";;
		--check-image-os)       ACTION_CHECK_OSIMAGE="yes";;
		--check-image-fw)       ACTION_CHECK_FWIMAGE="yes";;
		--check-images|-n|--dry-run)
		                        ACTION_CHECK_OSIMAGE="yes"; ACTION_CHECK_FWIMAGE="yes";;
		--no-check-image-os)    ACTION_CHECK_OSIMAGE="no";;
		--no-check-image-fw)    ACTION_CHECK_FWIMAGE="no";;
		--no-check-images)      ACTION_CHECK_OSIMAGE="no"; ACTION_CHECK_FWIMAGE="no";;
		--url-image-*|-U)
		    [ $# -eq 1 ] && die "The '$1' option requires a further argument"
		    case "${1-}" in
		        --url-image-os|-U)          URL_DOWNLOAD_OSIMAGE="$2"; shift;;
		        --url-image-fw-raw-uboot)   URL_DOWNLOAD_FWIMAGE_RAW_UBOOT="$2"; shift;;
		        --url-image-fw-raw-uimage)  URL_DOWNLOAD_FWIMAGE_RAW_UIMAGE="$2"; shift;;
		        --url-image-fw-raw-modules) URL_DOWNLOAD_FWIMAGE_RAW_MODULES="$2"; shift;;
		        *)  die "Aborting due to unknown command-line argument(s): $*" ;;
		    esac ;;
		--removeold-image-os)   ACTION_REMOVEOLD_OSIMAGE="yes";;
		--removeold-image-fw)   ACTION_REMOVEOLD_FWIMAGE="yes";;
		--removeold-images)     ACTION_REMOVEOLD_OSIMAGE="yes"; ACTION_REMOVEOLD_FWIMAGE="yes";;
		--no-removeold-image-os)ACTION_REMOVEOLD_OSIMAGE="no";;
		--no-removeold-image-fw)ACTION_REMOVEOLD_FWIMAGE="no";;
		--no-removeold-images)  ACTION_REMOVEOLD_OSIMAGE="no"; ACTION_REMOVEOLD_FWIMAGE="no";;
		--erase-factory-reset)
		                        FLAG_ERASE_FACTORYRESET="yes" ;;
		--touch-factory-reset|--force-factory-reset|-FR)
		                        FLAG_ERASE_FACTORYRESET="force" ;;
		--no-erase-factory-reset|--clear-factory-reset|-NR)
					FLAG_ERASE_FACTORYRESET="no" ;;
		--clear-failed-factory-reset|-FFR)
		                        FLAG_ERASE_FACTORYRESETFAILED="yes" ;;
		--erase-all)            FLAG_ERASE_ALL="yes" ;;
		--touch-erase-all|--force-erase-all)
		                        FLAG_ERASE_ALL="force" ;;
		--no-forceflash|--no-FF|-NFF)
		                        ACTION_FORCEFLASH_CLEANUP="yes" ;;
		--forceflash-image|-FF)
		                        ACTION_FORCEFLASH_OSIMAGE="yes"
		                        ACTION_FORCEFLASH_FWIMAGE_UBOOT="yes"
		                        ACTION_FORCEFLASH_FWIMAGE_UIMAGE="yes"
		                        ;;
		--forceflash-image-fw|--forceflash-image-FW|-FFf)
		                        ACTION_FORCEFLASH_FWIMAGE_UBOOT="yes"
		                        ACTION_FORCEFLASH_FWIMAGE_UIMAGE="yes"
		                        ;;
		--forceflash-image-os|--forceflash-image-OS|-FFo)
		                        ACTION_FORCEFLASH_OSIMAGE="yes"
		                        ;;
		--forceflash-image-u-Boot|--forceflash-image-uBoot|--forceflash-image-uboot|--forceflash-image-u-boot|-FFb)
		                        ACTION_FORCEFLASH_FWIMAGE_UBOOT="yes"
		                        ;;
		--forceflash-image-uImage|--forceflash-image-uimage|-FFi)
		                        ACTION_FORCEFLASH_FWIMAGE_UIMAGE="yes"
		                        ;;
		--no-erase-all)         FLAG_ERASE_ALL="no" ;;
		--reboot|-r)            WANT_REBOOT="yes" ;; # reboot if code 42 - got new files ok
		-R)                     WANT_REBOOT="force" ;; # reboot if exitcode 0 or 42
		--oem-finish)
		    [ "${WANT_REBOOT-}" = yes -o "${WANT_REBOOT-}" = force ] && DO_REBOOT=yes
		    logmsg_warn "Preparing for an OEM finish, wiping this controller during next boot"
		    echo "Press Ctrl+C within 5 seconds to abort!" >&2
		    sleep 5
		    logmsg_warn "Proceeding with an OEM finish, requesting to wipe this controller during next boot"
		    touch "$DEPLOYMENTROOT/factory_reset"
		    # Favor to skip badblocks search for the first user-facing bootup
		    # and reformat the MMC after all the transportation and storage
		    echo "yes-bb-skip" > "$DEPLOYMENTROOT/reformat-MMCp1"
		    if [ "$DO_REBOOT" = yes ]; then
		        logmsg_warn "Was asked to reboot... trying to do so..."
		        sync
		        init 6
		    else
		        logmsg_warn "Was asked to shut down for power-off... trying to do so..."
		        sync
		        poweroff
		    fi
		    die "Should not get to this line after requesting power-off..."
		    ;;
		*)  die "Aborting due to unknown command-line argument(s): $*" ;;
	esac
	shift
done
if test -z "$DOWNLOADROOTFW_UBOOT"; then
	ACTION_DOWNLOAD_FWIMAGE=no
fi

if [ x"$ACTION_FORCEFLASH_CLEANUP" = xyes ]; then
	rm -f "${DEPLOYMENTROOTFW_UBOOT}/u-Boot.forceflash" "${DOWNLOADROOTFW_UBOOT}/u-Boot.forceflash"
	rm -f "${DEPLOYMENTROOTFW_UIMAGE}/uImage.forceflash" "${DOWNLOADROOTFW_UIMAGE}/uImage.forceflash"
	rm -f "${DEPLOYMENTROOT_OSIMAGE}"/*.forceflash "${DOWNLOADROOT_OSIMAGE}"/*.forceflash
fi

# Checks are special - after we do all which were requested (if any), we exit
if [ x"$ACTION_CHECK_OSIMAGE" = xyes ] || [ x"$ACTION_CHECK_FWIMAGE" = xyes ]; then
	RESULT_ACTION_CHECK_OSIMAGE=-1
	RESULT_ACTION_CHECK_UBOOT=-1
	RESULT_ACTION_CHECK_UIMAGE=-1
	RESULT_ACTION_CHECK_MODULES=-1
	RESULT_ACTION_CHECK_ANYIMAGE=-1
	if [ x"$ACTION_CHECK_OSIMAGE" = xyes ]; then
		CHECK_ONLY=yes download_osimage $URL_DOWNLOAD_OSIMAGE; RESULT_ACTION_CHECK_OSIMAGE=$?
	fi
	if [ x"$ACTION_CHECK_FWIMAGE" = xyes ]; then
		CHECK_ONLY=yes download_rawfwimage_uboot   $URL_DOWNLOAD_FWIMAGE_RAW_UBOOT   ; RESULT_ACTION_CHECK_UBOOT=$?
		CHECK_ONLY=yes download_rawfwimage_uimage  $URL_DOWNLOAD_FWIMAGE_RAW_UIMAGE  ; RESULT_ACTION_CHECK_UIMAGE=$?
		CHECK_ONLY=yes download_rawfwimage_modules $URL_DOWNLOAD_FWIMAGE_RAW_MODULES ; RESULT_ACTION_CHECK_MODULES=$?
	fi
	learn_downloaded_images
	for RES_STR in $RESULT_ACTION_CHECK_OSIMAGE $RESULT_ACTION_CHECK_UBOOT $RESULT_ACTION_CHECK_UIMAGE $RESULT_ACTION_CHECK_MODULES ; do
		[ "$RES_STR" -gt "$RESULT_ACTION_CHECK_ANYIMAGE" ] && RESULT_ACTION_CHECK_ANYIMAGE="$RES_STR"
	done
	RES_STR="$RESULT_ACTION_CHECK_ANYIMAGE"
	case "$RESULT_ACTION_CHECK_ANYIMAGE" in
		0)  RES_STR="$RESULT_ACTION_CHECK_ANYIMAGE = All checked local files are OK, but there is nothing new to download" ;;
		42) RES_STR="$RESULT_ACTION_CHECK_ANYIMAGE = Should download something different from what we have locally" ;;
	esac
	if [ "$ACTION_FORCEFLASH_FWIMAGE_UBOOT" = yes  -a "$RESULT_ACTION_CHECK_UBOOT" = 0 ] ; then
		logmsg_info "Adding a touch of u-Boot forceflash, as requested"
		rm -f "${DEPLOYMENTROOTFW_UBOOT}/u-Boot.forceflash" "${DOWNLOADROOTFW_UBOOT}/u-Boot.forceflash"
		case "${DOWNLOADED_FW_UBOOT}" in
			/dev*) [ "$ACTION_REMOVEOLD_FWIMAGE" = yes ] && removeold_rawfwimage_uboot ;;
			*)
				[ -n "${DOWNLOADED_FW_UBOOT}" ] && [ -s "${DOWNLOADED_FW_UBOOT}" ] && touch "${DOWNLOADED_FW_UBOOT}.forceflash" ;;
		esac
	fi
	if [ "$ACTION_FORCEFLASH_FWIMAGE_UIMAGE" = yes -a "$RESULT_ACTION_CHECK_UIMAGE" = 0 ] ; then
		logmsg_info "Adding a touch of uImage forceflash, as requested"
		rm -f "${DEPLOYMENTROOTFW_UIMAGE}/uImage.forceflash" "${DOWNLOADROOTFW_UIMAGE}/uImage.forceflash"
		case "${DOWNLOADED_FW_UIMAGE}" in
			/dev*) [ "$ACTION_REMOVEOLD_FWIMAGE" = yes ] && removeold_rawfwimage_uimage ;;
			*)
				[ -n "${DOWNLOADED_FW_UIMAGE}" ] && [ -s "${DOWNLOADED_FW_UIMAGE}" ] && touch "${DOWNLOADED_FW_UIMAGE}.forceflash" ;;
		esac
	fi
	if [ "$ACTION_FORCEFLASH_OSIMAGE" = yes  -a "$RESULT_ACTION_CHECK_OSIMAGE" = 0 ] ; then
		logmsg_info "Adding a touch of OS image forceflash, as requested"
		rm -f "${DEPLOYMENTROOT_OSIMAGE}"/*.forceflash "${DOWNLOADROOT_OSIMAGE}"/*.forceflash
		[ -n "${DOWNLOADED_OS_IMAGE}" ] && [ -s "${DOWNLOADED_OS_IMAGE}" ] && touch "${DOWNLOADED_OS_IMAGE}.forceflash"
	fi
	logmsg_info "Exiting after completion of requested --check-* operations ($RES_STR)"
	exit $RESULT_ACTION_CHECK_ANYIMAGE
fi

RESULT_ACTION_DOWNLOAD_FWIMAGE=0
RESULT_ACTION_DOWNLOAD_FWIMAGE_RAW_UBOOT=0
RESULT_ACTION_DOWNLOAD_FWIMAGE_RAW_UIMAGE=0
RESULT_ACTION_DOWNLOAD_FWIMAGE_RAW_MODULES=0
if [ "$ACTION_DOWNLOAD_FWIMAGE" = yes ]; then
	download_rawfwimage_uboot $URL_DOWNLOAD_FWIMAGE_RAW_UBOOT
	RESULT_ACTION_DOWNLOAD_FWIMAGE_RAW_UBOOT=$?
	download_rawfwimage_uimage $URL_DOWNLOAD_FWIMAGE_RAW_UIMAGE
	RESULT_ACTION_DOWNLOAD_FWIMAGE_RAW_UIMAGE=$?
	download_rawfwimage_modules $URL_DOWNLOAD_FWIMAGE_RAW_MODULES
	RESULT_ACTION_DOWNLOAD_FWIMAGE_RAW_MODULES=$?

	[ "$RESULT_ACTION_DOWNLOAD_FWIMAGE_RAW_UBOOT" -gt 0 ] && \
	[ "$RESULT_ACTION_DOWNLOAD_FWIMAGE_RAW_UBOOT" -ne 42 ] && \
		ACTION_RESULT=$RESULT_ACTION_DOWNLOAD_FWIMAGE_RAW_UBOOT && \
		if [ "$ACTION_REMOVEOLD_FWIMAGE" = yes ] ; then
			logmsg_warn "New u-Boot loader image was not downloaded successfully, so old ones are not purged"
			ACTION_REMOVEOLD_FWIMAGE=no_BadDownload
		fi

	[ "$RESULT_ACTION_DOWNLOAD_FWIMAGE_RAW_UIMAGE" -gt 0 ] && \
	[ "$RESULT_ACTION_DOWNLOAD_FWIMAGE_RAW_UIMAGE" -ne 42 ] && \
		ACTION_RESULT=$RESULT_ACTION_DOWNLOAD_FWIMAGE_RAW_UIMAGE && \
		if [ "$ACTION_REMOVEOLD_FWIMAGE" = yes ] ; then
			logmsg_warn "New kernel uImage was not downloaded successfully, so old ones are not purged"
			ACTION_REMOVEOLD_FWIMAGE=no_BadDownload
		fi

	[ "$RESULT_ACTION_DOWNLOAD_FWIMAGE_RAW_MODULES" -gt 0 ] && \
	[ "$RESULT_ACTION_DOWNLOAD_FWIMAGE_RAW_MODULES" -ne 42 ] && \
		ACTION_RESULT=$RESULT_ACTION_DOWNLOAD_FWIMAGE_RAW_MODULES && \
		if [ "$ACTION_REMOVEOLD_FWIMAGE" = yes ] ; then
			logmsg_warn "New kernel modules archive was not downloaded successfully, so old ones are not purged"
			ACTION_REMOVEOLD_FWIMAGE=no_BadDownload
		fi

	learn_downloaded_images
	if [ "$ACTION_FORCEFLASH_FWIMAGE_UBOOT" = yes ] && \
	   [ "$RESULT_ACTION_DOWNLOAD_FWIMAGE_RAW_UBOOT" = 0 -o "$RESULT_ACTION_DOWNLOAD_FWIMAGE_RAW_UBOOT" = 42 ] \
	; then
		logmsg_info "Adding a touch of u-Boot forceflash, as requested"
		rm -f "${DEPLOYMENTROOTFW_UBOOT}/u-Boot.forceflash" "${DOWNLOADROOTFW_UBOOT}/u-Boot.forceflash"
		case "${DOWNLOADED_FW_UBOOT}" in
			/dev*) [ "$ACTION_REMOVEOLD_FWIMAGE" = yes ] && removeold_rawfwimage_uboot ;;
			*)
				[ -n "${DOWNLOADED_FW_UBOOT}" ] && [ -s "${DOWNLOADED_FW_UBOOT}" ] && touch "${DOWNLOADED_FW_UBOOT}.forceflash" ;;
		esac
	fi
	if [ "$ACTION_FORCEFLASH_FWIMAGE_UIMAGE" = yes ] && \
	   [ "$RESULT_ACTION_DOWNLOAD_FWIMAGE_RAW_UIMAGE" = 0 -o "$RESULT_ACTION_DOWNLOAD_FWIMAGE_RAW_UIMAGE" = 42 ] \
	; then
		logmsg_info "Adding a touch of uImage forceflash, as requested"
		rm -f "${DEPLOYMENTROOTFW_UIMAGE}/uImage.forceflash" "${DOWNLOADROOTFW_UIMAGE}/uImage.forceflash"
		case "${DOWNLOADED_FW_UIMAGE}" in
			/dev*) [ "$ACTION_REMOVEOLD_FWIMAGE" = yes ] && removeold_rawfwimage_uimage ;;
			*)
				[ -n "${DOWNLOADED_FW_UIMAGE}" ] && [ -s "${DOWNLOADED_FW_UIMAGE}" ] && touch "${DOWNLOADED_FW_UIMAGE}.forceflash" ;;
		esac
	fi
fi

if [ "$ACTION_REMOVEOLD_FWIMAGE" = yes ]; then
	removeold_rawfwimage_modules || ACTION_RESULT=$?
	removeold_rawfwimage_uimage || ACTION_RESULT=$?
	removeold_rawfwimage_uboot || ACTION_RESULT=$?
else
	logmsg_info "Not purging old FW images because ACTION_REMOVEOLD_FWIMAGE=$ACTION_REMOVEOLD_FWIMAGE"
fi

RESULT_ACTION_DOWNLOAD_OSIMAGE=0
if [ "$ACTION_DOWNLOAD_OSIMAGE" = yes ]; then
	rm -f "$DOWNLOADROOT_OSIMAGE/.newest-osimage"
	download_osimage $URL_DOWNLOAD_OSIMAGE
	RESULT_ACTION_DOWNLOAD_OSIMAGE=$?

	# If there was indeed a successful download, we have code=42 from the
	# routine; however the script succeeded - so overall exitcode stays 0
	if [ "$RESULT_ACTION_DOWNLOAD_OSIMAGE" -gt 0 -a "$RESULT_ACTION_DOWNLOAD_OSIMAGE" -ne 42 ] ; then
		ACTION_RESULT=$RESULT_ACTION_DOWNLOAD_OSIMAGE && \
		if [ "$ACTION_REMOVEOLD_OSIMAGE" = yes ] ; then
			logmsg_warn "New OS image was not downloaded successfully, so old ones are not purged"
			ACTION_REMOVEOLD_OSIMAGE=no_BadDownload
		fi
	else
		learn_downloaded_images
	fi

	if [ "$ACTION_FORCEFLASH_OSIMAGE" = yes ] && \
	   [ "$RESULT_ACTION_DOWNLOAD_OSIMAGE" = 0 -o "$RESULT_ACTION_DOWNLOAD_OSIMAGE" = 42 ] \
	; then
		logmsg_info "Adding a touch of OS image forceflash, as requested"
		rm -f "${DEPLOYMENTROOT_OSIMAGE}"/*.forceflash "${DOWNLOADROOT_OSIMAGE}"/*.forceflash
		[ -n "${DOWNLOADED_OS_IMAGE}" ] && [ -s "${DOWNLOADED_OS_IMAGE}" ] && touch "${DOWNLOADED_OS_IMAGE}.forceflash"
	fi
fi

case "$FLAG_ERASE_FACTORYRESET" in
	yes)
		if [ "$ACTION_DOWNLOAD_OSIMAGE" = no ] || \
		   [ "$ACTION_DOWNLOAD_OSIMAGE" = yes -a "$RESULT_ACTION_DOWNLOAD_OSIMAGE" -eq 42 ] || \
		   [ "$ACTION_DOWNLOAD_OSIMAGE" = yes -a "$RESULT_ACTION_DOWNLOAD_OSIMAGE" -eq 0 ] \
		; then
			if [ "$ACTION_DOWNLOAD_OSIMAGE" = no ] ; then
				logmsg_info "Per request, no OS image was downloaded; also requesting factory-reset during reboot"
			else
				logmsg_info "New OS image was downloaded successfully, so requesting factory-reset during reboot"
			fi
			touch "$DOWNLOADROOT/factory_reset"
		else
			logmsg_warn "New OS image was not downloaded successfully, so not requesting factory-reset"
		fi
		;;
	force)
		logmsg_info "Explicitly requesting factory-reset during next reboot, regardless of whether OS image changed or not"
		touch "$DOWNLOADROOT/factory_reset"
		;;
	no)
		rm -f "$DEPLOYMENTROOT/factory_reset" "$DOWNLOADROOT/factory_reset"
		;;
esac

case "$FLAG_ERASE_ALL" in
	yes)
		if [ "$ACTION_DOWNLOAD_OSIMAGE" = no ] || \
		   [ "$ACTION_DOWNLOAD_OSIMAGE" = yes -a "$RESULT_ACTION_DOWNLOAD_OSIMAGE" -eq 42 ] || \
		   [ "$ACTION_DOWNLOAD_OSIMAGE" = yes -a "$RESULT_ACTION_DOWNLOAD_OSIMAGE" -eq 0 ] \
		; then
			if [ "$ACTION_DOWNLOAD_OSIMAGE" = no ] ; then
				logmsg_info "Per request, no OS image was downloaded; also requesting erase-all during reboot"
			else
				logmsg_info "New OS image was downloaded successfully, so requesting erase-all during reboot"
			fi
			touch "$DOWNLOADROOT/erase_all"
		else
			logmsg_warn "New OS image was not downloaded successfully, so not requesting erase-all"
		fi
		;;
	force)
		logmsg_info "Explicitly requesting erase-all during next reboot, regardless of whether OS image changed or not"
		touch "$DOWNLOADROOT/erase_all"
		;;
	no)
		rm -f "$DEPLOYMENTROOT/erase_all" "$DOWNLOADROOT/erase_all"
		;;
esac

if [ "$ACTION_REMOVEOLD_OSIMAGE" = yes ]; then
	# Protect with RETAIN_FILES against overly eager etn-sw-update and other mishaps
	RETAIN_FILES="`[ -n "${DOWNLOADED_OS_IMAGE-}" ] && ls -1ad ${DOWNLOADED_OS_IMAGE}*`" \
	removeold_osimage || ACTION_RESULT=$?
	if [ -n "${DOWNLOADED_OS_IMAGE-}" ] ; then
		[ -s "${DOWNLOADED_OS_IMAGE}" ] || { ACTION_RESULT=$? ; logmsg_error "DOWNLOADED_OS_IMAGE='${DOWNLOADED_OS_IMAGE}' is missing after the purge of old images!" ; }
	fi
else
	logmsg_info "Not purging old OS images because ACTION_REMOVEOLD_OSIMAGE=$ACTION_REMOVEOLD_OSIMAGE"
fi

echo ""
echo "===================================================================="
echo ""

if [ -n "$DOWNLOADED_OS_IMAGE" ] && [ -s "$DOWNLOADED_OS_IMAGE" ]; then
	logmsg_info "NOTE: Downloaded an OS image during this run:" \
		"'$DOWNLOADED_OS_IMAGE'" \
		"`ls -lad "$DOWNLOADED_OS_IMAGE"`"
fi

if [ -f "$DEPLOYMENTROOT/factory_reset" ] || [ -f "$DOWNLOADROOT/factory_reset" ]; then
	logmsg_warn "NOTE: a FACTORY RESET was requested and will be done during reboot"
fi

if [ -f "$DEPLOYMENTROOT/erase_all" ] || [ -f "$DOWNLOADROOT/erase_all" ]; then
	logmsg_warn "NOTE: a FACTORY RESET + NAND FORMAT was requested and will be done during reboot"
fi

process_FACTORY_RESET_TTL_EXPIRED

logmsg_info "Syncing to ensure all writes are done..."
time sync || true

ACTION_RESULT_STR="seek errors above"
DO_REBOOT="no"
case "$ACTION_RESULT" in
	0|42)	ACTION_RESULT_STR="new files were available"
		[ "$ACTION_RESULT" = 0 ] && ACTION_RESULT_STR="no $ACTION_RESULT_STR"
		if [ "$RESULT_ACTION_DOWNLOAD_OSIMAGE" = 42 ] \
		|| [ "$RESULT_ACTION_DOWNLOAD_FWIMAGE_RAW_UBOOT" = 42 ] \
		|| [ "$RESULT_ACTION_DOWNLOAD_FWIMAGE_RAW_UIMAGE" = 42 ] \
		|| [ "$RESULT_ACTION_DOWNLOAD_FWIMAGE_RAW_MODULES" = 42 ] \
		; then
			ACTION_RESULT=42
			ACTION_RESULT_STR="new files were downloaded successfully, you can reboot now to apply the updates"
			[ "${WANT_REBOOT-}" = yes -o "${WANT_REBOOT-}" = force ] && DO_REBOOT=yes
			[ "${DO_REBOOT}" = yes ] && \
				logmsg_warn "Got new files without errors - and was asked to reboot in this case" || \
				logmsg_warn "Got new files without errors"
		fi
		if [ "$ACTION_RESULT" = 0 ] ; then
			[ "${WANT_REBOOT-}" = force ] && DO_REBOOT=yes
			[ "${DO_REBOOT}" = yes ] && \
				logmsg_warn "Got no errors - with new files or no updates - and was asked to reboot in this case" || \
				logmsg_warn "Got no errors - with new files or no updates"
		fi
		;;
esac

logmsg_info "Completed '$_SCRIPT_NAME $_SCRIPT_ARGS' with result $ACTION_RESULT ($ACTION_RESULT_STR)"

if [ "${DO_REBOOT-}" = yes ]; then
	logmsg_warn "Was asked to reboot... trying to do so..."
	sync
	init 6
fi

exit $ACTION_RESULT
