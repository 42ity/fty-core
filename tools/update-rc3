#!/bin/bash
#
# Copyright (C) 2015 Eaton
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
#! \file    systemctl
#  \brief   Helper script to manage download of new images initiated from RC3
#  \author  Jim Klimov <EvgenyKlimov@Eaton.com>
#  \author  Michal Hrusecky <MichalHrusecky@Eaton.com>
#  \author  Tomas Halman <TomasHalman@Eaton.com>
#

# Important bashism
set -o pipefail

# Default values matching Eaton internal (at the moment) resources
# The actual RC3 should be reconfigured to refer to some customer-local mirror
# or an external Eaton resource, done by snipets in /etc/update-rc3.d/*.conf
[ -z "${IMGTYPE-}" ] && IMGTYPE="deploy"
[ -z "${ARCH-}" ] && ARCH="`uname -m`"
# The RC3 base OS ensures support for squashfs and overlay(fs)
[ -z "${EXT-}" ] && EXT="squashfs"
[ -z "${CHECKSUM_ALGO_DEFAULT-}" ] && CHECKSUM_ALGO_DEFAULT="md5"

# This script is intended as the downloader tool for both CI/dev-workstation
# hosts and the ultimate devices. Most of the logic is the same, but there are
# a few differences. File and directory naming is one of them :
# Our CI farm deployments mimic the build farm paths - with IMGTYPE/ARCH/filename.ext
# The RC3 units expect a flat directory structure rootfs/filename.ext so the
# details (especially IMGTYPE) should end up in the flat filename - ...__${ARCH}__${IMGTYPE}.${EXT}.
[ -z "${FLATTEN_FILENAMES-}" ] && FLATTEN_FILENAMES="yes"

# TODO: TFTP support, busybox can do it
# TODO: Test with https - can require custom CA trust configuration, etc.
[ -z "${SOURCESITEROOT-}" ] && SOURCESITEROOT='http://obs.roz53.lab.etn.com/images'
[ -z "${SOURCESITEROOT_OSIMAGE-}" ] && SOURCESITEROOT_OSIMAGE="$SOURCESITEROOT/$IMGTYPE/$ARCH"

[ -z "${SOURCESITEROOTFW-}" ] && SOURCESITEROOTFW="http://obs.roz53.lab.etn.com/flash-rc3/recovery"
[ -z "${SOURCESITEROOTFW_UBOOT-}" ] && SOURCESITEROOTFW_UBOOT="$SOURCESITEROOTFW"
[ -z "${SOURCESITEROOTFW_UIMAGE-}" ] && SOURCESITEROOTFW_UIMAGE="$SOURCESITEROOTFW"
[ -z "${SOURCESITEROOTFW_MODULES-}" ] && SOURCESITEROOTFW_MODULES="$SOURCESITEROOTFW/modules"

# Recovery location (on MMC or mSATA) - for downloads
[ -z "${DOWNLOADROOT-}" ] && DOWNLOADROOT="/mnt/mmc/recovery"
[ -z "${DOWNLOADROOT_OSIMAGE-}" ] && DOWNLOADROOT_OSIMAGE="$DOWNLOADROOT/rootfs"
[ -z "${DOWNLOADROOTFW_UBOOT-}" ] && DOWNLOADROOT_UBOOT="$DOWNLOADROOT"
[ -z "${DOWNLOADROOTFW_UIMAGE-}" ] && DOWNLOADROOT_UIMAGE="$DOWNLOADROOT"
[ -z "${DOWNLOADROOTFW_MODULES-}" ] && DOWNLOADROOT_MODULES="$DOWNLOADROOT_UIMAGE/modules"

# Deployment location (on SPI flash in production) - for boot-mounted OS image
[ -z "${DEPLOYMENTROOT-}" ] && DEPLOYMENTROOT="/mnt/nand"
[ -z "${DEPLOYMENTROOT_OSIMAGE-}" ] && DEPLOYMENTROOT_OSIMAGE="$DEPLOYMENTROOT/rootfs"
[ -z "${DEPLOYMENTROOTFW_UBOOT-}" ] && DEPLOYMENTROOT_UBOOT="$DEPLOYMENTROOT"
[ -z "${DEPLOYMENTROOTFW_UIMAGE-}" ] && DEPLOYMENTROOT_UIMAGE="$DEPLOYMENTROOT"
[ -z "${DEPLOYMENTROOTFW_MODULES-}" ] && DEPLOYMENTROOT_MODULES="$DEPLOYMENTROOT_UIMAGE/modules"

[ -z "${http_proxy-}" -o x"${http_proxy-}" = x- ] && http_proxy=""
[ -z "${https_proxy-}" -o x"${https_proxy-}" = x- ] && https_proxy=""
[ -z "${ftp_proxy-}" -o x"${ftp_proxy-}" = x- ] && ftp_proxy=""
[ -z "${ftps_proxy-}" -o x"${ftps_proxy-}" = x- ] && ftps_proxy=""
export http_proxy https_proxy ftp_proxy ftps_proxy

# The RC3 SPI flash partitioning determines these sizes, value hardcoded in the
# default installation routines as well as the init/upgrade script in uImage.
# These numbers are used for "padded" checksum calculations.
UIMAGE_MAX_SIZE_RC3=3145728
UBOOT_MAX_SIZE_RC3=1048576
[ -z "${UIMAGE_MAX_SIZE-}" ] && UIMAGE_MAX_SIZE="$UIMAGE_MAX_SIZE_RC3"
[ -z "${UBOOT_MAX_SIZE-}" ] && UBOOT_MAX_SIZE="$UBOOT_MAX_SIZE_RC3"

PATH="/sbin:/usr/sbin:/usr/local/sbin:/bin:/usr/bin:/usr/local/bin:$PATH"
export PATH

### NOTE: This script can be copied to VM hosts and used standalone, so we do
### not depend it on scriptlib.sh or anything else. Implement a few bits here.

### This is prefixed before ERROR, WARN, INFO tags in the logged messages
LOGMSG_PREFIX="BIOS-UPDATE-RC3-"

### Store some important CLI values
[ -z "$_SCRIPT_PATH" ] && _SCRIPT_PATH="$0"
[ -z "$_SCRIPT_NAME" ] && _SCRIPT_NAME="`basename "${_SCRIPT_PATH}"`"
_SCRIPT_ARGS="$*"
_SCRIPT_ARGC="$#"

usage() {
    echo "Usage: ${_SCRIPT_NAME} [options...]"
    echo "Options:"
    echo "  --help | -help | -h       Display this hep and exit"
    echo "  --(no-)download-image-os  Enable or disable downloading of OS images"
    echo "  --(no-)download-image-fw  Likewise for downloading of uBoot, uImage+modules"
    echo "  --(no-)download-images    Enable or disable downloading of all image types"
    echo "  --(no-)check-image-os, --(no-)check-image-fw, --(no-)check-images"
    echo "                   Only check the source location if new images are available"
    echo "  --(no-)removeold-image-os, --(no-)removeold-image-fw, --(no-)removeold-images"
    echo "                   If download-image of this type was requested and successful,"
    echo "                   or if download was not requested at all, remove all but the"
    echo "                   newest (alphabetcally) image file from the recovery location"
    echo "  --no-remove-files         Skip removing image files deemed corrupt or obsolete"
# TODO ...
}

SCRIPTDIR=$(realpath "`dirname ${_SCRIPT_PATH}`") || \
    SCRIPTDIR=$(cd "`dirname ${_SCRIPT_PATH}`" && pwd)
SCRIPTPWD="`pwd`"
if [ -z "$CHECKOUTDIR" ] ; then
    CHECKOUTDIR=$(realpath "$SCRIPTDIR/../..") || \
        CHECKOUTDIR=$(cd "$SCRIPTDIR/../.." && pwd)
fi
[ "$CHECKOUTDIR" = / -o ! -d "$CHECKOUTDIR/tests/CI" ] && CHECKOUTDIR=""
[ -z "$BUILDSUBDIR" ] && BUILDSUBDIR="$CHECKOUTDIR"
export CHECKOUTDIR BUILDSUBDIR

[ -z "$LANG" ] && LANG=C
[ -z "$LANGUAGE" ] && LANGUAGE=C
[ -z "$LC_ALL" ] && LC_ALL=C
[ -z "$TZ" ] && TZ=UTC
export LANG LANGUAGE LC_ALL TZ

logmsg_info() {
    echo "${LOGMSG_PREFIX}INFO: ${_SCRIPT_PATH}:" "$@"
}

logmsg_warn() {
    echo "${LOGMSG_PREFIX}WARN: ${_SCRIPT_PATH}:" "$@" >&2
}

logmsg_error() {
    echo "${LOGMSG_PREFIX}ERROR: ${_SCRIPT_PATH}:" "$@" >&2
}

die() {
    CODE="${CODE-1}"
    [ "$CODE" -ge 0 ] 2>/dev/null || CODE=1
    for LINE in "$@" ; do
        echo "${LOGMSG_PREFIX}FATAL: ${_SCRIPT_PATH}:" "$LINE" >&2
    done
    exit $CODE
}

settraps() {
    # Not all trap names are recognized by all shells consistently
    # Note: slight difference from scriptlib.sh, we trap ERR too by default
    [ -z "${TRAP_SIGNALS-}" ] && TRAP_SIGNALS="ERR  EXIT QUIT TERM HUP INT"
    for P in "" SIG; do for S in $TRAP_SIGNALS ; do
        case "$1" in
        -|"") trap "$1" $P$S 2>/dev/null || true ;;
        *)    trap 'ERRCODE=$?; ('"$*"'); exit $ERRCODE;' $P$S 2>/dev/null || true ;;
        esac
    done; done
}

##############################################################################
remove_image() {
    # Remove the image file "$1" and its possible checksum patterns,
    # and the optional explicit checksum filename that can be in "$2"
    [ x"${FLAG_CAN_REMOVE_IMAGES-}" = xno ] && \
        logmsg_info "FLAG_CAN_REMOVE_IMAGES=$FLAG_CAN_REMOVE_IMAGES so do not remove_image($*)" && \
        return 0
    rm -f "$1"{,.md5,.sha,.sha1,.sha224,.sha256,.sha384,.sha512}{,-padded}{,.tmp} ${2:+"$2"}
}

get_csalgo_from_filename() {
    # Parse (extensions of) the filename in "$1" to retrieve the
    # checksum algo (if any); set of supported algos and extensions
    # is to be kept in sync with remove_image() above.
    _A="`echo "$1" | tr '[A-Z]' '[a-z]' | sed -e 's,\.tmp$,,' -e 's,^.*\.\([^\.]*\)$,\1,' -e 's,-padded$,,'`" || _A=""

    case "${_A}" in
        md5|sha|sha1|sha224|sha256|sha384|sha512)
            echo "${_A}"
            unset _A
            return 0 ;;
        "") logmsg_error "Could not extract checksum algorithm from filename '$1'"
            unset _A
            return 31 ;;
        *)  logmsg_error "Unrecognized checksum algorithm: '${_A}'"
            unset _A
            return 32 ;;
    esac
}

calculate_stream_checksum() {
    # Calculate and print to stdout checksum of the stdin stream using algo "$1"
    # Use the function above to validate known algorithm names
    # We expect to have either ${ALGO}sum program or openssl support for ${ALGO}
    if [ -z "${1-}" ]; then
        ALGO="${CHECKSUM_ALGO_DEFAULT}"
    else
        ALGO="`get_csalgo_from_filename "$1"`" || return $?
    fi

    if [ -x "`which openssl`" ] 2>/dev/null ; then
        openssl dgst -"${ALGO}" | awk '{print $NF}'
        return $?
    fi

    ${ALGO}sum | awk '{print $1}'
    return $?
}

expected_checksum() (
    # Extracts precalculated checksum of file "$1" recorded in file "$2"
    CHECKSUM_EXP="$(grep -i "`basename "$1"`" < "$2" | awk '{print $1}')" 2>/dev/null
    if [ $? != 0 -o -z "$CHECKSUM_EXP" ] && [ "`wc -l < "$2"`" -eq 1 ] ; then
        # Maybe the whole file content is one line with the value
        CHECKSUM_EXP="`awk '{print $1}' < "$2"`"
    fi
    [ -n "$CHECKSUM_EXP" ] && echo "$CHECKSUM_EXP"
    # If the value is empty, this statement returns an error exit-code
)

verify_checksum() {
    # Compares actual checksum of file "$1" with value recorded in file "$2"
    # with optional algorithm in "$3" (defaults to CHECKSUM_ALGO_DEFAULT='md5')
    # TODO: add generalized support for .${CHECKSUM_ALGO_DEFAULT}-padded checksum files (firmware imgs)
    FILENAME_DATA="$1"
    FILENAME_CSUM="${2-}"
    [ -z "$FILENAME_CSUM" ] && \
        FILENAME_CSUM="$FILENAME_DATA.${CHECKSUM_ALGO_DEFAULT}"
    if [ -z "${3-}" ]; then
        CHECKSUM_ALGO="`get_csalgo_from_filename "$FILENAME_CSUM"`"
        [ $? = 0 -a -n "$CHECKSUM_ALGO" ] || \
            CHECKSUM_ALGO="${CHECKSUM_ALGO_DEFAULT}"
    else
        CHECKSUM_ALGO="$3"
    fi
    LOGINTRO="Checksum validation of '$FILENAME_DATA' against value in '$FILENAME_CSUM' ($CHECKSUM_ALGO)"

    if [ -n "$FILENAME_DATA" ] && [ -n "$FILENAME_CSUM" ] && \
       [ -s "$FILENAME_DATA" -a -s "$FILENAME_CSUM" ] \
    ; then
        logmsg_info "Beginning $LOGINTRO..."

        CHECKSUM_EXP="`expected_checksum "$FILENAME_DATA" "$FILENAME_CSUM"`"
        if [ $? != 0 -o -z "$CHECKSUM_EXP" ]; then
            logmsg_warn "$LOGINTRO SKIPPED (can not detect expected value)"
            return 0
        fi

        CHECKSUM_ACT="`calculate_stream_checksum < "$FILENAME_DATA"`" || CHECKSUM_ACT=""
        if [ -z "$CHECKSUM_ACT" ]; then
            logmsg_warn "$LOGINTRO SKIPPED (can not calculate actual value)"
            return 0
        fi

        if [ x"$CHECKSUM_ACT" = x"$CHECKSUM_EXP" ]; then
            logmsg_info "$LOGINTRO SUCCEEDED!"
            return 0
        fi

        logmsg_error "$LOGINTRO FAILED (mismatch)!"
        echo "ACTUAL: $CHECKSUM_ACT" >&2
        echo "EXPECT: $CHECKSUM_EXP" >&2
        return 1
    fi
    logmsg_warn "$LOGINTRO SKIPPED (one of the files is missing)"
    return 0
}

ensure_checksum() {
    # A destructive wrapper of verify_checksum(), destroys bad downloads
    if ! verify_checksum "$@" ; then
        logmsg_warn "Removing broken file: '$1' and its checksum(s)"
        remove_image "$@"
        return 1
    fi
    return 0
}

verify_threeway_checksum() (
    # We can have (or not) a local copy of the data file "$2", a local copy
    # of the checksum file "$3", and a freshly fetched copy of remote checksum
    # file "$4" (usually an *.algo.tmp); all previously downloaded by caller
    # from URL in "$1".
    # Return codes:
    #   0       OK, local data and checksum files are (now) consistent, keep'em
    #   1       ERROR, local files inconsistent (removed), re-pull from remote!
    #   2       ERROR, some prerequisites missing, etc.
    # Verify if any of these files match together (in a destructive manner):
    # * If some of the files are not available:
    # ** data file - fail (must download all bits)
    # ** both checksums - fail (legacy mode allowed no checksums, now not so)
    # ** local checksum - fall through (only compare to remote checksum then)
    # ** remote checksum - fall through (only compare to local checksum then)
    # * If two checksums are the same (both in algo and value), remove the
    #   newly downloaded one and fall through for verifications
    # * If the remote checksum file exists (thus different from local) and
    #   a checksum value is detected from it:
    # ** If the remote checksum value does match the file - assume it to be
    #    authoritative and local one possibly broken (overwrite checksum file)
    # ** If the remote checksum does not match, assume the source file updated
    #    in-place on the remote source - kill local data and return error
    #    (caller would pull remote files)
    # * If the local CS+DATA do NOT match together, kill them and return error
    # * If neither checksum matches - kill local data and return error

    # The IMAGE_URL_BASENAME_EXT (on remote site with hierarchical structure)
    # may be different from local FILE_DATA name (with flattened structure).
    IMAGE_URL="$1"
    # Basenames of data and checksum files (under current dir set by caller).
    # Theoretically checksums may be from different algorithms (see extension).
    FILE_DATA="$2"
    FILE_CSOLD="$3"
    FILE_CSNEW="$4"

    [ -n "$IMAGE_URL" ] && \
    IMAGE_URL_BASENAME="`basename "$IMAGE_URL" ".${EXT}"`" && \
    [ -n "$IMAGE_URL_BASENAME" ] && \
    IMAGE_URL_BASENAME_EXT="${IMAGE_URL_BASENAME}.${EXT}" || \
        { logmsg_warn "Could not resolve IMAGE_URL value '$IMAGE_URL' into a filename"
          IMAGE_URL=""; IMAGE_URL_BASENAME=""; IMAGE_URL_BASENAME_EXT=""; }

    if [ ! -s "$FILE_DATA" ] ; then
        logmsg_info "Local data file '`pwd`/$FILE_DATA' is missing"
        return 2
    fi

    if [ ! -s "$FILE_CSOLD" ] && [ ! -s "$FILE_CSNEW" ] ; then
        logmsg_info "Both checksum files '`pwd`/$FILE_CSOLD' and '`pwd`/$FILE_CSNEW' are missing"
        return 2
    fi

    # If checksum files are available, try to get checksum values using the
    # current (local) or maybe original (remote from IMAGE_URL) filename.
    [ -s "$FILE_CSOLD" ] && \
        CSOLDALGO="`get_csalgo_from_filename "$FILE_CSOLD"`" && \
        { CSOLD="`expected_checksum "$FILE_DATA" "$FILE_CSOLD"`" || \
          CSOLD="`[ -z "$IMAGE_URL_BASENAME_EXT" ] && [ x"$FILE_DATA" != x"$IMAGE_URL_BASENAME_EXT" ] && expected_checksum "$IMAGE_URL_BASENAME_EXT" "$FILE_CSOLD"`" ; } || \
        { CSOLD=""; CSOLDALGO=""; logmsg_info "Local checksum file '`pwd`/$FILE_CSOLD' is missing"; }

    [ -s "$FILE_CSNEW" ] && \
        CSNEWALGO="`get_csalgo_from_filename "$FILE_CSNEW"`" && \
        { CSNEW="`expected_checksum "$FILE_DATA" "$FILE_CSNEW"`" || \
          CSNEW="`[ -z "$IMAGE_URL_BASENAME_EXT" ] && [ x"$FILE_DATA" != x"$IMAGE_URL_BASENAME_EXT" ] && expected_checksum "$IMAGE_URL_BASENAME_EXT" "$FILE_CSNEW"`" ; } || \
        { CSNEW=""; CSNEWALGO=""; logmsg_info "Remote checksum file '`pwd`/$FILE_CSNEW' is missing"; }

    if [ -z "$CSNEW" ] && [ -z "$CSOLD" ]; then
        logmsg_info "Could not get usable checksum values from both checksum files: '`pwd`/$FILE_CSOLD' and '`pwd`/$FILE_CSNEW'"
        return 2
    fi

    # Now that we have a validated request, do the actual suite of comparisons.
    if [ -n "$CSNEWALGO" ] && [ -n "$CSNEW" ] && \
       [ -n "$CSOLDALGO" ] && [ -n "$CSOLD" ] \
    ; then
        if [ x"$CSNEWALGO" = x"$CSOLDALGO" ]; then
            if [ x"$CSNEW" = x"$CSOLD" ]; then
                # Keep old checksum file and fall through
                rm -f "$FILE_CSNEW"
                CSNEW=""
                CSNEWALGO=""
            else
                logmsg_warn "Old and new checksum values differ with same algo ($CSOLDALGO): '$CSOLD' vs '$CSNEW'"
            fi
        else
            logmsg_warn "Old and new checksum files have different algorithms: '$CSOLDALGO' vs '$CSNEWALGO' (so values are not comparable directly)"
        fi
    fi

    [ -n "$CSNEW" ] && \
    if verify_checksum "$FILE_DATA" "$FILE_CSNEW" ; then
        logmsg_info "Remote checksum is good for '`pwd`/$FILE_CSNEW', local copy was corrupted - replacing checksum file"
        mv -f "$FILE_CSNEW" "$FILE_CSOLD" && \
        logmsg_info "The newest available image is '$IMAGE_URL' and we already have a good copy (as '$FILE_DATA')"
        return $?
    else
        logmsg_info "Remote checksum is not good for '`pwd`/$FILE_CSNEW', local file is corrupted or obsolete and should be re-downloaded from '$IMAGE_URL'"
        [ -s "$FILE_CSNEW" ] && mv -f "$FILE_CSNEW" ".$$.$FILE_CSNEW"
        remove_image "$FILE_DATA"
        [ -s ".$$.$FILE_CSNEW" ] && mv -f ".$$.$FILE_CSNEW" "$FILE_CSNEW"
        return 1
    fi

    [ -n "$CSOLD" ] && \
    if verify_checksum "$FILE_DATA" "$FILE_CSOLD" ; then
        logmsg_info "Local checksum matched for '`pwd`/$FILE_CSOLD'"
        return 0
    else
        # Ensuring against old checksum failed, so data file and its related
        # files (checksums) should have been removed; keep the FILE_CSNEW
        logmsg_info "Local checksum mismatched for '`pwd`/$FILE_CSOLD', local file is corrupted or obsolete and should be re-downloaded from '$IMAGE_URL'"
        [ -s "$FILE_CSNEW" ] && mv -f "$FILE_CSNEW" ".$$.$FILE_CSNEW"
        remove_image "$FILE_DATA"
        [ -s ".$$.$FILE_CSNEW" ] && mv -f ".$$.$FILE_CSNEW" "$FILE_CSNEW"
        return 1
    fi

    logmsg_info "Neither path of three-way verification has succeeded for $FILE_DATA', it should be re-downloaded from '$IMAGE_URL'"
    return 1
)

findnewest_osimage() (
    # Echo the URL to the newest OS image file found on remote resource, if any
    # Note: currently expects certain filename patterns and http-dir listing markup
    IMAGE_URL="`wget -q -O - ${SOURCESITEROOT_OSIMAGE}/ | sed -n 's|.*href="\(.*simpleimage.*\.'"${EXT}"'\)".*|'"${SOURCESITEROOT_OSIMAGE}"'/\1|p' | sed 's,\([^:]\)//,\1/,g'`" && \
    if [ x"$IMAGE_URL" != x ]; then
# | sort -n | tail -1
        [ x"`basename "$IMAGE_URL" .${EXT}`" != x ] && \
        echo "$IMAGE_URL" && return 0
    fi
    return 1
)

download_osimage() (
    cd "${DOWNLOADROOT_OSIMAGE}" || die "Can not use DOWNLOADROOT_OSIMAGE='$DOWNLOADROOT_OSIMAGE'"
    # TODO: Free space verification before download - BIOS-1562?
    # TODO: Currently hardcoded for md5 accompanying checksums only
    # TODO: Consider DEPLOYMENTROOT* variables to verify presence of local files against
    # TODO: Consider FLATTEN_FILENAMES=yes in TGT_FILE logic
    # TODO: Refactor the triple-file verification (local/remote checksum and the
    # data file) into a separate routine
    # TODO (later): Support file sizes as part of checksum info
    # TODO (later): Support presence of multipple checksum files (e.g. sha* and md5)

    logmsg_info "Fetching newest filename for ${ARCH} OS image of type ${IMGTYPE}..."
    IMAGE_URL="`findnewest_osimage`" && \
    IMAGE_URL_BASENAME="`basename "$IMAGE_URL" ".${EXT}"`" || \
        die "Can not find the remote image URL"
    IMAGE_CSALGO="${CHECKSUM_ALGO_DEFAULT}"

    logmsg_info "Downloading '$IMAGE_URL.${IMAGE_CSALGO}' (if any)..."
    rm -f "$IMAGE_URL_BASENAME.$EXT.${IMAGE_CSALGO}.tmp"
    wget -q -O - "$IMAGE_URL.${IMAGE_CSALGO}" > "$IMAGE_URL_BASENAME.$EXT.${IMAGE_CSALGO}.tmp" || \
        rm -f "$IMAGE_URL_BASENAME.$EXT.${IMAGE_CSALGO}.tmp"

    if  [ -s "$IMAGE_URL_BASENAME.$EXT" ] && \
        [ -s "$IMAGE_URL_BASENAME.$EXT.${IMAGE_CSALGO}" ] \
    ; then
        CSOLD="`expected_checksum "$IMAGE_URL_BASENAME.$EXT" "$IMAGE_URL_BASENAME.$EXT.${IMAGE_CSALGO}"`"
        CSNEW="`expected_checksum "$IMAGE_URL_BASENAME.$EXT" "$IMAGE_URL_BASENAME.$EXT.${IMAGE_CSALGO}.tmp"`"
        if [ x"$CSOLD" = x"$CSNEW" ]; then
            rm -f "$IMAGE_URL_BASENAME.$EXT.${IMAGE_CSALGO}.tmp"
        else
            # Here, two checksum files differ...
            if verify_checksum "$IMAGE_URL_BASENAME.$EXT" "$IMAGE_URL_BASENAME.$EXT.${IMAGE_CSALGO}.tmp" "${IMAGE_CSALGO}"; then
                # Remote checksum is good, local copy was corrupted
                mv -f "$IMAGE_URL_BASENAME.$EXT.${IMAGE_CSALGO}.tmp" "$IMAGE_URL_BASENAME.$EXT.${IMAGE_CSALGO}"
                logmsg_info "The newest available image is '$IMAGE_URL' and we already have a good copy (as '$IMAGE_URL_BASENAME.$EXT')"
                exit 0
            fi
        fi

        # Here, the new and old checksums are the same, or the different
        # new checksum for new filename did not match existing file.
        # Does the old couple match up?
        ensure_checksum "$IMAGE_URL_BASENAME.$EXT" "$IMAGE_URL_BASENAME.$EXT.${IMAGE_CSALGO}" && \
        logmsg_info "The newest available image is '$IMAGE_URL' and we already have a good copy (as '$IMAGE_URL_BASENAME.$EXT')" && \
        rm -f "$IMAGE_URL_BASENAME.$EXT.${IMAGE_CSALGO}.tmp" && \
        exit 0  # Local checksum is good & remote copy was corrupted, or the
                # remote files were replaced in-place which is not expected!

        # Here, the old file did not match either checksum and was killed...
        # The newly downloaded md5.tmp should remain available...
    elif [ -s "$IMAGE_URL_BASENAME.$EXT" ] && \
         [ -s "$IMAGE_URL_BASENAME.$EXT.${IMAGE_CSALGO}.tmp" ] \
    ; then
        # Got new checksum file for this name, and old is not available at all
        # If the checks fail, this is most likely an aborted and corrupt download
        mv -f "$IMAGE_URL_BASENAME.$EXT.${IMAGE_CSALGO}.tmp" "$IMAGE_URL_BASENAME.$EXT.${IMAGE_CSALGO}" && \
        ensure_checksum "$IMAGE_URL_BASENAME.$EXT" "$IMAGE_URL_BASENAME.$EXT.${IMAGE_CSALGO}" && \
        logmsg_info "The newest available image is '$IMAGE_URL' and we already have a good copy (as '$IMAGE_URL_BASENAME.$EXT')" && \
        rm -f "$IMAGE_URL_BASENAME.$EXT.${IMAGE_CSALGO}.tmp" && \
        exit 0
    fi

    # We rename the incoming image to include the type in flat directory space
    case "${IMAGE_URL_BASENAME}" in
        *__${ARCH}__${IMGTYPE}) TGT_FILE="${IMAGE_URL_BASENAME}.${EXT}" ;;
        *)  TGT_FILE="${IMAGE_URL_BASENAME}__${ARCH}__${IMGTYPE}.${EXT}" || \
                die "Can not produce the TGT_FILE value to save into"

            [ ! -s "$IMAGE_URL_BASENAME.$EXT.${IMAGE_CSALGO}.tmp" ] && \
                logmsg_info "Downloading '$IMAGE_URL.${IMAGE_CSALGO}' (if any)..."
                wget -q -O - "$IMAGE_URL.${IMAGE_CSALGO}" > "$IMAGE_URL_BASENAME.$EXT.${IMAGE_CSALGO}.tmp"

            sed 's,  .*$,  '"`basename "$TGT_FILE"`", < "$IMAGE_URL_BASENAME.$EXT.${IMAGE_CSALGO}.tmp" > "$TGT_FILE.${IMAGE_CSALGO}.tmp"
            rm -f "$IMAGE_URL_BASENAME.$EXT.${IMAGE_CSALGO}.tmp"

            if  [ -s "$TGT_FILE" ] && \
                [ -s "$TGT_FILE.${IMAGE_CSALGO}" ] \
            ; then
                CSOLD="`expected_checksum "$TGT_FILE" "$TGT_FILE.${IMAGE_CSALGO}"`"
                CSNEW="`expected_checksum "$TGT_FILE" "$TGT_FILE.${IMAGE_CSALGO}.tmp"`"
                if [ x"$CSOLD" = x"$CSNEW" ]; then
                    rm -f "$TGT_FILE.${IMAGE_CSALGO}.tmp"
                else
                    # Here, two checksum files (expected values) do differ...
                    if verify_checksum "$TGT_FILE" "$TGT_FILE.${IMAGE_CSALGO}.tmp" "${IMAGE_CSALGO}"; then
                        # Remote checksum is good, local copy was corrupted
                        mv -f "$TGT_FILE.${IMAGE_CSALGO}.tmp" "$TGT_FILE.${IMAGE_CSALGO}"
                        logmsg_info "The newest available image is '$IMAGE_URL' and we already have a good copy (as '$TGT_FILE')"
                        exit 0
                    fi
                fi

                # Here, the new and old checksums are the same, or the different
                # new checksum for new filename did not match existing file.
                # Does the old couple match up?
                ensure_checksum "$TGT_FILE" "$TGT_FILE.${IMAGE_CSALGO}" && \
                logmsg_info "The newest available image is '$IMAGE_URL' and we already have a good copy (as '$TGT_FILE')" && \
                rm -f "$TGT_FILE.${IMAGE_CSALGO}.tmp" && \
                exit 0  # Local checksum is good & remote copy was corrupted, or the
                        # remote files were replaced in-place which is not expected!

                # Here, the old file did not match either checksum and was killed...
            fi
            ;;  # Had to define TGT_FILE different from IMAGE_URL_BASENAME
    esac

    # If we are here, the IMAGE_URL is valid and points to a different content
    # than what we already have; the TGT_FILE names the ultimate local filename
    [ -s "$TGT_FILE.${IMAGE_CSALGO}.tmp" -a ! -s "$TGT_FILE.${IMAGE_CSALGO}" ] && \
        mv -f "$TGT_FILE.${IMAGE_CSALGO}.tmp" "$TGT_FILE.${IMAGE_CSALGO}"

    logmsg_info "Downloading '$IMAGE_URL' into '$TGT_FILE'..."
    rm -f "$TGT_FILE"
    wget -O "$TGT_FILE" -c "$IMAGE_URL" && [ -s "$TGT_FILE" ] || \
        { rm -f "$TGT_FILE"; die "Could not download '$IMAGE_URL' into '$TGT_FILE'"; }

    if [ -s "$TGT_FILE.${IMAGE_CSALGO}" ]; then
        ensure_checksum "$TGT_FILE" "$TGT_FILE.${IMAGE_CSALGO}" || exit $?
    else
        logmsg_warn "Generating '$TGT_FILE.${IMAGE_CSALGO}' because there was none at the source..."
        echo "`calculate_stream_checksum "${IMAGE_CSALGO}" < "$TGT_FILE"`  `basename "$TGT_FILE"`" > "$TGT_FILE.${IMAGE_CSALGO}" || \
        { rm -f "$TGT_FILE.${IMAGE_CSALGO}"; die "Could not generate '$TGT_FILE.${IMAGE_CSALGO}'"; }
    fi

    touch -r "$TGT_FILE" "$TGT_FILE.${IMAGE_CSALGO}" && \
    logmsg_info "Got OS image OK:" && \
    ls -ld "$TGT_FILE" "$TGT_FILE.${IMAGE_CSALGO}" && \
    cat "$TGT_FILE.${IMAGE_CSALGO}"
)

removeold_osimage() (
    cd "${DOWNLOADROOT_OSIMAGE}" || die "Can not use DOWNLOADROOT_OSIMAGE='$DOWNLOADROOT_OSIMAGE'"
    # Sort of implementation for BIOS-1566 snatched from bios-boot::Makefile
    # This removes all but the newest (alphabetically) files for the pattern
    # TODO: add support for hierarchical namespace (container hosts) with
    #       flattened or original filenames inside
    for F in `ls -1d *__${ARCH}__${IMGTYPE}.${EXT} 2>/dev/null | head -n -1` ; do
        logmsg_info "Removing older OS image: '$F' and its checksum"
        remove_image "$F"
    done || true
)

if [ -d "/etc/update-rc3.d/" ]; then
    for F in "/etc/update-rc3.d/"*.conf ; do
        if [ -s "$F" ] && [ -r "$F" ] ; then
            logmsg_info "Sourcing configuration file: '$F' ..."
            . "$F" || die
        fi
    done
fi

# TODO: Locking against multiple runs
# TODO: define CLI methods for status/size/... checks per BIOS-1563
# TODO: Expose more methods via CLI, e.g. to verify checksums of an image file

ACTION_DOWNLOAD_OSIMAGE="yes"
ACTION_DOWNLOAD_FWIMAGE="yes"

ACTION_CHECK_OSIMAGE="no"
ACTION_CHECK_FWIMAGE="no"

ACTION_REMOVEOLD_OSIMAGE="yes"
# This is currently no-op because we only track one FW image, unpacked on SRC
ACTION_REMOVEOLD_FWIMAGE="no"

# (dev) If set to "no", then do not remove files even if deemed broken or old
FLAG_CAN_REMOVE_IMAGES="yes"

ACTION_RESULT=0

while [ $# -gt 0 ]; do
        case "${1-}" in
                -h|--help|-help)        usage; exit 0 ;;
                --debug-calls)
                    if [ $# -eq 1 ]; then
                        die "The '$1' option requires further arguments"
                    fi
                    shift
                    set -xv
                    "$@" ; exit $? ;;
                --no-remove-files)      FLAG_CAN_REMOVE_IMAGES="no";;
                --download-image-os)    ACTION_DOWNLOAD_OSIMAGE="yes";;
                --download-image-fw)    ACTION_DOWNLOAD_FWIMAGE="yes";;
                --download-images)      ACTION_DOWNLOAD_OSIMAGE="yes"; ACTION_DOWNLOAD_FWIMAGE="yes";;
                --no-download-image-os) ACTION_DOWNLOAD_OSIMAGE="no";;
                --no-download-image-fw) ACTION_DOWNLOAD_FWIMAGE="no";;
                --no-download-images)   ACTION_DOWNLOAD_OSIMAGE="no"; ACTION_DOWNLOAD_FWIMAGE="no";;
                --check-image-os)       ACTION_CHECK_OSIMAGE="yes";;
                --check-image-fw)       ACTION_CHECK_FWIMAGE="yes";;
                --check-images)         ACTION_CHECK_OSIMAGE="yes"; ACTION_CHECK_FWIMAGE="yes";;
                --no-check-image-os)    ACTION_CHECK_OSIMAGE="no";;
                --no-check-image-fw)    ACTION_CHECK_FWIMAGE="no";;
                --no-check-images)      ACTION_CHECK_OSIMAGE="no"; ACTION_CHECK_FWIMAGE="no";;
                --removeold-image-os)   ACTION_REMOVEOLD_OSIMAGE="yes";;
                --removeold-image-fw)   ACTION_REMOVEOLD_FWIMAGE="yes";;
                --removeold-images)     ACTION_REMOVEOLD_OSIMAGE="yes"; ACTION_REMOVEOLD_FWIMAGE="yes";;
                --no-removeold-image-os)ACTION_REMOVEOLD_OSIMAGE="no";;
                --no-removeold-image-fw)ACTION_REMOVEOLD_FWIMAGE="no";;
                --no-removeold-images)  ACTION_REMOVEOLD_OSIMAGE="no"; ACTION_REMOVEOLD_FWIMAGE="no";;
        esac
        shift
done

if [ "$ACTION_DOWNLOAD_OSIMAGE" = yes ]; then
        download_osimage || ACTION_RESULT=$?
fi

if [ "$ACTION_REMOVEOLD_OSIMAGE" = yes ]; then
        if [ "$ACTION_DOWNLOAD_OSIMAGE" = no ] || [ "$ACTION_RESULT" -eq 0 ]; then
                removeold_osimage || ACTION_RESULT=$?
        fi
fi

exit $ACTION_RESULT
