#!/bin/bash
#
# Copyright (C) 2015-2016 Eaton
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
#! \file    update-rc3
#  \brief   Helper script to manage download of new images initiated from RC3
#  \author  Jim Klimov <EvgenyKlimov@Eaton.com>
#  \author  Michal Hrusecky <MichalHrusecky@Eaton.com>
#  \author  Tomas Halman <TomasHalman@Eaton.com>
#

# Important bashism
set -o pipefail

config_defaults() {
    # This routine sets variables required for the script to work
    # They can be set earlier by configuration files or caller's env

    # Default values matching Eaton internal (at the moment) resources
    # The actual RC3 should be reconfigured to refer some customer-local mirror
    # or an external Eaton resource, done by snippets in /etc/update-rc3.d/*.conf
    [ -z "${IMGTYPE-}" ] && IMGTYPE="deploy"

    # Prefix and suffix around $IMGTYPE in the URL directory component
    # and the image filename (at the moment, at least, applies to both)
    [ -z "$IMGTYPE_PREFIX" ] && IMGTYPE_PREFIX=""
    [ -z "$IMGTYPE_SUFFIX" ] && IMGTYPE_SUFFIX="-image"

    # We have several rounds of QA in the CI system; if the IMGQALEVEL is
    # defined then this sub-path including a slash is added into the URL.
    # Currently defined values include "master", "pre-rc" and finally "rc".
    # We only spend our ARM cycles to build the latter two; we have all
    # builds available on x86_64.
    [ -z "${ARCH-}" ] && ARCH="`uname -m`"
    [ -z "${IMGQALEVEL-}" ] && case "$ARCH" in
        *arm*) IMGQALEVEL="rc" ;;
        *86*)  IMGQALEVEL="master" ;;
        *)     IMGQALEVEL="master" ;;
    esac
    # The RC3 base OS ensures support for squashfs and overlay(fs)
    [ -z "${EXT-}" ] && EXT="squashfs"
    [ -z "${CHECKSUM_ALGO_DEFAULT-}" ] && CHECKSUM_ALGO_DEFAULT="md5"

    # This script is intended as the downloader tool for both CI/dev-workstation
    # hosts and the ultimate devices. Most of the logic is the same, but there are
    # a few differences. File and directory naming is one of them :
    # Our CI farm deployments mimic the build farm paths - with IMGTYPE/ARCH/filename.ext
    # The RC3 units expect a flat directory structure rootfs/filename.ext so
    # the details (especially IMGTYPE) should end up in the flat filename - as
    # ...__${ARCH}__${IMGTYPE}.${EXT} or ${IMGTYPE}..._${ARCH}.${EXT}
    # (rc3/virthost) If set to "no", use original filenames from the source server
    # FLAG_FLATTEN_FILENAMES is overridable by CLI option "--(no-)flatten-filenames"
    # The base filename pattern for an OS image as a shell glob, without the extension
    # on the download server.
    # [ -z "${SOURCESITEROOT_OSIMAGE_FILENAMEPATTERN-}" ] && SOURCESITEROOT_OSIMAGE_FILENAMEPATTERN="*"
    # [ -z "${SOURCESITEROOT_OSIMAGE_FILENAMEPATTERN-}" ] && SOURCESITEROOT_OSIMAGE_FILENAMEPATTERN="simpleimage*"
    # [ -z "${FLAG_FLATTEN_FILENAMES-}" ] && FLAG_FLATTEN_FILENAMES="yes"

    # Apparently, the new smarter build-names do not require flattery.
    # See findnewest_osimage() for subsequent filter over indexed filenames.
    [ -z "${SOURCESITEROOT_OSIMAGE_FILENAMEPATTERN-}" ] && SOURCESITEROOT_OSIMAGE_FILENAMEPATTERN="${IMGTYPE_PREFIX}${IMGTYPE}${IMGTYPE_SUFFIX}"'-*_'"${ARCH}"
    [ -z "${FLAG_FLATTEN_FILENAMES-}" ] && FLAG_FLATTEN_FILENAMES="no"

    ### Values below can be changed by command-line choices, and some defaults
    ### may be overridden by config files before CLI choices
    # (dev) If set to "no", then do not remove files even if deemed broken or old
    # Overridable by CLI option "--(no-)remove-files" which is somewhat different
    # from "--(no-)removeold-images" that only impacts old-image removal after a
    # successful download of new image(s)
    [ -z "${FLAG_CAN_REMOVE_IMAGES-}" ] && FLAG_CAN_REMOVE_IMAGES="yes"

    # Should we do a factory reset (erase all userdata)?
    [ -z "${FLAG_ERASE_FACTORYRESET-}" ] && FLAG_ERASE_FACTORYRESET="unset"

    # Should we do an erase_all (erase all userdata AND (re-)format /mnt/nand)?
    [ -z "${FLAG_ERASE_ALL-}" ] && FLAG_ERASE_ALL="unset"

    # TODO: TFTP support, busybox can do it
    # TODO: Test with https - can require custom CA trust configuration, etc.
    # TODO: Use our common requester as a wrapper for real/busybox wget/curl
    # TODO: Make a common routine to list remote directories (e.g. http-dir parsing, ftp, tftp, localfs...)
    [ -z "${SOURCESITEROOT-}" ] && SOURCESITEROOT='http://obs.roz.lab.etn.com/images'
    [ -z "${SOURCESITEROOT_OSIMAGE-}" ] && SOURCESITEROOT_OSIMAGE="$SOURCESITEROOT/${IMGTYPE_PREFIX}${IMGTYPE}${IMGTYPE_SUFFIX}/${IMGQALEVEL:+$IMGQALEVEL/}$ARCH"

    [ -z "${SOURCESITEROOTFW-}" ] && SOURCESITEROOTFW="http://obs.roz.lab.etn.com/flash-rc3/recovery"
    [ -z "${SOURCESITEROOTFW_UBOOT-}" ] && SOURCESITEROOTFW_UBOOT="$SOURCESITEROOTFW"
    [ -z "${SOURCESITEROOTFW_UIMAGE-}" ] && SOURCESITEROOTFW_UIMAGE="$SOURCESITEROOTFW"
    [ -z "${SOURCESITEROOTFW_MODULES-}" ] && SOURCESITEROOTFW_MODULES="$SOURCESITEROOTFW/modules"

    # Recovery location (on MMC or mSATA) - for downloads
    [ -z "${DOWNLOADROOT-}" ] && DOWNLOADROOT="/mnt/mmc/recovery"
    [ -z "${DOWNLOADROOT_OSIMAGE-}" ] && DOWNLOADROOT_OSIMAGE="$DOWNLOADROOT/rootfs"
    [ -z "${DOWNLOADROOTFW_UBOOT-}" ] && DOWNLOADROOTFW_UBOOT="$DOWNLOADROOT"
    [ -z "${DOWNLOADROOTFW_UIMAGE-}" ] && DOWNLOADROOTFW_UIMAGE="$DOWNLOADROOT"
    [ -z "${DOWNLOADROOTFW_MODULES-}" ] && DOWNLOADROOTFW_MODULES="$DOWNLOADROOTFW_UIMAGE/modules"

    # Deployment location (on SPI flash in production) - for boot-mounted OS image
    [ -z "${DEPLOYMENTROOT-}" ] && DEPLOYMENTROOT="/mnt/nand"
    [ -z "${DEPLOYMENTROOT_OSIMAGE-}" ] && DEPLOYMENTROOT_OSIMAGE="$DEPLOYMENTROOT/rootfs"
    [ -z "${DEPLOYMENTROOTFW_UBOOT-}" ] && DEPLOYMENTROOTFW_UBOOT="$DEPLOYMENTROOT"
    [ -z "${DEPLOYMENTROOTFW_UIMAGE-}" ] && DEPLOYMENTROOTFW_UIMAGE="$DEPLOYMENTROOT"
    [ -z "${DEPLOYMENTROOTFW_MODULES-}" ] && DEPLOYMENTROOTFW_MODULES="$DEPLOYMENTROOTFW_UIMAGE/modules"

    [ -z "${http_proxy-}" -o x"${http_proxy-}" = x- ] && http_proxy=""
    [ -z "${https_proxy-}" ] && https_proxy="$http_proxy"
    [ -z "${ftp_proxy-}" ]   && ftp_proxy="$http_proxy"
    [ -z "${ftps_proxy-}" ]  && ftps_proxy="$http_proxy"
    [ x"${https_proxy-}" = x- ] && https_proxy=""
    [ x"${ftp_proxy-}" = x- ]   && ftp_proxy=""
    [ x"${ftps_proxy-}" = x- ]  && ftps_proxy=""
    export http_proxy https_proxy ftp_proxy ftps_proxy

    # The RC3 SPI flash partitioning determines these sizes, value hardcoded in the
    # default installation routines as well as the init/upgrade script in uImage.
    # These numbers are used for "padded" checksum calculations.
    UIMAGE_MAX_SIZE_RC3=3145728
    UBOOT_MAX_SIZE_RC3=1048576
    [ -z "${UIMAGE_MAX_SIZE-}" ] && UIMAGE_MAX_SIZE="$UIMAGE_MAX_SIZE_RC3"
    [ -z "${UBOOT_MAX_SIZE-}" ] && UBOOT_MAX_SIZE="$UBOOT_MAX_SIZE_RC3"

    # /dev/mtdX numbers for RC3 partitions
    ROOT_MTD=5
    KERNEL_MTD=4
    UBOOTCFG_MTD=3
    UBOOT_MTD=2


    PATH="/sbin:/usr/sbin:/usr/local/sbin:/bin:/usr/bin:/usr/local/bin:$PATH"
    export PATH
}

### NOTE: This script can be copied to VM hosts and used standalone, so we do
### not depend it on scriptlib.sh or anything else. Implement a few bits here.

### This is prefixed before ERROR, WARN, INFO tags in the logged messages
LOGMSG_PREFIX="BIOS-UPDATE-RC3-"

### Store some important CLI values
[ -z "$_SCRIPT_PATH" ] && _SCRIPT_PATH="$0"
[ -z "$_SCRIPT_NAME" ] && _SCRIPT_NAME="`basename "${_SCRIPT_PATH}"`"
_SCRIPT_ARGS="$*"
_SCRIPT_ARGC="$#"

usage() {
    echo "Usage: ${_SCRIPT_NAME} [options...]"
    echo "Options:"
    echo "  --help | -help | -h       Display this hep and exit"
    echo "  --config | -c             Source an additional config file (beside looking in"
    echo "                            standard locations e.g. '/etc/update-rc3.d/*.conf')"
    echo '  --no-config-file          Do not source default /etc/update-rc3.d/*.conf files'
    echo "  -ls              List remote images (except standard checksum files) and do an"
    echo "                   estimate if the newest differ from local copies. Effect and"
    echo "                   exitcodes similar to --check* below but with different output."
    echo "  --(no-)check-image-os, --(no-)check-image-fw, --(no-)check-images"
    echo "                   Only check the source location if new images are available"
    echo "                   and exit, whatever the outcome (returns 0 if nothing found,"
    echo "                   42 if there is something to download)"
    echo "  --dry-run | -n            Alias to --check-images (check both OS and FW)"
    echo "  --(no-)download-image-os  Enable or disable downloading of OS images"
    echo "  --(no-)download-image-fw  Likewise for downloading of uBoot, uImage+modules"
    echo "  --(no-)download-images    Enable or disable downloading of all image types"
    echo "  --fw-only                 Alias to --no-download-image-os --download-image-fw"
    echo "  --os-only                 Alias to --download-image-os --no-download-image-fw"
    echo "  --(no-)removeold-image-os, --(no-)removeold-image-fw, --(no-)removeold-images"
    echo "                   If download-image of this type was requested and successful,"
    echo "                   or if download was not requested at all, remove all but the"
    echo "                   newest (alphabetcally) image file from the recovery location"
    echo "                   NOTE: For flat namespace, removes all 'other' image types!"
    echo "  --(no-)remove-files       Skip removing image files deemed corrupt or obsolete"
    echo "  --(no-)flatten-filenames  Skip renaming image files to include ARCH and TYPE"
    echo "                            for easier differentiation in the flat storage dirs"
    echo "For the check* and download* methods, you can specify a full URL to the image"
    echo "file which you want rather than trying to detect the newest one available, with"
    echo "the following arguments ('raw' firmwares are the non-tarballed singular files):"
    echo "  --url-image-os {URL} (expected checksum patterns should still exist nearby)"
    echo "  --url-image-fw-raw-uboot --url-image-fw-raw-uimage --url-image-fw-raw-modules"
    echo "  --(no-)erase-factory-reset If a new OS image downloaded successfully, touch"
    echo "                   the control file so 'init' does a factory reset after reboot"
    echo "  --touch-factory-reset      Enforce a factory-reset for next boot"
    echo "  --(no-)erase-all           If a new OS image downloaded successfully, then"
    echo "                   request a factory reset + NAND format after reboot"
    echo "  --touch-erase-all          Enforce a factory reset + NAND format next boot"
    echo "For HTTP(S) or FTP(S) based delivery, do not forget to set http_proxy URL as"
    echo "applicable for your environment. Current value is '$http_proxy'."
# TODO(recurring) Maintain usage() as CLI options get added to the script
}

SCRIPTDIR=$(realpath "`dirname ${_SCRIPT_PATH}`") || \
    SCRIPTDIR=$(cd "`dirname ${_SCRIPT_PATH}`" && pwd)
SCRIPTPWD="`pwd`"
if [ -z "$CHECKOUTDIR" ] ; then
    CHECKOUTDIR=$(realpath "$SCRIPTDIR/../..") || \
        CHECKOUTDIR=$(cd "$SCRIPTDIR/../.." && pwd)
fi
[ "$CHECKOUTDIR" = / -o ! -d "$CHECKOUTDIR/tests/CI" ] && CHECKOUTDIR=""
[ -z "$BUILDSUBDIR" ] && BUILDSUBDIR="$CHECKOUTDIR"
export CHECKOUTDIR BUILDSUBDIR

[ -z "$LANG" ] && LANG=C
[ -z "$LANGUAGE" ] && LANGUAGE=C
[ -z "$LC_ALL" ] && LC_ALL=C
[ -z "$TZ" ] && TZ=UTC
export LANG LANGUAGE LC_ALL TZ

logmsg_info() {
    echo "${LOGMSG_PREFIX}INFO:" "$1"
    shift
    for L in "$@" ; do echo "$L"; done
    return 0
}

logmsg_warn() {
    echo "${LOGMSG_PREFIX}WARN:" "$1" >&2
    shift
    for L in "$@" ; do echo "$L"; done >&2
    return 0
}

logmsg_error() {
    echo "${LOGMSG_PREFIX}ERROR:" "$1" >&2
    shift
    for L in "$@" ; do echo "$L"; done >&2
    return 0
}

die() {
    CODE="${CODE-1}"
    [ "$CODE" -ge 0 ] 2>/dev/null || CODE=1
    for LINE in "$@" ; do
        echo "${LOGMSG_PREFIX}FATAL:" "$LINE" >&2
    done
    exit $CODE
}

settraps() {
    # Not all trap names are recognized by all shells consistently
    # Note: slight difference from scriptlib.sh, we trap ERR too by default
    [ -z "${TRAP_SIGNALS-}" ] && TRAP_SIGNALS="ERR  EXIT QUIT TERM HUP INT"
    for P in "" SIG; do for S in $TRAP_SIGNALS ; do
        case "$1" in
        -|"") trap "$1" $P$S 2>/dev/null || true ;;
        *)    trap 'ERRCODE=$?; ('"$*"'); exit $ERRCODE;' $P$S 2>/dev/null || true ;;
        esac
    done; done
}

##############################################################################
get_csalgo_from_filename() {
    # Parse (extensions of) the filename in "$1" to retrieve the
    # checksum algo (if any); set of supported algos and extensions
    # is to be kept in sync with remove_image() above.
    _A="`echo "$1" | tr '[A-Z]' '[a-z]' | sed -e 's,\.tmp$,,' -e 's,^.*\.\([^\.]*\)$,\1,' -e 's,-padded$,,'`" || _A=""

    case "${_A}" in
        md5|sha|sha1|sha224|sha256|sha384|sha512)
            echo "${_A}"
            unset _A
            return 0 ;;
        "") logmsg_error "Could not extract checksum algorithm from filename '$1'"
            unset _A
            return 31 ;;
        *)  logmsg_error "Unrecognized checksum algorithm: '${_A}'"
            unset _A
            return 32 ;;
    esac
}

calculate_stream_checksum() {
    # Calculate and print to stdout checksum of the stdin stream using algo "$1"
    # Use the function above to validate known algorithm names
    # We expect to have either ${ALGO}sum program or openssl support for ${ALGO}
    if [ -z "${1-}" ]; then
        ALGO="${CHECKSUM_ALGO_DEFAULT}"
    else
        ALGO="`get_csalgo_from_filename "$1"`" || return $?
    fi

    if [ -x "`which openssl`" ] 2>/dev/null ; then
        openssl dgst -"${ALGO}" | awk '{print $NF}'
        return $?
    fi

    ${ALGO}sum | awk '{print $1}'
    return $?
}

expected_checksum() (
    # Extracts precalculated checksum of file "$1" recorded in file "$2"
    CHECKSUM_EXP="$(grep -i "`basename "$1"`" < "$2" | awk '{print $1}')" 2>/dev/null
    if [ $? != 0 -o -z "$CHECKSUM_EXP" ] && [ "`wc -l < "$2"`" -eq 1 ] ; then
        # Maybe the whole file content is one line with the value
        CHECKSUM_EXP="`awk '{print $1}' < "$2"`"
    fi
    [ -n "$CHECKSUM_EXP" ] && echo "$CHECKSUM_EXP"
    # If the value is empty, this statement returns an error exit-code
)

# Colon-separated values: CHECKSUM:LENGTH:ALGO:PATHNAME
# Length of -1 means full file or device byte-range
CHECKSUM_CACHE=""
find_checksum_cache() {
    # Finds from the cache the entry with given pathname $3 and algo $2 and length $1
    [ $# != 3 ] && return 22
    [ -z "${CHECKSUM_CACHE}" ] && return 1
    echo "$CHECKSUM_CACHE" | egrep '^[^\:]+'":$1:$2:$3"'$' | awk -F: '{print $1}'
}

remove_checksum_cache() {
    # Removes from the cache the entry with given pathname $3 and algo $2 and length $1
    [ $# != 3 ] && return 22
    [ -z "${CHECKSUM_CACHE}" ] && return 0
    CHECKSUM_CACHE="`echo "$CHECKSUM_CACHE" | egrep -v '^[^\:]+'"$1:$2:$3"'$'`"
}

add_checksum_cache() {
    # Adds to the cache if the given pathname and algo and length are missing
    # If a value exists, it is replaced
    # Arguments $1..$4 are same as in CHECKSUM_CACHE above
    [ $# != 4 ] && return 22
    if [ -z "${CHECKSUM_CACHE}" ]; then
        CHECKSUM_CACHE="$1:$2:$3:$4"
    else
        CHECKSUM_CACHE="`echo "$CHECKSUM_CACHE" | egrep -v '^[^\:]+'":$2:$3:$4"'$'`
$1:$2:$3:$4"
    fi
}

remove_image() {
    # Remove the image file "$1" and its possible checksum patterns,
    # and the optional explicit checksum filename that can be in "$2"
    # If the RETAIN_FILE variable is set, keep this file (downloaded new CS)
    [ x"${FLAG_CAN_REMOVE_IMAGES-}" = xno ] && \
        logmsg_info "FLAG_CAN_REMOVE_IMAGES=$FLAG_CAN_REMOVE_IMAGES so do not remove_image($*)" && \
        return 0
    [ -n "$RETAIN_FILE" ] && [ -s "$RETAIN_FILE" ] && \
        logmsg_info "Retaining '$RETAIN_FILE' during remove_image($*)" && \
        mv -f "$RETAIN_FILE" "$RETAIN_FILE.$$"
    remove_checksum_cache '[^\:]*' '[^\:]*' "$1"
    remove_checksum_cache '[^\:]*' '[^\:]*' "$1"'\.[^\:]*'
    rm -f "$1"{,.md5,.sha,.sha1,.sha224,.sha256,.sha384,.sha512}{,-padded}{,.tmp} ${2:+"$2"}
    [ -n "$RETAIN_FILE" ] && [ -s "$RETAIN_FILE.$$" ] && mv -f "$RETAIN_FILE.$$" "$RETAIN_FILE"
}

verify_checksum() {
    # Compares actual checksum of file "$1" with value recorded in file "$2"
    # with optional algorithm in "$3" (defaults to CHECKSUM_ALGO_DEFAULT='md5')
    # TODO: add generalized support for .${CHECKSUM_ALGO_DEFAULT}-padded checksum files (firmware imgs)
    # TODO (later): Support file sizes as part of checksum info
    FILENAME_DATA="$1"
    FILENAME_CSUM="${2-}"
    [ -z "$FILENAME_CSUM" ] && \
        FILENAME_CSUM="$FILENAME_DATA.${CHECKSUM_ALGO_DEFAULT}"
    if [ -z "${3-}" ]; then
        CHECKSUM_ALGO="`get_csalgo_from_filename "$FILENAME_CSUM"`"
        [ $? = 0 -a -n "$CHECKSUM_ALGO" ] || \
            CHECKSUM_ALGO="${CHECKSUM_ALGO_DEFAULT}"
    else
        CHECKSUM_ALGO="$3"
    fi
    LOGINTRO="Checksum validation of '$FILENAME_DATA' against value in '$FILENAME_CSUM' ($CHECKSUM_ALGO)"

    if [ -n "$FILENAME_DATA" ] && [ -n "$FILENAME_CSUM" ] && \
       [ -s "$FILENAME_DATA" -o -c "$FILENAME_DATA" -o -b "$FILENAME_DATA" ] && \
       [ -s "$FILENAME_CSUM" ] \
    ; then
        logmsg_info "Beginning $LOGINTRO..."

        CHECKSUM_EXP="`expected_checksum "$FILENAME_DATA" "$FILENAME_CSUM"`"
        if [ $? != 0 -o -z "$CHECKSUM_EXP" ]; then
            logmsg_warn "$LOGINTRO SKIPPED (can not detect expected value)"
            return 0
        fi

        CHECKSUM_ACT="`find_checksum_cache '-1' "${CHECKSUM_ALGO}" "${FILENAME_DATA}"`" && \
            [ -n "${CHECKSUM_ACT}" ] && logmsg_info "Got cached checksum (${CHECKSUM_ALGO}) for ${FILENAME_DATA}" \
            || CHECKSUM_ACT=""
        if [ -z "$CHECKSUM_ACT" ]; then
            CHECKSUM_ACT="`calculate_stream_checksum < "$FILENAME_DATA"`"
            if [ $? = 0 ] && [ -n "$CHECKSUM_ACT" ]; then
                add_checksum_cache "${CHECKSUM_ACT}" "-1" "${CHECKSUM_ALGO}" "${FILENAME_DATA}"
            else
                CHECKSUM_ACT=""
            fi
        fi
        if [ -z "$CHECKSUM_ACT" ]; then
            logmsg_warn "$LOGINTRO SKIPPED (can not calculate actual value)"
            return 0
        fi

        if [ x"$CHECKSUM_ACT" = x"$CHECKSUM_EXP" ]; then
            logmsg_info "$LOGINTRO SUCCEEDED!"
            return 0
        fi

        logmsg_error "$LOGINTRO FAILED (mismatch)!"
        echo "ACTUAL: $CHECKSUM_ACT" >&2
        echo "EXPECT: $CHECKSUM_EXP" >&2
        return 1
    fi
    logmsg_warn "$LOGINTRO SKIPPED (one of the files is missing)"
    return 0
}

ensure_checksum() {
    # A destructive wrapper of verify_checksum(), destroys bad downloads
    if ! verify_checksum "$@" ; then
        logmsg_warn "Removing broken file: '$1' and its checksum(s)"
        remove_image "$@" || return $?
        return 1
    fi
    return 0
}

verify_threeway_checksum() {
    # We can have (or not) a local copy of the data file "$2", a local copy
    # of the checksum file "$3", and a freshly fetched copy of remote checksum
    # file "$4" (usually an *.algo.tmp); all previously downloaded by caller
    # from URL in "$1".
    # Return codes:
    #   0       OK, local data and checksum files are (now) consistent, keep'em
    #   1       ERROR, local files inconsistent (removed), re-pull from remote!
    #   2       ERROR, some prerequisites missing, etc.
    # Verify if any of these files match together (in a destructive manner):
    # * If some of the files are not available:
    # ** data file - fail (must download all bits)
    # ** both checksums - fail (legacy mode allowed no checksums, now not so)
    # ** local checksum - fall through (only compare to remote checksum then)
    # ** remote checksum - fall through (only compare to local checksum then)
    # * If two checksums are the same (both in algo and value), remove the
    #   newly downloaded one and fall through for verifications
    # * If the remote checksum file exists (thus different from local) and
    #   a checksum value is detected from it:
    # ** If the remote checksum value does match the file - assume it to be
    #    authoritative and local one possibly broken (overwrite checksum file)
    # ** If the remote checksum does not match, assume the source file updated
    #    in-place on the remote source - kill local data and return error
    #    (caller would pull remote files)
    # * If the local CS+DATA do NOT match together, kill them and return error
    # * If neither checksum matches - kill local data and return error

    # The IMAGE_URL_BASENAME_EXT (on remote site with hierarchical structure)
    # may be different from local FILE_DATA name (with flattened structure).
    local IMAGE_URL="$1"
    local IMAGE_URL_BASENAME
    local IMAGE_URL_BASENAME_EXT
    # Basenames of data and checksum files (under current dir set by caller
    # or absolute - e.g. for recovery vs. deployed storage locations).
    # Theoretically checksums may be from different algorithms (see extension).
    local FILE_DATA="$2"
    local FILE_CSOLD="$3"
    local FILE_CSNEW="$4"

    local CSNEW CSOLD CSNEWALGO CSOLDALGO

    local FILE_DIR="`pwd`"
    case "$FILE_DATA" in
        /*) FILE_DIR="`dirname "$FILE_DATA"`";;
        ./*|../*) FILE_DIR="`pwd`/`dirname "$FILE_DATA"`"; FILE_DATA="$FILE_DIR/`basename "$FILE_DATA"`";;
        *) FILE_DATA="$FILE_DIR/$FILE_DATA" ;;
    esac
    case "$FILE_CSOLD" in
        /*) ;;
        ./*|../*) FILE_CSOLD="`pwd`/$FILE_CSOLD";;
        *) FILE_CSOLD="$FILE_DIR/$FILE_CSOLD" ;;
    esac
    case "$FILE_CSNEW" in
        /*) ;;
        ./*|../*) FILE_CSNEW="`pwd`/$FILE_CSNEW";;
        *) FILE_CSNEW="$FILE_DIR/$FILE_CSNEW" ;;
    esac

    [ -n "$IMAGE_URL" ] && \
    IMAGE_URL_BASENAME="`basename "$IMAGE_URL" ".${EXT}"`" && \
    [ -n "$IMAGE_URL_BASENAME" ] && \
    IMAGE_URL_BASENAME_EXT="${IMAGE_URL_BASENAME}${EXT:+.$EXT}" || \
        { logmsg_warn "Could not resolve IMAGE_URL value '$IMAGE_URL' into a filename"
          IMAGE_URL=""; IMAGE_URL_BASENAME=""; IMAGE_URL_BASENAME_EXT=""; }

    if [ ! -s "$FILE_DATA" ] && [ ! -c "$FILE_DATA" ] && [ ! -b "$FILE_DATA" ] ; then
        logmsg_info "Local data file '$FILE_DATA' is missing"
        return 2
    fi

    if [ ! -s "$FILE_CSOLD" ] && [ ! -s "$FILE_CSNEW" ] ; then
        logmsg_info "Both checksum files '$FILE_CSOLD' and '$FILE_CSNEW' are missing"
        return 2
    fi

    # If checksum files are available, try to get checksum values using the
    # current (local) or maybe original (remote from IMAGE_URL) filename.
    [ -s "$FILE_CSOLD" ] && \
        CSOLDALGO="`get_csalgo_from_filename "$FILE_CSOLD"`" && \
        { CSOLD="`expected_checksum "$FILE_DATA" "$FILE_CSOLD"`" || \
          CSOLD="`[ -z "$IMAGE_URL_BASENAME_EXT" ] && [ x"$FILE_DATA" != x"$IMAGE_URL_BASENAME_EXT" ] && expected_checksum "$IMAGE_URL_BASENAME_EXT" "$FILE_CSOLD"`" ; } || \
        { CSOLD=""; CSOLDALGO=""; logmsg_info "Local checksum file '$FILE_CSOLD' is missing"; }

    [ -s "$FILE_CSNEW" ] && \
        CSNEWALGO="`get_csalgo_from_filename "$FILE_CSNEW"`" && \
        { CSNEW="`expected_checksum "$FILE_DATA" "$FILE_CSNEW"`" || \
          CSNEW="`[ -z "$IMAGE_URL_BASENAME_EXT" ] && [ x"$FILE_DATA" != x"$IMAGE_URL_BASENAME_EXT" ] && expected_checksum "$IMAGE_URL_BASENAME_EXT" "$FILE_CSNEW"`" ; } || \
        { CSNEW=""; CSNEWALGO=""; logmsg_info "Remote checksum file '$FILE_CSNEW' is missing"; }

    if [ -z "$CSNEW" ] && [ -z "$CSOLD" ]; then
        logmsg_info "Could not get usable checksum values from both checksum files: '$FILE_CSOLD' and '$FILE_CSNEW'"
        return 2
    fi

    # Now that we have a validated request, do the actual suite of comparisons.
    if [ -n "$CSNEWALGO" ] && [ -n "$CSNEW" ] && \
       [ -n "$CSOLDALGO" ] && [ -n "$CSOLD" ] \
    ; then
        if [ x"$CSNEWALGO" = x"$CSOLDALGO" ]; then
            if [ x"$CSNEW" = x"$CSOLD" ]; then
                logmsg_info "Old and new checksum values are the same; keeping old checksum file and discarding new one"
                rm -f "$FILE_CSNEW"
                CSNEW=""
                CSNEWALGO=""
            else
                logmsg_warn "Old and new checksum values differ with same algo ($CSOLDALGO): '$CSOLD' vs '$CSNEW'"
            fi
        else
            logmsg_warn "Old and new checksum files have different algorithms: '$CSOLDALGO' vs '$CSNEWALGO' (so values are not comparable directly)"
        fi
    fi

    [ -n "$CSNEW" ] && \
    if verify_checksum "$FILE_DATA" "$FILE_CSNEW" ; then
        if [ x"${REPLACE_MISSING_CHECKSUM-}" = xno ] && [ ! -f "$FILE_CSOLD" ] ; then
            logmsg_info "Remote checksum is good in '$FILE_CSNEW' and local copy was missing - not installing new checksum file"
        else
            logmsg_info "Remote checksum is good in '$FILE_CSNEW', local copy was corrupted or missing - replacing checksum file"
            mv -f "$FILE_CSNEW" "$FILE_CSOLD"
        fi && \
            logmsg_info "The newest available remote image is '$IMAGE_URL' and we already have a good copy (as '$FILE_DATA')"
        return $?
    else
        # In-place changes are not nice but can happen e.g. for FW images
        logmsg_info "Remote checksum in '$FILE_CSNEW' is not good for '$FILE_DATA', local file is corrupted or obsolete and should be re-downloaded from '$IMAGE_URL'"
        if [ ! -c "$FILE_DATA" ] && [ ! -b "$FILE_DATA" ] ; then
            RETAIN_FILE="$FILE_CSNEW" remove_image "$FILE_DATA"
        fi
        return 1
    fi

    # Here we do not have a new checksum value for whatever reason
    [ -n "$CSOLD" ] && \
    if verify_checksum "$FILE_DATA" "$FILE_CSOLD" ; then
        logmsg_info "Local checksum matched for '$FILE_CSOLD'"
        return 0
    else
        # Verifying against old checksum failed, so data file and its related
        # files (checksums) should be removed; keep the FILE_CSNEW if available
        logmsg_info "Local checksum mismatched for '$FILE_CSOLD', local file is corrupted and should be re-downloaded from '$IMAGE_URL'"
        if [ ! -c "$FILE_DATA" ] && [ ! -b "$FILE_DATA" ] ; then
            RETAIN_FILE="$FILE_CSNEW" remove_image "$FILE_DATA"
        fi
        return 1
    fi

    logmsg_info "Neither path of three-way verification has succeeded for '$FILE_DATA', it should be re-downloaded from '$IMAGE_URL'"
    if [ ! -c "$FILE_DATA" ] && [ ! -b "$FILE_DATA" ] ; then
        RETAIN_FILE="$FILE_CSNEW" remove_image "$FILE_DATA"
    fi
    return 1
}

##################################################

# Routines below come from bios-boot::init codebase
readbytes() {
    # Input: "$1" == total size in bytes to copy from stdin to stdout;
    # chunked by $BS as much as possible for speed
    [ "$1" -ge 0 ] || \
        { echo "readbytes(): bad input size '$1'" ; return 1; }
    BS=16384
    if [ "$1" -le "$BS" ]; then
        dd bs=1 count="$1"
        return $?
    else
        dd bs="$BS" count="`expr $1 / $BS`" && \
        dd bs=1 count="`expr $1 % $BS`"
        return $?
    fi 2>/dev/null
}

calculate_stream_checksum_bytes() {
    # Calculate and print to stdout checksum of "$1" bytes from the stdin
    # stream using algo "$2" (or default algo, if not specified)
    readbytes "$1" | calculate_stream_checksum $2
}

filesize() {
    # Prints logical size of file in "$1", avoids dependency on ext.parsers
    ls -lHd "$1" | while \
        read _P _I _U _G _SZ _D1 _D2 _D3 _N; do echo ${_SZ}; done
}


##################################################

lshost_http() (
    # List the remote resource "$1" which is an apache-style http directory
    # (HTML) and return links that are relative or under the same virtserver
    REMOTE_DIR="`echo "$1" | sed 's,/$,,g'`"
    REMOTE_ROOTURL="`echo "$REMOTE_DIR" | sed 's,^\(.*://[^/]*\)/.*$,\1,'`"
    # Hostname from the URL, without schema and port
    REMOTE_VIRTHOST="`echo "$REMOTE_DIR" | sed 's,^.*://\([^/:]*\)[/:].*$,\1,'`"
    wget -q -O - "$REMOTE_DIR"/ | \
        sed -n 's|.*href="\([^\"]*\)".*|\1|pg' | \
    while read URL ; do
#        echo "DEBUG: lshost_http(): got URL='$URL'" >&2
        case "$URL" in
            "[Hh][Tt]|[Tt][Pp]?([Ss])://${REMOTE_VIRTHOST}[:/]"*)
                # URL is under this virthost
                echo "$URL" ;;
            "[Hh][Tt][Tt][Pp]?([Ss])://"*)
                # URL is under some other virthost
                ;;
            *://*)
                # URL is under some unknown schema (e.g. FTP)
                ;;
            /*)  # Assume relative URL under server root
                echo "${REMOTE_ROOTURL}/${URL}" ;;
            *)  # Assume relative URL under current dir
                echo "${REMOTE_DIR}/${URL}" ;;
        esac
    done | sed 's,\([^:]\)//,\1/,g'
)

lsdir_http() (
    # List the remote resource "$1/" which is an apache-style http directory
    # and selects URLs starting with this "$1/"
    REMOTE_DIR="`echo "$1" | sed 's,/$,,g'`"
    lshost_http "$REMOTE_DIR" | egrep -i "^$REMOTE_DIR/"
)

lsdir_http_pattern() {
    # List the remote directory resource "$1/" and select sub-files by glob $2
    # See "Pathname Expansion" in `man bash` for syntax details
    REMOTE_DIR="`echo "$1" | sed 's,/$,,g'`"
    REMOTE_GLOB="$2"
    lsdir_http "$REMOTE_DIR" | while read URL; do
#        echo "DEBUG: lsdir_http_pattern('$REMOTE_DIR', '$REMOTE_GLOB'): got URL='$URL'" >&2
        case "$URL" in
            $REMOTE_DIR/$REMOTE_GLOB) echo "$URL" ;;
        esac
    done
}


##################################################

sort_osimage_names() {
    # ASSUMPTION: we don't have over 999 rebuilds of the same baseline image ;)
    # ASSUMPTION2: all image builds have a rebuild-index suffix for the same
    # baseline, or there is one old image for a baseline without a suffix.
    ### sort
    ### sort -n
    sed -e 's,-\([[:digit:]][[:digit:]]\.[[:digit:]][[:digit:]]\.[[:digit:]][[:digit:]]\)_,-\1-0_,' \
        -e 's,-\([[:digit:]]\)_,-0\1_,' \
        -e 's,-\([[:digit:]][[:digit:]]\)_,-0\1_,' \
    | sort -n | \
    sed -e 's,-0*\([123456789][[:digit:]]*\)_,-\1_,' \
        -e 's,-00*_,_,'
}

findnewest_osimage() (
    # Echo the URL to the newest OS image file found on remote resource, if any
    # Note: currently expects certain filename patterns and http-dir listing markup
    IMAGE_URL="`lsdir_http_pattern "${SOURCESITEROOT_OSIMAGE}" "${SOURCESITEROOT_OSIMAGE_FILENAMEPATTERN}.${EXT}" | sort_osimage_names | tail -1`"
    if [ $? = 0 -a x"$IMAGE_URL" != x ]; then
        [ x"`basename "$IMAGE_URL" .${EXT}`" != x ] && \
        echo "$IMAGE_URL" && return 0
    fi
    logmsg_error "Error looking up remote file: Make sure your settings (including proxy if needed) are correct."
    return 1
)

download_osimage() (
    # If the caller sets CHECK_ONLY=yes and no copy of the remote image is
    # found on this local system, then the routine just returns code "42"
    # instead of downloading this detected new image otherwise.
    # A successful download of an image (consistent non-empty file) is 42 too

    # We do not download OS images into NAND (like FW image fallback),
    # not by easy default at least
    cd "${DOWNLOADROOT_OSIMAGE}" || {
        if [ x"${CHECK_ONLY-}" = xyes ]; then
            cd "${DOWNLOADROOTFW_OSIMAGE}" || die "Can not use DOWNLOADROOT_OSIMAGE='$DOWNLOADROOT_OSIMAGE' or DOWNLOADROOTFW_OSIMAGE='$DOWNLOADROOTFW_OSIMAGE'"
        else
            die "Can not use DOWNLOADROOT_OSIMAGE='$DOWNLOADROOT_OSIMAGE'"
        fi
    }

    case "${1-}" in
            *://*)
                logmsg_info "download_osimage() was asked to try downloading '$1' as the ${IMGTYPE} OS image for ${ARCH}"
                IMAGE_URL="$1" ;;
            "")
                logmsg_info "Fetching newest remote filename for ${ARCH} OS image of type ${IMGTYPE}..."
                IMAGE_URL="`findnewest_osimage`" && [ -n "$IMAGE_URL" ] \
                && logmsg_info "download_osimage() detected '$IMAGE_URL' as the newest remote ${IMGTYPE} OS image for ${ARCH}" \
                || { logmsg_error "Could not find any remote OS image"; IMAGE_URL="";} ;;
            *)  logmsg_error "download_osimage() got an unsupported argument: $*"
                IMAGE_URL=""
                ;; # This dies a bit below
    esac

    case "$IMAGE_URL" in
            *"${IMGTYPE}"*) ;;
            "") ;; # This dies a bit below
            *)  logmsg_warn "The IMAGE_URL='$IMAGE_URL' does not contain IMGTYPE='$IMGTYPE'!" ; sleep 5 ;;
    esac

    case "$IMAGE_URL" in
            *"${ARCH}"*) ;;
            "") ;; # This dies a bit below
            *)  logmsg_warn "The IMAGE_URL='$IMAGE_URL' does not contain ARCH='$ARCH'!" ; sleep 5 ;;
    esac

    [ -n "$IMAGE_URL" ] && \
    rIMAGE_URL_BASENAME="`basename "$IMAGE_URL" ".${EXT}"`" && \
        [ -n "$rIMAGE_URL_BASENAME" ] && \
        rIMAGE_URL_BASENAME_EXT="${rIMAGE_URL_BASENAME}${EXT:+.$EXT}" || \
        die "Can not find the remote image URL"

    # TODO: Currently hardcoded for md5 accompanying checksums only
    # TODO (later): Support presence of multiple checksum files (e.g. sha* and md5)
    IMAGE_CSALGO="${CHECKSUM_ALGO_DEFAULT}"

    # NOTE: "Old" filename and checksum are basenames that can be located under
    # different directories ("r"elative varnames), but e.g. a "new" checksum is
    # ensured to be in a temporary location and a newly downloaded file should
    # land into the recovery location ("a"bsolute varnames)
    IMAGE_CSURL="${IMAGE_URL}.${IMAGE_CSALGO}"
    rIMAGE_CSOLD="${rIMAGE_URL_BASENAME_EXT}.${IMAGE_CSALGO}"
    aIMAGE_CSNEW="/tmp/${rIMAGE_URL_BASENAME_EXT}.$$.${IMAGE_CSALGO}.tmp"

    # We rename the incoming image to include the type in flat directory space
    rTGT_FILE="${rIMAGE_URL_BASENAME_EXT}"
    case "${rIMAGE_URL_BASENAME}" in
        *__${ARCH}__${IMGTYPE}|*${IMGTYPE}*-*_${ARCH}) # Already good and flat
            ;;
        *)  if [ x"$FLAG_FLATTEN_FILENAMES" = xyes ]; then
                rTGT_FILE="${rIMAGE_URL_BASENAME}__${ARCH}__${IMGTYPE}${EXT:+.$EXT}" && \
                [ -n "$rTGT_FILE" ] || \
                die "Can not produce the relative TGT_FILE value to save into"
            fi
            ;;  # Had to define TGT_FILE different from rIMAGE_URL_BASENAME
    esac

    rTGT_FILE_CSOLD="${rTGT_FILE}.${IMAGE_CSALGO}"
    aTGT_FILE_CSNEW="/tmp/${rTGT_FILE}.$$.${IMAGE_CSALGO}.tmp"

    trap 'TRAPCODE=$?; rm -f "$aTGT_FILE_CSNEW" "$aIMAGE_CSNEW"; exit $TRAPCODE' 0

    logmsg_info "Downloading '${IMAGE_CSURL}' (if any) into '${aIMAGE_CSNEW}'..."
    rm -f "${aIMAGE_CSNEW}"
    wget -q -O - "${IMAGE_CSURL}" > "${aIMAGE_CSNEW}" || \
        { logmsg_error "Could not save '${IMAGE_CSURL}' into '${aIMAGE_CSNEW}'"
          rm -f "${aIMAGE_CSNEW}"
          if [ x"${CHECK_ONLY-}" = xyes ]; then
            die "Got an error while checking if there is something new to download, so no reason to proceed"
          fi
        }

    if [ ! -s "${aTGT_FILE_CSNEW}" ] ; then
        logmsg_info "Processing '${IMAGE_CSURL}' (if any) to flatten the names into '${aTGT_FILE_CSNEW}'..."
        { [ -s "${aIMAGE_CSNEW}" ] && cat "${aIMAGE_CSNEW}" || wget -q -O - "${IMAGE_CSURL}"; } | \
        sed 's,  .*$,  '"`basename "$rTGT_FILE"`", > "${aTGT_FILE_CSNEW}" || \
            { logmsg_error "Could not save and process '${IMAGE_CSURL}' into '${aTGT_FILE_CSNEW}'"
              rm -f "${aTGT_FILE_CSNEW}"
            }
    fi

    # First try the modified filenames in local directories: more probable hit
    if [ x"$rTGT_FILE" != x"$rIMAGE_URL_BASENAME_EXT" ] ; then
        if [ -s "$aTGT_FILE_CSNEW" ] && [ x"$aTGT_FILE_CSNEW" != x"${aIMAGE_CSNEW}" ]; then
            logmsg_info "Verifying if we have this checksum and corresponding file under flat name of data and checksum files..."
            verify_threeway_checksum "${IMAGE_URL}" "${rTGT_FILE}" "${rTGT_FILE_CSOLD}" "${aTGT_FILE_CSNEW}" && return 0
            if [ -d "${DEPLOYMENTROOT_OSIMAGE}" ] ; then
                # Do not remove deployed files!
                logmsg_info "Verifying if we have this checksum and corresponding file already deployed..."
                FLAG_CAN_REMOVE_IMAGES="no" verify_threeway_checksum "${IMAGE_URL}" \
                    "${DEPLOYMENTROOT_OSIMAGE}/${rTGT_FILE}" \
                    "${DEPLOYMENTROOT_OSIMAGE}/${rTGT_FILE_CSOLD}" \
                    "${aTGT_FILE_CSNEW}" \
                && { echo "${DEPLOYMENTROOT_OSIMAGE}/${rTGT_FILE}" > "$DOWNLOADROOT_OSIMAGE/.newest-osimage"; return 0; }
            fi
        fi
        logmsg_info "Verifying if we have this checksum and corresponding file under flat name of data and original name of checksum file..."
        verify_threeway_checksum "${IMAGE_URL}" "${rTGT_FILE}" "${rTGT_FILE_CSOLD}" "${aIMAGE_CSNEW}" && return 0
        if [ -d "${DEPLOYMENTROOT_OSIMAGE}" ] ; then
            # Do not remove deployed files!
            logmsg_info "Verifying if we have this checksum and corresponding file already deployed..."
            FLAG_CAN_REMOVE_IMAGES="no" verify_threeway_checksum "${IMAGE_URL}" \
                "${DEPLOYMENTROOT_OSIMAGE}/${rTGT_FILE}" \
                "${DEPLOYMENTROOT_OSIMAGE}/${rTGT_FILE_CSOLD}" \
                "${aIMAGE_CSNEW}" \
                && { echo "${DEPLOYMENTROOT_OSIMAGE}/${rTGT_FILE}" > "$DOWNLOADROOT_OSIMAGE/.newest-osimage"; return 0; }
        fi
    fi

    # Then try unmodified filenames in local directories (e.g. USB download)
    logmsg_info "Verifying if we have this checksum and corresponding file under original name in base dir..."
    verify_threeway_checksum "${IMAGE_URL}" "${rIMAGE_URL_BASENAME_EXT}" "${rIMAGE_CSOLD}" "${aIMAGE_CSNEW}" \
    && { echo "${rIMAGE_URL_BASENAME_EXT}" > "$DOWNLOADROOT_OSIMAGE/.newest-osimage"; return 0; }
    if [ -d "${DEPLOYMENTROOT_OSIMAGE}" ] ; then
        # Do not remove deployed files!
        logmsg_info "Verifying if we have this checksum and corresponding file already deployed..."
        FLAG_CAN_REMOVE_IMAGES="no" verify_threeway_checksum "${IMAGE_URL}" \
            "${DEPLOYMENTROOT_OSIMAGE}/${rIMAGE_URL_BASENAME_EXT}" \
            "${DEPLOYMENTROOT_OSIMAGE}/${rIMAGE_CSOLD}" \
            "${aIMAGE_CSNEW}" \
        && { echo "${DEPLOYMENTROOT_OSIMAGE}/${rIMAGE_URL_BASENAME_EXT}" > "$DOWNLOADROOT_OSIMAGE/.newest-osimage"; return 0; }
    fi
    if [ -d "./$IMGTYPE/$ARCH" ]; then
        # Bit of support for container hosts
        logmsg_info "Verifying if we have this checksum and corresponding file under original name in hierarchy..."
        verify_threeway_checksum "${IMAGE_URL}" "./$IMGTYPE/$ARCH/${rIMAGE_URL_BASENAME_EXT}" "./$IMGTYPE/$ARCH/${rIMAGE_CSOLD}" "${aIMAGE_CSNEW}" \
        && { echo "`pwd`/$IMGTYPE/$ARCH/${rIMAGE_URL_BASENAME_EXT}" > "$DOWNLOADROOT_OSIMAGE/.newest-osimage"; return 0; }
    fi

    if [ x"${CHECK_ONLY-}" = xyes ]; then
        logmsg_info "According to checksums, the remote resource '$IMAGE_URL' points to an OS image we do not have on this system"
        return 42
    fi

    # If we are here, the IMAGE_URL is valid and points to a different content
    # than what we already have; the TGT_FILE names the ultimate local filename
    if [ -d "./$IMGTYPE/$ARCH" ]; then
        aTGT_FILE="`pwd`/$IMGTYPE/$ARCH/${rTGT_FILE}"
        aTGT_FILE_CSOLD="`pwd`/$IMGTYPE/$ARCH/${rTGT_FILE_CSOLD}"
    else
        aTGT_FILE="`pwd`/${rTGT_FILE}"
        aTGT_FILE_CSOLD="`pwd`/${rTGT_FILE_CSOLD}"
    fi

    if [ x"$aTGT_FILE_CSNEW" != x"${aIMAGE_CSNEW}" ] && [ -s "$aIMAGE_CSNEW" ] && [ -s "$aTGT_FILE_CSNEW" ] ; then
        # We have both a flat and original checksum files; keep one
        if [ x"$FLAG_FLATTEN_FILENAMES" = xyes ]; then
            rm -f "$aIMAGE_CSNEW"
        else
            rm -f "$aTGT_FILE_CSNEW"
        fi
    fi

    if [ ! -s "${aTGT_FILE_CSOLD}" ]; then
        [ -s "${aIMAGE_CSNEW}" ] && cp -f "${aIMAGE_CSNEW}" "${aTGT_FILE_CSOLD}"
        [ -s "${aTGT_FILE_CSNEW}" ] && cp -f "${aTGT_FILE_CSNEW}" "${aTGT_FILE_CSOLD}"
    fi

    logmsg_info "Downloading '$IMAGE_URL' into '$aTGT_FILE'..."
    rm -f "${aTGT_FILE}"
    wget -O "${aTGT_FILE}" "$IMAGE_URL" && [ -s "$aTGT_FILE" ] || \
        { remove_image "$aTGT_FILE"; die "Could not download '$IMAGE_URL' into '$aTGT_FILE'"; }
    remove_checksum_cache '[^\:]*' '[^\:]*' "${aTGT_FILE}"

    if [ -s "${aTGT_FILE_CSOLD}" ]; then
        ensure_checksum "${aTGT_FILE}" "${aTGT_FILE_CSOLD}" || return $?
    else
        logmsg_warn "Generating '${aTGT_FILE_CSOLD}' because there was none at the source..."
        echo "`calculate_stream_checksum "${IMAGE_CSALGO}" < "$aTGT_FILE"`  `basename "$aTGT_FILE"`" > "${aTGT_FILE_CSOLD}" || \
        { rm -f "${aTGT_FILE_CSOLD}"; die "Could not generate '${aTGT_FILE_CSOLD}'"; }
    fi

    [ -s "${aTGT_FILE}" ] && [ -s "${aTGT_FILE_CSOLD}" ] && \
    touch -r "${aTGT_FILE}" "${aTGT_FILE_CSOLD}" && \
    logmsg_info "Got OS image OK:" && \
    ls -ld "${aTGT_FILE}" "${aTGT_FILE_CSOLD}" && \
    cat "${aTGT_FILE_CSOLD}" && \
    { echo "${aTGT_FILE}" > "$DOWNLOADROOT_OSIMAGE/.newest-osimage";
      return 42; }
)

removeold_osimage() (
    cd "${DOWNLOADROOT_OSIMAGE}" || die "Can not use DOWNLOADROOT_OSIMAGE='$DOWNLOADROOT_OSIMAGE'"
    # Sort of implementation for BIOS-1566 snatched from bios-boot::Makefile
    # This removes all but the newest (alphabetically) files for the pattern
    # TODO: add support for hierarchical namespace (container hosts) with
    #       flattened or original filenames inside
    VICTIMS=0
    if [ x"$FLAG_FLATTEN_FILENAMES" = xno ] ; then
        [ -d "./$IMGTYPE/$ARCH" ] && cd "./$IMGTYPE/$ARCH"
        # Alphabetic sort, per timestamps from the builder host
        # but considering the rebuild-suffixes of same baseline
        for F in `ls -1d *.${EXT} 2>/dev/null | grep -v _ | sort_osimage_names | head -n -1` ; do
            [ -n "$F" ] && [ -f "$F" ] && \
            logmsg_info "Removing older OS image: '`pwd`/$F' and its checksum(s)" && \
            if [ -n "$DOWNLOADED_OS_IMAGE" ] && [ -s "$DOWNLOADED_OS_IMAGE" ] && \
                [ "$F" = "`basename "$DOWNLOADED_OS_IMAGE"`" ]; then
                    logmsg_info "Keeping the just-downloaded OS image: '$DOWNLOADED_OS_IMAGE'"
            else
                remove_image "$F"
                VICTIMS=$(($VICTIMS+1))
            fi
        done
    fi

    # For flattened filenames, including those fetched like this from the build
    # server, the "other" image types can block automated updates after reboot
    # (e.g. `devel` always begins alphabetically "newer" than `deploy`).
    # Here we choose the file to keep by timestamp (from the source server).
    for F in \
        `ls -1dt *__${ARCH}__${IMGTYPE}.${EXT} ${IMGTYPE}-*_${ARCH}.${EXT} 2>/dev/null | tail -n +2` \
        `ls -1d *__${ARCH}__*.${EXT} 2>/dev/null | grep -v "__${ARCH}__${IMGTYPE}.${EXT}"` \
        `ls -1d *_${ARCH}.${EXT} 2>/dev/null | grep -v "${IMGTYPE}-.*_${ARCH}.${EXT}"` \
    ; do
        [ -n "$F" ] && [ -f "$F" ] && \
        logmsg_info "Removing older OS image: '`pwd`/$F' and its checksum(s)" && \
        if [ -n "$DOWNLOADED_OS_IMAGE" ] && [ -s "$DOWNLOADED_OS_IMAGE" ] && \
            [ "$F" = "`basename "$DOWNLOADED_OS_IMAGE"`" ]; then
                logmsg_info "Keeping the just-downloaded OS image: '$DOWNLOADED_OS_IMAGE'"
        else
            remove_image "$F"
            VICTIMS=$(($VICTIMS+1))
        fi
    done

    [ "$VICTIMS" -eq 0 ] && logmsg_info "removeold_osimage() had nothing to remove" || \
        logmsg_info "removeold_osimage() requested to remove $VICTIMS file(s)"
    return 0
)

##################################################

findnewest_rawfwimage_uboot() (
    # Echo the URL to the newest "raw" (not tarballed, only one)
    # uBoot image file found on remote resource, if any
    # Note: currently expects certain filename patterns and http-dir listing markup
    for P in 'u-Boot' 'uBoot' ; do
        IMAGE_URL="`lsdir_http_pattern "${SOURCESITEROOTFW_UBOOT}" "$P"`"
        if [ $? = 0 -a x"$IMAGE_URL" != x ]; then
            echo "$IMAGE_URL" && return 0
        fi
    done
    logmsg_error "Error looking up remote file: Make sure your settings (including proxy if needed) are correct."
    return 1
)

download_rawfwimage_uboot() (
    cd "${DOWNLOADROOTFW_UBOOT}" || \
    cd "${DEPLOYMENTROOTFW_UBOOT}" || die "Can not use DOWNLOADROOTFW_UBOOT='$DOWNLOADROOTFW_UBOOT' nor DEPLOYMENTROOTFW_UBOOT='$DEPLOYMENTROOTFW_UBOOT'"

    case "${1-}" in
            *://*)
                logmsg_info "download_rawfwimage_uboot() was asked to try downloading '$1' as the raw u-Boot loader image"
                IMAGE_URL="$1" ;;
            "")
                logmsg_info "Fetching newest remote filename for the raw u-Boot loader image..."
                IMAGE_URL="`findnewest_rawfwimage_uboot`" && [ -n "$IMAGE_URL" ] \
                && logmsg_info "download_rawfwimage_uboot() detected '$IMAGE_URL' as the newest remote raw u-Boot loader image" \
                || { logmsg_error "Could not find any remote raw u-Boot loader image"; IMAGE_URL="";} ;;
            *)  logmsg_error "download_rawfwimage_uboot() got an unsupported argument: $*"
                IMAGE_URL=""
                ;;
    esac

    [ -n "$IMAGE_URL" ] && \
    rIMAGE_URL_BASENAME="`basename "$IMAGE_URL"`" && \
        [ -n "$rIMAGE_URL_BASENAME" ] || \
        die "Can not find the remote image URL"

    # TODO: Currently hardcoded for md5 accompanying checksums only
    # TODO (later): Support presence of multiple checksum files (e.g. sha* and md5)
    # TODO: Also support checksum-verifying against the flashed partition bits
    IMAGE_CSALGO="${CHECKSUM_ALGO_DEFAULT}"

    # NOTE: "Old" filename and checksum are basenames that can be located under
    # different directories ("r"elative varnames), but e.g. a "new" checksum is
    # ensured to be in a temporary location and a newly downloaded file should
    # land into the recovery location ("a"bsolute varnames)
    IMAGE_CSURL="${IMAGE_URL}.${IMAGE_CSALGO}"
    rIMAGE_CSOLD="${rIMAGE_URL_BASENAME}.${IMAGE_CSALGO}"
    aIMAGE_CSNEW="/tmp/${rIMAGE_URL_BASENAME}.$$.${IMAGE_CSALGO}.tmp"

    IMAGE_CSURL_PADDED="${IMAGE_URL}.${IMAGE_CSALGO}-padded"
    rIMAGE_CSOLD_PADDED="${rIMAGE_URL_BASENAME}.${IMAGE_CSALGO}-padded"
    aIMAGE_CSNEW_PADDED="/tmp/${rIMAGE_URL_BASENAME}.$$.${IMAGE_CSALGO}-padded.tmp"

    trap 'TRAPCODE=$?; rm -f "${aIMAGE_CSNEW}" "${aIMAGE_CSNEW_PADDED}"; exit $TRAPCODE' 0

    logmsg_info "Downloading '${IMAGE_CSURL}' (if any) into '${aIMAGE_CSNEW}'..."
    rm -f "${aIMAGE_CSNEW}"
    wget -q -O - "${IMAGE_CSURL}" > "${aIMAGE_CSNEW}" || \
        { logmsg_error "Could not save '${IMAGE_CSURL}' into '${aIMAGE_CSNEW}'"
          rm -f "${aIMAGE_CSNEW}"
          if [ x"${CHECK_ONLY-}" = xyes ]; then
            die "Got an error while checking if there is something new to download, so no reason to proceed"
          fi
        }

    logmsg_info "Downloading '${IMAGE_CSURL_PADDED}' (if any) into '${aIMAGE_CSNEW_PADDED}'..."
    rm -f "${aIMAGE_CSNEW_PADDED}"
    wget -q -O - "${IMAGE_CSURL_PADDED}" > "${aIMAGE_CSNEW_PADDED}" || \
        { logmsg_error "Could not save '${IMAGE_CSURL_PADDED}' into '${aIMAGE_CSNEW_PADDED}'"
          rm -f "${aIMAGE_CSNEW_PADDED}"
          if [ x"${CHECK_ONLY-}" = xyes ]; then
            die "Got an error while checking if there is something new to download, so no reason to proceed"
          fi
        }

    # Try the filenames in local directories
    logmsg_info "Verifying if we have this checksum and corresponding file under original name in base dir..."
    verify_threeway_checksum "${IMAGE_URL}" "${rIMAGE_URL_BASENAME}" "${rIMAGE_CSOLD}" "${aIMAGE_CSNEW}" && return 0
    if [ -s "${aIMAGE_CSNEW_PADDED}" ] && [ -c "/dev/mtd$UBOOT_MTD" ]; then
        logmsg_info "Verify padded checksum against a raw u-Boot loader partition with flashed bits here ..."
        REPLACE_MISSING_CHECKSUM="no" FLAG_CAN_REMOVE_IMAGES="no" verify_threeway_checksum "${IMAGE_URL}" \
            "/dev/mtd$UBOOT_MTD" \
            "${DEPLOYMENTROOTFW_UBOOT}/${rIMAGE_CSOLD_PADDED}" \
            "${aIMAGE_CSNEW_PADDED}" && return 0
    fi
    logmsg_info "Verify non-padded checksum against a raw u-Boot loader partition with flashed bits here ..."
    REPLACE_MISSING_CHECKSUM="no" FLAG_CAN_REMOVE_IMAGES="no" verify_threeway_checksum "${IMAGE_URL}" \
            "/dev/mtd$UBOOT_MTD" \
            "${DEPLOYMENTROOTFW_UBOOT}/${rIMAGE_CSOLD}" \
            "${aIMAGE_CSNEW}" && return 0
    logmsg_warn "TODO: If we can detect the file size of the remote image, use calculate_stream_checksum_bytes() to verify flashed bits"

    if [ x"${CHECK_ONLY-}" = xyes ]; then
        logmsg_info "According to checksums, the remote resource '$IMAGE_URL' points to an u-Boot loader image we do not have on this system"
        return 42
    fi

    # If we are here, the IMAGE_URL is valid and points to a different content
    # than what we already have; the aTGT_FILE names the ultimate local filename
    aTGT_FILE="`pwd`/${rIMAGE_URL_BASENAME}"
    aIMAGE_CSOLD="`pwd`/${rIMAGE_CSOLD}"
    aIMAGE_CSOLD_PADDED="`pwd`/${rIMAGE_CSOLD_PADDED}"

    if [ ! -s "${aIMAGE_CSOLD}" ]; then
        [ -s "${aIMAGE_CSNEW}" ] && cp -f "${aIMAGE_CSNEW}" "${aIMAGE_CSOLD}"
    fi

    if [ ! -s "${aIMAGE_CSOLD_PADDED}" ]; then
        [ -s "${aIMAGE_CSNEW_PADDED}" ] && cp -f "${aIMAGE_CSNEW_PADDED}" "${aIMAGE_CSOLD_PADDED}"
    fi

    logmsg_info "Downloading '$IMAGE_URL' into '$aTGT_FILE'..."
    rm -f "${aTGT_FILE}"
    wget -O "${aTGT_FILE}" "$IMAGE_URL" && [ -s "$aTGT_FILE" ] || \
        { remove_image "$aTGT_FILE"; die "Could not download '$IMAGE_URL' into '$aTGT_FILE'"; }
    remove_checksum_cache '[^\:]*' '[^\:]*' "${aTGT_FILE}"

    lsdir_http_pattern "${SOURCESITEROOTFW_UBOOT}" "`basename ${IMAGE_URL}`"'*' | egrep "^${IMAGE_URL}\." | \
        egrep -v "^(${IMAGE_CSURL}|${IMAGE_CSURL_PADDED})"'$' | \
        while read U ; do
            # Note these are helper files, e.g. a padded checksum or some
            # touched-flags (may even be empty) and not fatal if missing
            aBU="`pwd`/`basename "$U"`"
            logmsg_info "Downloading additional file '$U' into '$aBU'..."
            rm -f "$aBU"
            wget -O "${aBU}" "$U" || logmsg_error "Could not download the additional '$U'"
        done

    if [ -s "${aIMAGE_CSOLD}" ] || [ -s "${aIMAGE_CSNEW}" ] || [ -s "${DEPLOYMENTROOTFW_UBOOT}/${rIMAGE_CSOLD}" ]; then
        FLAG_CAN_REMOVE_IMAGES="no" verify_threeway_checksum "${IMAGE_URL}" \
            "${aTGT_FILE}" \
            "${aIMAGE_CSOLD}" \
            "${DEPLOYMENTROOTFW_UBOOT}/${rIMAGE_CSOLD}" || \
        verify_threeway_checksum "${IMAGE_URL}" \
            "${aTGT_FILE}" \
            "${aIMAGE_CSOLD}" \
            "${aIMAGE_CSNEW}" || return $?
    else
        logmsg_warn "Generating '${aIMAGE_CSOLD}' because there was none at the source..."
        echo "`calculate_stream_checksum "${IMAGE_CSALGO}" < "$aTGT_FILE"`  `basename "$aTGT_FILE"`" > "${aIMAGE_CSOLD}" || \
        { rm -f "${aIMAGE_CSOLD}"; die "Could not generate '${aIMAGE_CSOLD}'"; }
    fi

    # TODO: Verify file size against partition size (flashability after reboot)
    [ -s "${aTGT_FILE}" ] && [ -s "${aIMAGE_CSOLD}" ] && \
    touch -r "${aTGT_FILE}" "${aIMAGE_CSOLD}" && \
    logmsg_info "Got u-Boot loader image OK:" && \
    ls -ld "${aTGT_FILE}" "${aIMAGE_CSOLD}" && \
    cat "${aIMAGE_CSOLD}" && \
    return 42
)

removeold_rawfwimage_uboot() (
    cd "${DOWNLOADROOTFW_UBOOT}" || die "Can not use DOWNLOADROOTFW_UBOOT='$DOWNLOADROOTFW_UBOOT'"
    logmsg_info "NOTE: removeold_rawfwimage_uboot() is likely a no-op at this point"
    VICTIMS=0
    for F in `ls -1d u-Boot 2>/dev/null | head -n -1` ; do
        logmsg_info "Removing older u-Boot loader image: '`pwd`/$F' and its checksum(s)"
        remove_image "$F"
        VICTIMS=$(($VICTIMS+1))
    done
    [ "$VICTIMS" -eq 0 ] && logmsg_info "removeold_rawfwimage_uboot() had nothing to remove" || \
        logmsg_info "removeold_rawfwimage_uboot() requested to remove $VICTIMS file(s)"
    return 0
)


##################################################

findnewest_rawfwimage_uimage() (
    # Echo the URL to the newest "raw" (not tarballed, only one)
    # uImage image file found on remote resource, if any
    # Note: currently expects certain filename patterns and http-dir listing markup
    IMAGE_URL="`lsdir_http_pattern "${SOURCESITEROOTFW_UIMAGE}" "uImage"`"
    if [ $? = 0 -a x"$IMAGE_URL" != x ]; then
        echo "$IMAGE_URL" && return 0
    fi
    logmsg_error "Error looking up remote file: Make sure your settings (including proxy if needed) are correct."
    return 1
)

download_rawfwimage_uimage() (
    cd "${DOWNLOADROOTFW_UIMAGE}" || \
    cd "${DEPLOYMENTROOTFW_UIMAGE}" || die "Can not use DOWNLOADROOTFW_UIMAGE='$DOWNLOADROOTFW_UIMAGE' nor DEPLOYMENTROOTFW_UIMAGE='$DEPLOYMENTROOTFW_UIMAGE'"

    case "${1-}" in
            *://*)
                logmsg_info "download_rawfwimage_uimage() was asked to try downloading '$1' as the raw kernel uImage"
                IMAGE_URL="$1" ;;
            "")
                logmsg_info "Fetching newest remote filename for the raw kernel uImage..."
                IMAGE_URL="`findnewest_rawfwimage_uimage`" && [ -n "$IMAGE_URL" ] \
                && logmsg_info "download_rawfwimage_uimage() detected '$IMAGE_URL' as the newest remote raw kernel uImage" \
                || { logmsg_error "Could not find any remote raw kernel uImage"; IMAGE_URL="";} ;;
            *)  logmsg_error "download_rawfwimage_uimage() got an unsupported argument: $*"
                IMAGE_URL=""
                ;;
    esac

    [ -n "$IMAGE_URL" ] && \
    rIMAGE_URL_BASENAME="`basename "$IMAGE_URL"`" && \
        [ -n "$rIMAGE_URL_BASENAME" ] || \
        die "Can not find the remote image URL"

    # TODO: Currently hardcoded for md5 accompanying checksums only
    # TODO (later): Support presence of multiple checksum files (e.g. sha* and md5)
    # TODO: Also support checksum-verifying against the flashed partition bits
    IMAGE_CSALGO="${CHECKSUM_ALGO_DEFAULT}"

    # NOTE: "Old" filename and checksum are basenames that can be located under
    # different directories ("r"elative varnames), but e.g. a "new" checksum is
    # ensured to be in a temporary location and a newly downloaded file should
    # land into the recovery location ("a"bsolute varnames)
    IMAGE_CSURL="${IMAGE_URL}.${IMAGE_CSALGO}"
    rIMAGE_CSOLD="${rIMAGE_URL_BASENAME}.${IMAGE_CSALGO}"
    aIMAGE_CSNEW="/tmp/${rIMAGE_URL_BASENAME}.$$.${IMAGE_CSALGO}.tmp"

    IMAGE_CSURL_PADDED="${IMAGE_URL}.${IMAGE_CSALGO}-padded"
    rIMAGE_CSOLD_PADDED="${rIMAGE_URL_BASENAME}.${IMAGE_CSALGO}-padded"
    aIMAGE_CSNEW_PADDED="/tmp/${rIMAGE_URL_BASENAME}.$$.${IMAGE_CSALGO}-padded.tmp"

    trap 'TRAPCODE=$?; rm -f "${aIMAGE_CSNEW}" "${aIMAGE_CSNEW_PADDED}"; exit $TRAPCODE' 0

    logmsg_info "Downloading '${IMAGE_CSURL}' (if any) into '${aIMAGE_CSNEW}'..."
    rm -f "${aIMAGE_CSNEW}"
    wget -q -O - "${IMAGE_CSURL}" > "${aIMAGE_CSNEW}" || \
        { logmsg_error "Could not save '${IMAGE_CSURL}' into '${aIMAGE_CSNEW}'"
          rm -f "${aIMAGE_CSNEW}"
          if [ x"${CHECK_ONLY-}" = xyes ]; then
            die "Got an error while checking if there is something new to download, so no reason to proceed"
          fi
        }

    logmsg_info "Downloading '${IMAGE_CSURL_PADDED}' (if any) into '${aIMAGE_CSNEW_PADDED}'..."
    rm -f "${aIMAGE_CSNEW_PADDED}"
    wget -q -O - "${IMAGE_CSURL_PADDED}" > "${aIMAGE_CSNEW_PADDED}" || \
        { logmsg_error "Could not save '${IMAGE_CSURL_PADDED}' into '${aIMAGE_CSNEW_PADDED}'"
          rm -f "${aIMAGE_CSNEW_PADDED}"
          if [ x"${CHECK_ONLY-}" = xyes ]; then
            die "Got an error while checking if there is something new to download, so no reason to proceed"
          fi
        }

    # Try the filenames in local directories
    logmsg_info "Verifying if we have this checksum and corresponding file under original name in base dir..."
    verify_threeway_checksum "${IMAGE_URL}" "${rIMAGE_URL_BASENAME}" "${rIMAGE_CSOLD}" "${aIMAGE_CSNEW}" && return 0
    if [ -s "${aIMAGE_CSNEW_PADDED}" ] && [ -c "/dev/mtd$KERNEL_MTD" ]; then
        logmsg_info "Verify padded checksum against a raw kernel uImage partition with flashed bits here ..."
        REPLACE_MISSING_CHECKSUM="no" FLAG_CAN_REMOVE_IMAGES="no" verify_threeway_checksum "${IMAGE_URL}" \
            "/dev/mtd$KERNEL_MTD" \
            "${DEPLOYMENTROOTFW_UIMAGE}/${rIMAGE_CSOLD_PADDED}" \
            "${aIMAGE_CSNEW_PADDED}" && return 0
    fi
    logmsg_info "Verify non-padded checksum against a raw kernel uImage partition with flashed bits here ..."
    REPLACE_MISSING_CHECKSUM="no" FLAG_CAN_REMOVE_IMAGES="no" verify_threeway_checksum "${IMAGE_URL}" \
            "/dev/mtd$KERNEL_MTD" \
            "${DEPLOYMENTROOTFW_UIMAGE}/${rIMAGE_CSOLD}" \
            "${aIMAGE_CSNEW}" && return 0
    logmsg_warn "TODO: If we can detect the file size of the remote image, use calculate_stream_checksum_bytes() to verify flashed bits"

    if [ x"${CHECK_ONLY-}" = xyes ]; then
        logmsg_info "According to checksums, the remote resource '$IMAGE_URL' points to a kernel uImage we do not have on this system"
        return 42
    fi

    # If we are here, the IMAGE_URL is valid and points to a different content
    # than what we already have; the aTGT_FILE names the ultimate local filename
    aTGT_FILE="`pwd`/${rIMAGE_URL_BASENAME}"
    aIMAGE_CSOLD="`pwd`/${rIMAGE_CSOLD}"
    aIMAGE_CSOLD_PADDED="`pwd`/${rIMAGE_CSOLD_PADDED}"

    if [ ! -s "${aIMAGE_CSOLD}" ]; then
        [ -s "${aIMAGE_CSNEW}" ] && cp -f "${aIMAGE_CSNEW}" "${aIMAGE_CSOLD}"
    fi

    if [ ! -s "${aIMAGE_CSOLD_PADDED}" ]; then
        [ -s "${aIMAGE_CSNEW_PADDED}" ] && cp -f "${aIMAGE_CSNEW_PADDED}" "${aIMAGE_CSOLD_PADDED}"
    fi

    logmsg_info "Downloading '$IMAGE_URL' into '$aTGT_FILE'..."
    rm -f "${aTGT_FILE}"
    wget -O "${aTGT_FILE}" "$IMAGE_URL" && [ -s "$aTGT_FILE" ] || \
        { remove_image "$aTGT_FILE"; die "Could not download '$IMAGE_URL' into '$aTGT_FILE'"; }
    remove_checksum_cache '[^\:]*' '[^\:]*' "${aTGT_FILE}"

    lsdir_http_pattern "${SOURCESITEROOTFW_UIMAGE}" "`basename ${IMAGE_URL}`"'*' | egrep "^${IMAGE_URL}\." | \
        egrep -v "^(${IMAGE_CSURL}|${IMAGE_CSURL_PADDED})"'$' | \
        while read U ; do
            # Note these are helper files, e.g. a padded checksum or some
            # touched-flags (may even be empty) and not fatal if missing
            aBU="`pwd`/`basename "$U"`"
            logmsg_info "Downloading additional file '$U' into '$aBU'..."
            rm -f "$aBU"
            wget -O "${aBU}" "$U" || logmsg_error "Could not download the additional '$U'"
        done

    if [ -s "${aIMAGE_CSOLD}" ] || [ -s "${aIMAGE_CSNEW}" ] || [ -s "${DEPLOYMENTROOTFW_UIMAGE}/${rIMAGE_CSOLD}" ]; then
        FLAG_CAN_REMOVE_IMAGES="no" verify_threeway_checksum "${IMAGE_URL}" \
            "${aTGT_FILE}" \
            "${aIMAGE_CSOLD}" \
            "${DEPLOYMENTROOTFW_UIMAGE}/${rIMAGE_CSOLD}" || \
        verify_threeway_checksum "${IMAGE_URL}" \
            "${aTGT_FILE}" \
            "${aIMAGE_CSOLD}" \
            "${aIMAGE_CSNEW}" || return $?
    else
        logmsg_warn "Generating '${aIMAGE_CSOLD}' because there was none at the source..."
        echo "`calculate_stream_checksum "${IMAGE_CSALGO}" < "$aTGT_FILE"`  `basename "$aTGT_FILE"`" > "${aIMAGE_CSOLD}" || \
        { rm -f "${aIMAGE_CSOLD}"; die "Could not generate '${aIMAGE_CSOLD}'"; }
    fi

    # TODO: Verify file size against partition size (flashability after reboot)
    [ -s "${aTGT_FILE}" ] && [ -s "${aIMAGE_CSOLD}" ] && \
    touch -r "${aTGT_FILE}" "${aIMAGE_CSOLD}" && \
    logmsg_info "Got kernel uImage OK:" && \
    ls -ld "${aTGT_FILE}" "${aIMAGE_CSOLD}" && \
    cat "${aIMAGE_CSOLD}" && \
    return 42
)

removeold_rawfwimage_uimage() (
    cd "${DOWNLOADROOTFW_UIMAGE}" || die "Can not use DOWNLOADROOTFW_UIMAGE='$DOWNLOADROOTFW_UIMAGE'"
    logmsg_info "NOTE: removeold_rawfwimage_uimage() is likely a no-op at this point"
    VICTIMS=0
    for F in `ls -1d uImage 2>/dev/null | head -n -1` ; do
        logmsg_info "Removing older kernel uImage: '`pwd`/$F' and its checksum(s)"
        remove_image "$F"
        VICTIMS=$(($VICTIMS+1))
    done
    [ "$VICTIMS" -eq 0 ] && logmsg_info "removeold_rawfwimage_uimage() had nothing to remove" || \
        logmsg_info "removeold_rawfwimage_uimage() requested to remove $VICTIMS file(s)"
    return 0
)

##################################################

findnewest_rawfwimage_modules() (
    # Echo the URL to the newest "raw" (not tarballed, only one)
    # uImage image file found on remote resource, if any
    # Note: currently expects certain filename patterns and http-dir listing markup
    IMAGE_URL="`lsdir_http_pattern "${SOURCESITEROOTFW_MODULES}" "*[0-9].[0-9]*.${EXT}"`"
    if [ $? = 0 -a x"$IMAGE_URL" != x ]; then
        echo "$IMAGE_URL" && return 0
    fi
    logmsg_error "Error looking up remote file: Make sure your settings (including proxy if needed) are correct."
    return 1
)

download_rawfwimage_modules() (
    cd "${DOWNLOADROOTFW_MODULES}" || \
    cd "${DEPLOYMENTROOTFW_MODULES}" || die "Can not use DOWNLOADROOTFW_MODULES='$DOWNLOADROOTFW_MODULES' nor DEPLOYMENTROOTFW_MODULES='$DEPLOYMENTROOTFW_MODULES'"

    case "${1-}" in
            *://*)
                logmsg_info "download_rawfwimage_modules() was asked to try downloading '$1' as the raw kernel modules archive"
                IMAGE_URL="$1" ;;
            "")
                logmsg_info "Fetching newest remote filename for the raw kernel modules archive..."
                IMAGE_URL="`findnewest_rawfwimage_modules`" && [ -n "$IMAGE_URL" ] \
                && logmsg_info "download_rawfwimage_modules() detected '$IMAGE_URL' as the newest remote raw kernel modules archive" \
                || { logmsg_error "Could not find any remote raw kernel modules archive"; IMAGE_URL="";} ;;
            *)  logmsg_error "download_rawfwimage_modules() got an unsupported argument: $*"
                IMAGE_URL=""
                ;;
    esac

    [ -n "$IMAGE_URL" ] && \
    rIMAGE_URL_BASENAME="`basename "$IMAGE_URL"`" && \
        [ -n "$rIMAGE_URL_BASENAME" ] || \
        die "Can not find the remote image URL"

    # TODO: Currently hardcoded for md5 accompanying checksums only
    # TODO (later): Support presence of multiple checksum files (e.g. sha* and md5)
    # TODO: Also support checksum-verifying against the flashed partition bits
    IMAGE_CSALGO="${CHECKSUM_ALGO_DEFAULT}"

    # NOTE: "Old" filename and checksum are basenames that can be located under
    # different directories ("r"elative varnames), but e.g. a "new" checksum is
    # ensured to be in a temporary location and a newly downloaded file should
    # land into the recovery location ("a"bsolute varnames)
    IMAGE_CSURL="${IMAGE_URL}.${IMAGE_CSALGO}"
    rIMAGE_CSOLD="${rIMAGE_URL_BASENAME}.${IMAGE_CSALGO}"
    aIMAGE_CSNEW="/tmp/${rIMAGE_URL_BASENAME}.$$.${IMAGE_CSALGO}.tmp"

    trap 'TRAPCODE=$?; rm -f "$aIMAGE_CSNEW"; exit $TRAPCODE' 0

    logmsg_info "Downloading '${IMAGE_CSURL}' (if any) into '${aIMAGE_CSNEW}'..."
    rm -f "${aIMAGE_CSNEW}"
    wget -q -O - "${IMAGE_CSURL}" > "${aIMAGE_CSNEW}" || \
        { logmsg_error "Could not save '${IMAGE_CSURL}' into '${aIMAGE_CSNEW}'"
          rm -f "${aIMAGE_CSNEW}"
          if [ x"${CHECK_ONLY-}" = xyes ]; then
            die "Got an error while checking if there is something new to download, so no reason to proceed"
          fi
        }

    # Try the filenames in local directories
    logmsg_info "Verifying if we have this checksum and corresponding file under original name in base dir..."
    verify_threeway_checksum "${IMAGE_URL}" "${rIMAGE_URL_BASENAME}" "${rIMAGE_CSOLD}" "${aIMAGE_CSNEW}" && return 0

    if [ -d "${DEPLOYMENTROOT_MODULES}" ] ; then
        # Do not remove deployed files!
        logmsg_info "Verifying if we have this checksum and corresponding file already deployed..."
        FLAG_CAN_REMOVE_IMAGES="no" verify_threeway_checksum "${IMAGE_URL}" \
            "${DEPLOYMENTROOT_MODULES}/${rIMAGE_URL_BASENAME}" \
            "${DEPLOYMENTROOT_MODULES}/${rIMAGE_CSOLD}" \
            "${aIMAGE_CSNEW}" \
        && return 0
    fi

    if [ x"${CHECK_ONLY-}" = xyes ]; then
        logmsg_info "According to checksums, the remote resource '$IMAGE_URL' points to a kernel modules archive we do not have on this system"
        return 42
    fi

    # If we are here, the IMAGE_URL is valid and points to a different content
    # than what we already have; the aTGT_FILE names the ultimate local filename
    aTGT_FILE="`pwd`/${rIMAGE_URL_BASENAME}"
    aIMAGE_CSOLD="`pwd`/${rIMAGE_CSOLD}"

    if [ ! -s "${aIMAGE_CSOLD}" ]; then
        [ -s "${aIMAGE_CSNEW}" ] && cp -f "${aIMAGE_CSNEW}" "${aIMAGE_CSOLD}"
    fi

    logmsg_info "Downloading '$IMAGE_URL' into '$aTGT_FILE'..."
    rm -f "${aTGT_FILE}"
    wget -O "${aTGT_FILE}" "$IMAGE_URL" && [ -s "$aTGT_FILE" ] || \
        { remove_image "$aTGT_FILE"; die "Could not download '$IMAGE_URL' into '$aTGT_FILE'"; }
    remove_checksum_cache '[^\:]*' '[^\:]*' "${aTGT_FILE}"

    lsdir_http_pattern "${SOURCESITEROOTFW_MODULES}" "`basename ${IMAGE_URL}`"'*' | egrep "^${IMAGE_URL}\." | \
        egrep -v "^${IMAGE_CSURL}"'$' | \
        while read U ; do
            # Note these are helper files, e.g. a padded checksum or some
            # touched-flags (may even be empty) and not fatal if missing
            aBU="`pwd`/`basename "$U"`"
            logmsg_info "Downloading additional file '$U' into '$aBU'..."
            rm -f "$aBU"
            wget -O "${aBU}" "$U" || logmsg_error "Could not download the additional '$U'"
        done

    if [ -s "${aIMAGE_CSOLD}" ] || [ -s "${aIMAGE_CSNEW}" ] || [ -s "${DEPLOYMENTROOTFW_MODULES}/${rIMAGE_CSOLD}" ]; then
        FLAG_CAN_REMOVE_IMAGES="no" verify_threeway_checksum "${IMAGE_URL}" \
            "${aTGT_FILE}" \
            "${aIMAGE_CSOLD}" \
            "${DEPLOYMENTROOTFW_MODULES}/${rIMAGE_CSOLD}" || \
        verify_threeway_checksum "${IMAGE_URL}" \
            "${aTGT_FILE}" \
            "${aIMAGE_CSOLD}" \
            "${aIMAGE_CSNEW}" || return $?
    else
        logmsg_warn "Generating '${aIMAGE_CSOLD}' because there was none at the source..."
        echo "`calculate_stream_checksum "${IMAGE_CSALGO}" < "$aTGT_FILE"`  `basename "$aTGT_FILE"`" > "${aIMAGE_CSOLD}" || \
        { rm -f "${aIMAGE_CSOLD}"; die "Could not generate '${aIMAGE_CSOLD}'"; }
    fi

    # TODO: Verify file size against partition size (flashability after reboot)
    [ -s "${aTGT_FILE}" ] && [ -s "${aIMAGE_CSOLD}" ] && \
    touch -r "${aTGT_FILE}" "${aIMAGE_CSOLD}" && \
    logmsg_info "Got kernel modules archive OK:" && \
    ls -ld "${aTGT_FILE}" "${aIMAGE_CSOLD}" && \
    cat "${aIMAGE_CSOLD}" && \
    return 42
)

removeold_rawfwimage_modules() (
    cd "${DOWNLOADROOTFW_MODULES}" || die "Can not use DOWNLOADROOTFW_MODULES='$DOWNLOADROOTFW_MODULES'"
    logmsg_info "NOTE: removeold_rawfwimage_modules() is likely a no-op at this point"
    VICTIMS=0
    for F in `ls -1d *[0-9]*.*[0-9]*.${EXT} 2>/dev/null | head -n -1` ; do
        logmsg_info "Removing older modules archive: '`pwd`/$F' and its checksum(s)"
        remove_image "$F"
        VICTIMS=$(($VICTIMS+1))
    done
    [ "$VICTIMS" -eq 0 ] && logmsg_info "removeold_rawfwimage_modules() had nothing to remove" || \
        logmsg_info "removeold_rawfwimage_modules() requested to remove $VICTIMS file(s)"
    return 0
)


###########################################################################
### Start of application logic
###########################################################################

logmsg_info "`date`: Starting ${_SCRIPT_PATH} ${_SCRIPT_ARGS}"

case "$*" in
    *--no-config-file*) logmsg_info "NOT sourcing configs from /etc/update-rc3.d/" ;;
    *)
        if [ -d "/etc/update-rc3.d/" ]; then
            for F in "/etc/update-rc3.d/"*.conf ; do
                if [ -s "$F" ] && [ -r "$F" ] ; then
                    logmsg_info "Sourcing configuration file: '$F' ..."
                    . "$F" || logmsg_error "Possibly got an error sourcing '$F', see above..."
                fi
            done
        fi
        ;;
esac
config_defaults

# TODO: Locking against multiple runs
# TODO: define CLI methods for status/size/... checks per BIOS-1563
# TODO: Free space verification before download - BIOS-1562?
# TODO: Expose more methods via CLI, e.g. to verify checksums of an image file
# TODO: Methods to compare if we have a candidate image newer than flashed bits
#       (and so if the user should reboot)

ACTION_DOWNLOAD_OSIMAGE="yes"
case "$ARCH" in
    *arm*)  ACTION_DOWNLOAD_FWIMAGE="yes" ;;
    *)      ACTION_DOWNLOAD_FWIMAGE="no" ;;
esac

ACTION_CHECK_OSIMAGE="no"
ACTION_CHECK_FWIMAGE="no"

# The routines can force a specific URL rather than detecting the "newest" one
[ -z "${URL_DOWNLOAD_OSIMAGE-}" ] &&                URL_DOWNLOAD_OSIMAGE=""
[ -z "${URL_DOWNLOAD_FWIMAGE_RAW_UBOOT-}" ] &&      URL_DOWNLOAD_FWIMAGE_RAW_UBOOT=""
[ -z "${URL_DOWNLOAD_FWIMAGE_RAW_UIMAGE-}" ] &&     URL_DOWNLOAD_FWIMAGE_RAW_UIMAGE=""
[ -z "${URL_DOWNLOAD_FWIMAGE_RAW_MODULES-}" ] &&    URL_DOWNLOAD_FWIMAGE_RAW_MODULES=""

ACTION_REMOVEOLD_OSIMAGE="yes"
# This is currently no-op because we only track "raw" FW images which have one
# data file per fwimage sub-type, unpacked on remote server
# TODO: Support creation, download and installation of timestamped FW tarballs
ACTION_REMOVEOLD_FWIMAGE="no"

# Ultimate exit code of the script
ACTION_RESULT=0

# Exclude this (base) filename from removeold_osimage() hit-list
DOWNLOADED_OS_IMAGE=""

while [ $# -gt 0 ]; do
        case "${1-}" in
                -h|--help|-help)        usage; exit 0 ;;
                --debug-calls|--debug-calls-x)
                    if [ $# -eq 1 ]; then
                        die "The '$1' option requires further arguments"
                    fi
                    [ "$1" = "--debug-calls" ] && shift || { shift; set -xv; }
                    "$@" ; exit $? ;;
                -c|--config) [ -n "$2" ] && [ -s "$2" ] && [ -r "$2" ] && \
                        logmsg_info "Sourcing configuration file: '$2' ..." && \
                        . "$2" || die "Possibly got an error sourcing '$2', see above..."
                    shift ;;
                --no-config-file) ;; # Processed above
		-ls)
			RES=0
			lsdir_http_pattern "${SOURCESITEROOTFW_UBOOT}" "uBoot*" \
				| egrep -v '\.(md5'"$CHECKSUM_ALGO_DEFAULT:+|$CHECKSUM_ALGO_DEFAULT"')$' || RES=$?
			lsdir_http_pattern "${SOURCESITEROOTFW_UBOOT}" "u-Boot*" \
				| egrep -v '\.(md5'"$CHECKSUM_ALGO_DEFAULT:+|$CHECKSUM_ALGO_DEFAULT"')$' || RES=$?
			lsdir_http_pattern "${SOURCESITEROOTFW_UIMAGE}" "uImage*" \
				| egrep -v '\.(md5'"$CHECKSUM_ALGO_DEFAULT:+|$CHECKSUM_ALGO_DEFAULT"')$' || RES=$?
			lsdir_http_pattern "${SOURCESITEROOTFW_MODULES}" "*[0-9].[0-9]*.${EXT}*" \
				| egrep -v '\.(md5'"$CHECKSUM_ALGO_DEFAULT:+|$CHECKSUM_ALGO_DEFAULT"')$' || RES=$?
			lsdir_http_pattern "${SOURCESITEROOT_OSIMAGE}" "${SOURCESITEROOT_OSIMAGE_FILENAMEPATTERN}.${EXT}*" \
				| sort_osimage_names \
				| egrep -v '\.(md5'"$CHECKSUM_ALGO_DEFAULT:+|$CHECKSUM_ALGO_DEFAULT"')$' || RES=$?

			summarize_check() {
				IMG="$1"
				shift
				OUT="`CHECK_ONLY=yes "$@" 2>&1`"
				sRES=$?
				case "$sRES" in
					0) echo "$IMG: Local is up-to-date" ;;
					42) echo "$IMG: Newest remote is different";;
					*) echo "$IMG: Some error ($sRES):"; echo "$OUT";;
				esac
				return $sRES
			}

			summarize_check "OSIMAGE" download_osimage $URL_DOWNLOAD_OSIMAGE &
			PID1=$!
			summarize_check "KERNEL-UIMAGE"  download_rawfwimage_uimage  $URL_DOWNLOAD_FWIMAGE_RAW_UIMAGE &
			PID2=$!
			summarize_check "KERNEL-MODULES" download_rawfwimage_modules $URL_DOWNLOAD_FWIMAGE_RAW_MODULES &
			PID3=$!
			summarize_check "LOADER-UBOOT"   download_rawfwimage_uboot   $URL_DOWNLOAD_FWIMAGE_RAW_UBOOT &
			PID4=$!
			for P in $PID1 $PID2 $PID3 $PID4 ; do wait $P || RES=$? ; done
			wait || RES=$?
			exit $RES
			;;
                --remove-files)         FLAG_CAN_REMOVE_IMAGES="yes";;
                --no-remove-files)      FLAG_CAN_REMOVE_IMAGES="no";;
                --flatten-filenames)    FLAG_FLATTEN_FILENAMES="yes";;
                --no-flatten-filenames) FLAG_FLATTEN_FILENAMES="no";;
                --download-image-os)    ACTION_DOWNLOAD_OSIMAGE="yes";;
                --download-image-fw)    ACTION_DOWNLOAD_FWIMAGE="yes";;
                --download-images)      ACTION_DOWNLOAD_OSIMAGE="yes"; ACTION_DOWNLOAD_FWIMAGE="yes";;
                --no-download-image-os) ACTION_DOWNLOAD_OSIMAGE="no";;
                --no-download-image-fw) ACTION_DOWNLOAD_FWIMAGE="no";;
                --no-download-images)   ACTION_DOWNLOAD_OSIMAGE="no"; ACTION_DOWNLOAD_FWIMAGE="no";;
                --fw-only)              ACTION_DOWNLOAD_OSIMAGE="no"; ACTION_DOWNLOAD_FWIMAGE="yes";;
                --os-only)              ACTION_DOWNLOAD_OSIMAGE="yes"; ACTION_DOWNLOAD_FWIMAGE="no";;
                --check-image-os)       ACTION_CHECK_OSIMAGE="yes";;
                --check-image-fw)       ACTION_CHECK_FWIMAGE="yes";;
                --check-images|-n|--dry-run)
                                        ACTION_CHECK_OSIMAGE="yes"; ACTION_CHECK_FWIMAGE="yes";;
                --no-check-image-os)    ACTION_CHECK_OSIMAGE="no";;
                --no-check-image-fw)    ACTION_CHECK_FWIMAGE="no";;
                --no-check-images)      ACTION_CHECK_OSIMAGE="no"; ACTION_CHECK_FWIMAGE="no";;
                --url-image-*)
                    [ $# -eq 1 ] && die "The '$1' option requires a further argument"
                    case "${1-}" in
                        --url-image-os)             URL_DOWNLOAD_OSIMAGE="$2"; shift;;
                        --url-image-fw-raw-uboot)   URL_DOWNLOAD_FWIMAGE_RAW_UBOOT="$2"; shift;;
                        --url-image-fw-raw-uimage)  URL_DOWNLOAD_FWIMAGE_RAW_UIMAGE="$2"; shift;;
                        --url-image-fw-raw-modules) URL_DOWNLOAD_FWIMAGE_RAW_MODULES="$2"; shift;;
                        *)  die "Aborting due to unknown command-line argument(s): $*" ;;
                    esac ;;
                --removeold-image-os)   ACTION_REMOVEOLD_OSIMAGE="yes";;
                --removeold-image-fw)   ACTION_REMOVEOLD_FWIMAGE="yes";;
                --removeold-images)     ACTION_REMOVEOLD_OSIMAGE="yes"; ACTION_REMOVEOLD_FWIMAGE="yes";;
                --no-removeold-image-os)ACTION_REMOVEOLD_OSIMAGE="no";;
                --no-removeold-image-fw)ACTION_REMOVEOLD_FWIMAGE="no";;
                --no-removeold-images)  ACTION_REMOVEOLD_OSIMAGE="no"; ACTION_REMOVEOLD_FWIMAGE="no";;
                --erase-factory-reset)
                                        FLAG_ERASE_FACTORYRESET="yes" ;;
                --touch-factory-reset|--force-factory-reset)
                                        FLAG_ERASE_FACTORYRESET="force" ;;
                --no-erase-factory-reset)  FLAG_ERASE_FACTORYRESET="no" ;;
                --erase-all)            FLAG_ERASE_ALL="yes" ;;
                --touch-erase-all|--force-erase-all)
                                        FLAG_ERASE_ALL="force" ;;
                --no-erase-all)         FLAG_ERASE_ALL="no" ;;
                *)  die "Aborting due to unknown command-line argument(s): $*" ;;
        esac
        shift
done

# Checks are special - after we do all which were requested (if any), we exit
if [ x"$ACTION_CHECK_OSIMAGE" = xyes ] || [ x"$ACTION_CHECK_FWIMAGE" = xyes ]; then
    RESULT_ACTION_CHECK_ANYIMAGE=0
    if [ x"$ACTION_CHECK_OSIMAGE" = xyes ]; then
        CHECK_ONLY=yes download_osimage $URL_DOWNLOAD_OSIMAGE || RESULT_ACTION_CHECK_ANYIMAGE=$?
    fi
    if [ x"$ACTION_CHECK_FWIMAGE" = xyes ]; then
        CHECK_ONLY=yes download_rawfwimage_uboot   $URL_DOWNLOAD_FWIMAGE_RAW_UBOOT   || RESULT_ACTION_CHECK_ANYIMAGE=$?
        CHECK_ONLY=yes download_rawfwimage_uimage  $URL_DOWNLOAD_FWIMAGE_RAW_UIMAGE  || RESULT_ACTION_CHECK_ANYIMAGE=$?
        CHECK_ONLY=yes download_rawfwimage_modules $URL_DOWNLOAD_FWIMAGE_RAW_MODULES || RESULT_ACTION_CHECK_ANYIMAGE=$?
    fi
    RES_STR="$RESULT_ACTION_CHECK_ANYIMAGE"
    case "$RESULT_ACTION_CHECK_ANYIMAGE" in
        0)  RES_STR="$RESULT_ACTION_CHECK_ANYIMAGE = Local files are OK, but there is nothing new to download" ;;
        42) RES_STR="$RESULT_ACTION_CHECK_ANYIMAGE = Should download something different from what we have locally" ;;
    esac
    logmsg_info "Exiting after completion of requested --check-* operations ($RES_STR)"
    exit $RESULT_ACTION_CHECK_ANYIMAGE
fi

RESULT_ACTION_DOWNLOAD_FWIMAGE=0
RESULT_ACTION_DOWNLOAD_FWIMAGE_RAW_UBOOT=0
RESULT_ACTION_DOWNLOAD_FWIMAGE_RAW_UIMAGE=0
RESULT_ACTION_DOWNLOAD_FWIMAGE_RAW_MODULES=0
if [ "$ACTION_DOWNLOAD_FWIMAGE" = yes ]; then
        download_rawfwimage_uboot $URL_DOWNLOAD_FWIMAGE_RAW_UBOOT
        RESULT_ACTION_DOWNLOAD_FWIMAGE_RAW_UBOOT=$?
        download_rawfwimage_uimage $URL_DOWNLOAD_FWIMAGE_RAW_UIMAGE
        RESULT_ACTION_DOWNLOAD_FWIMAGE_RAW_UIMAGE=$?
        download_rawfwimage_modules $URL_DOWNLOAD_FWIMAGE_RAW_MODULES
        RESULT_ACTION_DOWNLOAD_FWIMAGE_RAW_MODULES=$?

        [ "$RESULT_ACTION_DOWNLOAD_FWIMAGE_RAW_UBOOT" -gt 0 ] && \
            ACTION_RESULT=$RESULT_ACTION_DOWNLOAD_FWIMAGE_RAW_UBOOT && \
            if [ "$ACTION_REMOVEOLD_FWIMAGE" = yes ] ; then
                logmsg_warn "New u-Boot image was not downloaded successfully, so old ones are not purged"
                ACTION_REMOVEOLD_FWIMAGE=no_BadDownload
            fi

        [ "$RESULT_ACTION_DOWNLOAD_FWIMAGE_RAW_UIMAGE" -gt 0 ] && \
            ACTION_RESULT=$RESULT_ACTION_DOWNLOAD_FWIMAGE_RAW_UIMAGE && \
            if [ "$ACTION_REMOVEOLD_FWIMAGE" = yes ] ; then
                logmsg_warn "New kernel uImage was not downloaded successfully, so old ones are not purged"
                ACTION_REMOVEOLD_FWIMAGE=no_BadDownload
            fi

        [ "$RESULT_ACTION_DOWNLOAD_FWIMAGE_RAW_MODULES" -gt 0 ] && \
            ACTION_RESULT=$RESULT_ACTION_DOWNLOAD_FWIMAGE_RAW_MODULES && \
            if [ "$ACTION_REMOVEOLD_FWIMAGE" = yes ] ; then
                logmsg_warn "New modules archive was not downloaded successfully, so old ones are not purged"
                ACTION_REMOVEOLD_FWIMAGE=no_BadDownload
            fi
fi

if [ "$ACTION_REMOVEOLD_FWIMAGE" = yes ]; then
        removeold_rawfwimage_modules || ACTION_RESULT=$?
        removeold_rawfwimage_uimage || ACTION_RESULT=$?
        removeold_rawfwimage_uboot || ACTION_RESULT=$?
else
        logmsg_info "Not purging old FW images because ACTION_REMOVEOLD_FWIMAGE=$ACTION_REMOVEOLD_FWIMAGE"
fi

RESULT_ACTION_DOWNLOAD_OSIMAGE=0
if [ "$ACTION_DOWNLOAD_OSIMAGE" = yes ]; then
        rm -f "$DOWNLOADROOT_OSIMAGE/.newest-osimage"
        download_osimage $URL_DOWNLOAD_OSIMAGE
        RESULT_ACTION_DOWNLOAD_OSIMAGE=$?

        # If there was indeed a successful download, we have code=42 from the
        # routine; however the script succeeded - so overall exitcode stays 0
        if [ "$RESULT_ACTION_DOWNLOAD_OSIMAGE" -gt 0 -a "$RESULT_ACTION_DOWNLOAD_OSIMAGE" -ne 42 ] ; then
            ACTION_RESULT=$RESULT_ACTION_DOWNLOAD_OSIMAGE && \
            if [ "$ACTION_REMOVEOLD_OSIMAGE" = yes ] ; then
                logmsg_warn "New OS image was not downloaded successfully, so old ones are not purged"
                ACTION_REMOVEOLD_OSIMAGE=no_BadDownload
            fi
        else
            [ -s "$DOWNLOADROOT_OSIMAGE/.newest-osimage" ] && \
                DOWNLOADED_OS_IMAGE="`cat "$DOWNLOADROOT_OSIMAGE/.newest-osimage"`" || \
                DOWNLOADED_OS_IMAGE=""
        fi
fi

case "$FLAG_ERASE_FACTORYRESET" in
	yes)
		if [ "$ACTION_DOWNLOAD_OSIMAGE" = no ] || \
		   [ "$ACTION_DOWNLOAD_OSIMAGE" = yes -a "$RESULT_ACTION_DOWNLOAD_OSIMAGE" -eq 42 ] || \
		   [ "$ACTION_DOWNLOAD_OSIMAGE" = yes -a "$RESULT_ACTION_DOWNLOAD_OSIMAGE" -eq 0 ] \
		; then
			logmsg_info "New OS image was downloaded successfully, so requesting factory-reset during reboot"
			touch "$DOWNLOADROOT/factory_reset"
		else
			logmsg_warn "New OS image was not downloaded successfully, so not requesting factory-reset"
		fi
		;;
	force)
		logmsg_info "Explicitly requesting factory-reset during next reboot, regardless of whether OS image changed or not"
		touch "$DOWNLOADROOT/factory_reset"
		;;
	no)
		rm -f "$DEPLOYMENTROOT/factory_reset" "$DOWNLOADROOT/factory_reset"
		;;
esac

case "$FLAG_ERASE_ALL" in
	yes)
		if [ "$ACTION_DOWNLOAD_OSIMAGE" = no ] || \
		   [ "$ACTION_DOWNLOAD_OSIMAGE" = yes -a "$RESULT_ACTION_DOWNLOAD_OSIMAGE" -eq 42 ] || \
		   [ "$ACTION_DOWNLOAD_OSIMAGE" = yes -a "$RESULT_ACTION_DOWNLOAD_OSIMAGE" -eq 0 ] \
		; then
			logmsg_info "New OS image was downloaded successfully, so requesting erase-all during reboot"
			touch "$DOWNLOADROOT/erase_all"
		else
			logmsg_warn "New OS image was not downloaded successfully, so not requesting erase-all"
		fi
		;;
	force)
		logmsg_info "Explicitly requesting erase-all during next reboot, regardless of whether OS image changed or not"
		touch "$DOWNLOADROOT/erase_all"
		;;
	no)
		rm -f "$DEPLOYMENTROOT/erase_all" "$DOWNLOADROOT/erase_all"
		;;
esac

if [ "$ACTION_REMOVEOLD_OSIMAGE" = yes ]; then
	removeold_osimage || ACTION_RESULT=$?
else
	logmsg_info "Not purging old OS images because ACTION_REMOVEOLD_OSIMAGE=$ACTION_REMOVEOLD_OSIMAGE"
fi

echo ""
echo "===================================================================="
echo ""

if [ -n "$DOWNLOADED_OS_IMAGE" ] && [ -s "$DOWNLOADED_OS_IMAGE" ]; then
	logmsg_info "NOTE: Downloaded an OS image during this run:" \
		"'$DOWNLOADED_OS_IMAGE'" \
		"`ls -lad "$DOWNLOADED_OS_IMAGE"`"
fi

if [ -f "$DEPLOYMENTROOT/factory_reset" ] || [ -f "$DOWNLOADROOT/factory_reset" ]; then
	logmsg_warn "NOTE: a FACTORY RESET was requested and will be done during reboot"
fi

if [ -f "$DEPLOYMENTROOT/erase_all" ] || [ -f "$DOWNLOADROOT/erase_all" ]; then
	logmsg_warn "NOTE: a FACTORY RESET + NAND FORMAT was requested and will be done during reboot"
fi

logmsg_info "Syncing to ensure all writes are done..."
time sync || true

logmsg_info "Completed '$_SCRIPT_NAME $_SCRIPT_ARGS' with result $ACTION_RESULT"
exit $ACTION_RESULT
