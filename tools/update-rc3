#!/bin/bash
#
# Copyright (C) 2015 Eaton
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
#! \file    systemctl
#  \brief   Helper script to manage download of new images initiated from RC3
#  \author  Jim Klimov <EvgenyKlimov@Eaton.com>
#  \author  Michal Hrusecky <MichalHrusecky@Eaton.com>
#  \author  Tomas Halman <TomasHalman@Eaton.com>
#

# Important bashism
set -o pipefail

config_defaults() {
    # This routine sets variables required for the script to work
    # They can be set earlier by configuration files or caller's env

    # Default values matching Eaton internal (at the moment) resources
    # The actual RC3 should be reconfigured to refer some customer-local mirror
    # or an external Eaton resource, done by snippets in /etc/update-rc3.d/*.conf
    [ -z "${IMGTYPE-}" ] && IMGTYPE="deploy"
    [ -z "${ARCH-}" ] && ARCH="`uname -m`"
    # The RC3 base OS ensures support for squashfs and overlay(fs)
    [ -z "${EXT-}" ] && EXT="squashfs"
    [ -z "${CHECKSUM_ALGO_DEFAULT-}" ] && CHECKSUM_ALGO_DEFAULT="md5"

    # This script is intended as the downloader tool for both CI/dev-workstation
    # hosts and the ultimate devices. Most of the logic is the same, but there are
    # a few differences. File and directory naming is one of them :
    # Our CI farm deployments mimic the build farm paths - with IMGTYPE/ARCH/filename.ext
    # The RC3 units expect a flat directory structure rootfs/filename.ext so the
    # details (especially IMGTYPE) should end up in the flat filename - ...__${ARCH}__${IMGTYPE}.${EXT}.
    # (rc3/virthost) If set to "no", use original filenames from the source server
    # Overridable by CLI option "--(no-)flatten-filenames"
    [ -z "${FLAG_FLATTEN_FILENAMES-}" ] && FLAG_FLATTEN_FILENAMES="yes"

    ### Values below can be changed by command-line choices, and some defaults
    ### may be overridden by config files before CLI choices
    # (dev) If set to "no", then do not remove files even if deemed broken or old
    # Overridable by CLI option "--(no-)remove-files" which is somewhat different
    # from "--(no-)removeold-images" that only impacts old-image removal after a
    # successful download of new image(s)
    [ -z "${FLAG_CAN_REMOVE_IMAGES-}" ] && FLAG_CAN_REMOVE_IMAGES="yes"

    # TODO: TFTP support, busybox can do it
    # TODO: Test with https - can require custom CA trust configuration, etc.
    # TODO: Use our common requester as a wrapper for real/busybox wget/curl
    # TODO: Make a common routine to list remote directories (e.g. http-dir parsing, ftp, tftp, localfs...)
    [ -z "${SOURCESITEROOT-}" ] && SOURCESITEROOT='http://obs.roz53.lab.etn.com/images'
    [ -z "${SOURCESITEROOT_OSIMAGE-}" ] && SOURCESITEROOT_OSIMAGE="$SOURCESITEROOT/$IMGTYPE/$ARCH"

    [ -z "${SOURCESITEROOTFW-}" ] && SOURCESITEROOTFW="http://obs.roz53.lab.etn.com/flash-rc3/recovery"
    [ -z "${SOURCESITEROOTFW_UBOOT-}" ] && SOURCESITEROOTFW_UBOOT="$SOURCESITEROOTFW"
    [ -z "${SOURCESITEROOTFW_UIMAGE-}" ] && SOURCESITEROOTFW_UIMAGE="$SOURCESITEROOTFW"
    [ -z "${SOURCESITEROOTFW_MODULES-}" ] && SOURCESITEROOTFW_MODULES="$SOURCESITEROOTFW/modules"

    # Recovery location (on MMC or mSATA) - for downloads
    [ -z "${DOWNLOADROOT-}" ] && DOWNLOADROOT="/mnt/mmc/recovery"
    [ -z "${DOWNLOADROOT_OSIMAGE-}" ] && DOWNLOADROOT_OSIMAGE="$DOWNLOADROOT/rootfs"
    [ -z "${DOWNLOADROOTFW_UBOOT-}" ] && DOWNLOADROOTFW_UBOOT="$DOWNLOADROOT"
    [ -z "${DOWNLOADROOTFW_UIMAGE-}" ] && DOWNLOADROOTFW_UIMAGE="$DOWNLOADROOT"
    [ -z "${DOWNLOADROOTFW_MODULES-}" ] && DOWNLOADROOTFW_MODULES="$DOWNLOADROOTFW_UIMAGE/modules"

    # Deployment location (on SPI flash in production) - for boot-mounted OS image
    [ -z "${DEPLOYMENTROOT-}" ] && DEPLOYMENTROOT="/mnt/nand"
    [ -z "${DEPLOYMENTROOT_OSIMAGE-}" ] && DEPLOYMENTROOT_OSIMAGE="$DEPLOYMENTROOT/rootfs"
    [ -z "${DEPLOYMENTROOTFW_UBOOT-}" ] && DEPLOYMENTROOTFW_UBOOT="$DEPLOYMENTROOT"
    [ -z "${DEPLOYMENTROOTFW_UIMAGE-}" ] && DEPLOYMENTROOTFW_UIMAGE="$DEPLOYMENTROOT"
    [ -z "${DEPLOYMENTROOTFW_MODULES-}" ] && DEPLOYMENTROOTFW_MODULES="$DEPLOYMENTROOTFW_UIMAGE/modules"

    [ -z "${http_proxy-}" -o x"${http_proxy-}" = x- ] && http_proxy=""
    [ -z "${https_proxy-}" -o x"${https_proxy-}" = x- ] && https_proxy=""
    [ -z "${ftp_proxy-}" -o x"${ftp_proxy-}" = x- ] && ftp_proxy=""
    [ -z "${ftps_proxy-}" -o x"${ftps_proxy-}" = x- ] && ftps_proxy=""
    export http_proxy https_proxy ftp_proxy ftps_proxy

    # The RC3 SPI flash partitioning determines these sizes, value hardcoded in the
    # default installation routines as well as the init/upgrade script in uImage.
    # These numbers are used for "padded" checksum calculations.
    UIMAGE_MAX_SIZE_RC3=3145728
    UBOOT_MAX_SIZE_RC3=1048576
    [ -z "${UIMAGE_MAX_SIZE-}" ] && UIMAGE_MAX_SIZE="$UIMAGE_MAX_SIZE_RC3"
    [ -z "${UBOOT_MAX_SIZE-}" ] && UBOOT_MAX_SIZE="$UBOOT_MAX_SIZE_RC3"

    PATH="/sbin:/usr/sbin:/usr/local/sbin:/bin:/usr/bin:/usr/local/bin:$PATH"
    export PATH
}

### NOTE: This script can be copied to VM hosts and used standalone, so we do
### not depend it on scriptlib.sh or anything else. Implement a few bits here.

### This is prefixed before ERROR, WARN, INFO tags in the logged messages
LOGMSG_PREFIX="BIOS-UPDATE-RC3-"

### Store some important CLI values
[ -z "$_SCRIPT_PATH" ] && _SCRIPT_PATH="$0"
[ -z "$_SCRIPT_NAME" ] && _SCRIPT_NAME="`basename "${_SCRIPT_PATH}"`"
_SCRIPT_ARGS="$*"
_SCRIPT_ARGC="$#"

usage() {
    echo "Usage: ${_SCRIPT_NAME} [options...]"
    echo "Options:"
    echo "  --help | -help | -h       Display this hep and exit"
    echo "  --config | -c             Source an additional config file (beside looking in"
    echo "                            standard locations e.g. '/etc/update-rc3.d/*.conf')"
    echo "  --(no-)check-image-os, --(no-)check-image-fw, --(no-)check-images"
    echo "                   Only check the source location if new images are available"
    echo "                   and exit, whatever the outcome (returns 0 if nothing found,"
    echo "                   42 if there is something to download)"
    echo "  --(no-)download-image-os  Enable or disable downloading of OS images"
    echo "  --(no-)download-image-fw  Likewise for downloading of uBoot, uImage+modules"
    echo "  --(no-)download-images    Enable or disable downloading of all image types"
    echo "  --(no-)removeold-image-os, --(no-)removeold-image-fw, --(no-)removeold-images"
    echo "                   If download-image of this type was requested and successful,"
    echo "                   or if download was not requested at all, remove all but the"
    echo "                   newest (alphabetcally) image file from the recovery location"
    echo "  --(no-)remove-files       Skip removing image files deemed corrupt or obsolete"
    echo "  --(no-)flatten-filenames  Skip renaming image files to include ARCH and TYPE"
    echo "                            for easier differentiation in the flat storage dirs"
    echo "For the check* and download* methods, you can specify a full URL to the image"
    echo "file which you want rather than trying to detect the newest one available, with"
    echo "the following arguments ('raw' firmwares are the non-tarballed singular files):"
    echo "  --url-image-os {URL} (expected checksum patterns should still exist nearby)"
    echo "  --url-image-fw-raw-uboot --url-image-fw-raw-uimage --url-image-fw-raw-modules"
# TODO ...
}

SCRIPTDIR=$(realpath "`dirname ${_SCRIPT_PATH}`") || \
    SCRIPTDIR=$(cd "`dirname ${_SCRIPT_PATH}`" && pwd)
SCRIPTPWD="`pwd`"
if [ -z "$CHECKOUTDIR" ] ; then
    CHECKOUTDIR=$(realpath "$SCRIPTDIR/../..") || \
        CHECKOUTDIR=$(cd "$SCRIPTDIR/../.." && pwd)
fi
[ "$CHECKOUTDIR" = / -o ! -d "$CHECKOUTDIR/tests/CI" ] && CHECKOUTDIR=""
[ -z "$BUILDSUBDIR" ] && BUILDSUBDIR="$CHECKOUTDIR"
export CHECKOUTDIR BUILDSUBDIR

[ -z "$LANG" ] && LANG=C
[ -z "$LANGUAGE" ] && LANGUAGE=C
[ -z "$LC_ALL" ] && LC_ALL=C
[ -z "$TZ" ] && TZ=UTC
export LANG LANGUAGE LC_ALL TZ

logmsg_info() {
    echo "${LOGMSG_PREFIX}INFO:" "$@"
}

logmsg_warn() {
    echo "${LOGMSG_PREFIX}WARN:" "$@" >&2
}

logmsg_error() {
    echo "${LOGMSG_PREFIX}ERROR:" "$@" >&2
}

die() {
    CODE="${CODE-1}"
    [ "$CODE" -ge 0 ] 2>/dev/null || CODE=1
    for LINE in "$@" ; do
        echo "${LOGMSG_PREFIX}FATAL:" "$LINE" >&2
    done
    exit $CODE
}

settraps() {
    # Not all trap names are recognized by all shells consistently
    # Note: slight difference from scriptlib.sh, we trap ERR too by default
    [ -z "${TRAP_SIGNALS-}" ] && TRAP_SIGNALS="ERR  EXIT QUIT TERM HUP INT"
    for P in "" SIG; do for S in $TRAP_SIGNALS ; do
        case "$1" in
        -|"") trap "$1" $P$S 2>/dev/null || true ;;
        *)    trap 'ERRCODE=$?; ('"$*"'); exit $ERRCODE;' $P$S 2>/dev/null || true ;;
        esac
    done; done
}

##############################################################################
remove_image() {
    # Remove the image file "$1" and its possible checksum patterns,
    # and the optional explicit checksum filename that can be in "$2"
    # If the RETAIN_FILE variable is set, keep this file (downloaded new CS)
    [ x"${FLAG_CAN_REMOVE_IMAGES-}" = xno ] && \
        logmsg_info "FLAG_CAN_REMOVE_IMAGES=$FLAG_CAN_REMOVE_IMAGES so do not remove_image($*)" && \
        return 0
    [ -n "$RETAIN_FILE" ] && [ -s "$RETAIN_FILE" ] && \
        logmsg_info "Retaining '$RETAIN_FILE' during remove_image($*)" && \
        mv -f "$RETAIN_FILE" "$RETAIN_FILE.$$"
    rm -f "$1"{,.md5,.sha,.sha1,.sha224,.sha256,.sha384,.sha512}{,-padded}{,.tmp} ${2:+"$2"}
    [ -n "$RETAIN_FILE" ] && [ -s "$RETAIN_FILE.$$" ] && mv -f "$RETAIN_FILE.$$" "$RETAIN_FILE"
}

get_csalgo_from_filename() {
    # Parse (extensions of) the filename in "$1" to retrieve the
    # checksum algo (if any); set of supported algos and extensions
    # is to be kept in sync with remove_image() above.
    _A="`echo "$1" | tr '[A-Z]' '[a-z]' | sed -e 's,\.tmp$,,' -e 's,^.*\.\([^\.]*\)$,\1,' -e 's,-padded$,,'`" || _A=""

    case "${_A}" in
        md5|sha|sha1|sha224|sha256|sha384|sha512)
            echo "${_A}"
            unset _A
            return 0 ;;
        "") logmsg_error "Could not extract checksum algorithm from filename '$1'"
            unset _A
            return 31 ;;
        *)  logmsg_error "Unrecognized checksum algorithm: '${_A}'"
            unset _A
            return 32 ;;
    esac
}

calculate_stream_checksum() {
    # Calculate and print to stdout checksum of the stdin stream using algo "$1"
    # Use the function above to validate known algorithm names
    # We expect to have either ${ALGO}sum program or openssl support for ${ALGO}
    if [ -z "${1-}" ]; then
        ALGO="${CHECKSUM_ALGO_DEFAULT}"
    else
        ALGO="`get_csalgo_from_filename "$1"`" || return $?
    fi

    if [ -x "`which openssl`" ] 2>/dev/null ; then
        openssl dgst -"${ALGO}" | awk '{print $NF}'
        return $?
    fi

    ${ALGO}sum | awk '{print $1}'
    return $?
}

expected_checksum() (
    # Extracts precalculated checksum of file "$1" recorded in file "$2"
    CHECKSUM_EXP="$(grep -i "`basename "$1"`" < "$2" | awk '{print $1}')" 2>/dev/null
    if [ $? != 0 -o -z "$CHECKSUM_EXP" ] && [ "`wc -l < "$2"`" -eq 1 ] ; then
        # Maybe the whole file content is one line with the value
        CHECKSUM_EXP="`awk '{print $1}' < "$2"`"
    fi
    [ -n "$CHECKSUM_EXP" ] && echo "$CHECKSUM_EXP"
    # If the value is empty, this statement returns an error exit-code
)

verify_checksum() {
    # Compares actual checksum of file "$1" with value recorded in file "$2"
    # with optional algorithm in "$3" (defaults to CHECKSUM_ALGO_DEFAULT='md5')
    # TODO: add generalized support for .${CHECKSUM_ALGO_DEFAULT}-padded checksum files (firmware imgs)
    # TODO (later): Support file sizes as part of checksum info
    FILENAME_DATA="$1"
    FILENAME_CSUM="${2-}"
    [ -z "$FILENAME_CSUM" ] && \
        FILENAME_CSUM="$FILENAME_DATA.${CHECKSUM_ALGO_DEFAULT}"
    if [ -z "${3-}" ]; then
        CHECKSUM_ALGO="`get_csalgo_from_filename "$FILENAME_CSUM"`"
        [ $? = 0 -a -n "$CHECKSUM_ALGO" ] || \
            CHECKSUM_ALGO="${CHECKSUM_ALGO_DEFAULT}"
    else
        CHECKSUM_ALGO="$3"
    fi
    LOGINTRO="Checksum validation of '$FILENAME_DATA' against value in '$FILENAME_CSUM' ($CHECKSUM_ALGO)"

    if [ -n "$FILENAME_DATA" ] && [ -n "$FILENAME_CSUM" ] && \
       [ -s "$FILENAME_DATA" -a -s "$FILENAME_CSUM" ] \
    ; then
        logmsg_info "Beginning $LOGINTRO..."

        CHECKSUM_EXP="`expected_checksum "$FILENAME_DATA" "$FILENAME_CSUM"`"
        if [ $? != 0 -o -z "$CHECKSUM_EXP" ]; then
            logmsg_warn "$LOGINTRO SKIPPED (can not detect expected value)"
            return 0
        fi

        CHECKSUM_ACT="`calculate_stream_checksum < "$FILENAME_DATA"`" || CHECKSUM_ACT=""
        if [ -z "$CHECKSUM_ACT" ]; then
            logmsg_warn "$LOGINTRO SKIPPED (can not calculate actual value)"
            return 0
        fi

        if [ x"$CHECKSUM_ACT" = x"$CHECKSUM_EXP" ]; then
            logmsg_info "$LOGINTRO SUCCEEDED!"
            return 0
        fi

        logmsg_error "$LOGINTRO FAILED (mismatch)!"
        echo "ACTUAL: $CHECKSUM_ACT" >&2
        echo "EXPECT: $CHECKSUM_EXP" >&2
        return 1
    fi
    logmsg_warn "$LOGINTRO SKIPPED (one of the files is missing)"
    return 0
}

ensure_checksum() {
    # A destructive wrapper of verify_checksum(), destroys bad downloads
    if ! verify_checksum "$@" ; then
        logmsg_warn "Removing broken file: '$1' and its checksum(s)"
        remove_image "$@" || return $?
        return 1
    fi
    return 0
}

verify_threeway_checksum() (
    # We can have (or not) a local copy of the data file "$2", a local copy
    # of the checksum file "$3", and a freshly fetched copy of remote checksum
    # file "$4" (usually an *.algo.tmp); all previously downloaded by caller
    # from URL in "$1".
    # Return codes:
    #   0       OK, local data and checksum files are (now) consistent, keep'em
    #   1       ERROR, local files inconsistent (removed), re-pull from remote!
    #   2       ERROR, some prerequisites missing, etc.
    # Verify if any of these files match together (in a destructive manner):
    # * If some of the files are not available:
    # ** data file - fail (must download all bits)
    # ** both checksums - fail (legacy mode allowed no checksums, now not so)
    # ** local checksum - fall through (only compare to remote checksum then)
    # ** remote checksum - fall through (only compare to local checksum then)
    # * If two checksums are the same (both in algo and value), remove the
    #   newly downloaded one and fall through for verifications
    # * If the remote checksum file exists (thus different from local) and
    #   a checksum value is detected from it:
    # ** If the remote checksum value does match the file - assume it to be
    #    authoritative and local one possibly broken (overwrite checksum file)
    # ** If the remote checksum does not match, assume the source file updated
    #    in-place on the remote source - kill local data and return error
    #    (caller would pull remote files)
    # * If the local CS+DATA do NOT match together, kill them and return error
    # * If neither checksum matches - kill local data and return error

    # The IMAGE_URL_BASENAME_EXT (on remote site with hierarchical structure)
    # may be different from local FILE_DATA name (with flattened structure).
    IMAGE_URL="$1"
    # Basenames of data and checksum files (under current dir set by caller
    # or absolute - e.g. for recovery vs. deployed storage locations).
    # Theoretically checksums may be from different algorithms (see extension).
    FILE_DATA="$2"
    FILE_CSOLD="$3"
    FILE_CSNEW="$4"

    FILE_DIR="`pwd`"
    case "$FILE_DATA" in
        /*) FILE_DIR="`dirname "$FILE_DATA"`";;
        ./*|../*) FILE_DIR="`pwd`/`dirname "$FILE_DATA"`"; FILE_DATA="$FILE_DIR/`basename "$FILE_DATA"`";;
        *) FILE_DATA="$FILE_DIR/$FILE_DATA" ;;
    esac
    case "$FILE_CSOLD" in
        /*) ;;
        ./*|../*) FILE_CSOLD="`pwd`/$FILE_CSOLD";;
        *) FILE_CSOLD="$FILE_DIR/$FILE_CSOLD" ;;
    esac
    case "$FILE_CSNEW" in
        /*) ;;
        ./*|../*) FILE_CSNEW="`pwd`/$FILE_CSNEW";;
        *) FILE_CSNEW="$FILE_DIR/$FILE_CSNEW" ;;
    esac

    [ -n "$IMAGE_URL" ] && \
    IMAGE_URL_BASENAME="`basename "$IMAGE_URL" ".${EXT}"`" && \
    [ -n "$IMAGE_URL_BASENAME" ] && \
    IMAGE_URL_BASENAME_EXT="${IMAGE_URL_BASENAME}${EXT:+.$EXT}" || \
        { logmsg_warn "Could not resolve IMAGE_URL value '$IMAGE_URL' into a filename"
          IMAGE_URL=""; IMAGE_URL_BASENAME=""; IMAGE_URL_BASENAME_EXT=""; }

    if [ ! -s "$FILE_DATA" ] ; then
        logmsg_info "Local data file '$FILE_DATA' is missing"
        return 2
    fi

    if [ ! -s "$FILE_CSOLD" ] && [ ! -s "$FILE_CSNEW" ] ; then
        logmsg_info "Both checksum files '$FILE_CSOLD' and '$FILE_CSNEW' are missing"
        return 2
    fi

    # If checksum files are available, try to get checksum values using the
    # current (local) or maybe original (remote from IMAGE_URL) filename.
    [ -s "$FILE_CSOLD" ] && \
        CSOLDALGO="`get_csalgo_from_filename "$FILE_CSOLD"`" && \
        { CSOLD="`expected_checksum "$FILE_DATA" "$FILE_CSOLD"`" || \
          CSOLD="`[ -z "$IMAGE_URL_BASENAME_EXT" ] && [ x"$FILE_DATA" != x"$IMAGE_URL_BASENAME_EXT" ] && expected_checksum "$IMAGE_URL_BASENAME_EXT" "$FILE_CSOLD"`" ; } || \
        { CSOLD=""; CSOLDALGO=""; logmsg_info "Local checksum file '$FILE_CSOLD' is missing"; }

    [ -s "$FILE_CSNEW" ] && \
        CSNEWALGO="`get_csalgo_from_filename "$FILE_CSNEW"`" && \
        { CSNEW="`expected_checksum "$FILE_DATA" "$FILE_CSNEW"`" || \
          CSNEW="`[ -z "$IMAGE_URL_BASENAME_EXT" ] && [ x"$FILE_DATA" != x"$IMAGE_URL_BASENAME_EXT" ] && expected_checksum "$IMAGE_URL_BASENAME_EXT" "$FILE_CSNEW"`" ; } || \
        { CSNEW=""; CSNEWALGO=""; logmsg_info "Remote checksum file '$FILE_CSNEW' is missing"; }

    if [ -z "$CSNEW" ] && [ -z "$CSOLD" ]; then
        logmsg_info "Could not get usable checksum values from both checksum files: '$FILE_CSOLD' and '$FILE_CSNEW'"
        return 2
    fi

    # Now that we have a validated request, do the actual suite of comparisons.
    if [ -n "$CSNEWALGO" ] && [ -n "$CSNEW" ] && \
       [ -n "$CSOLDALGO" ] && [ -n "$CSOLD" ] \
    ; then
        if [ x"$CSNEWALGO" = x"$CSOLDALGO" ]; then
            if [ x"$CSNEW" = x"$CSOLD" ]; then
                logmsg_info "Old and new checksum values are the same; keeping old checksum file and discarding new one"
                rm -f "$FILE_CSNEW"
                CSNEW=""
                CSNEWALGO=""
            else
                logmsg_warn "Old and new checksum values differ with same algo ($CSOLDALGO): '$CSOLD' vs '$CSNEW'"
            fi
        else
            logmsg_warn "Old and new checksum files have different algorithms: '$CSOLDALGO' vs '$CSNEWALGO' (so values are not comparable directly)"
        fi
    fi

    [ -n "$CSNEW" ] && \
    if verify_checksum "$FILE_DATA" "$FILE_CSNEW" ; then
        logmsg_info "Remote checksum is good for '$FILE_CSNEW', local copy was corrupted or missing - replacing checksum file"
        mv -f "$FILE_CSNEW" "$FILE_CSOLD" && \
            logmsg_info "The newest available image is '$IMAGE_URL' and we already have a good copy (as '$FILE_DATA')"
        return $?
    else
        # In-place changes are not nice but can happen e.g. for FW images
        logmsg_info "Remote checksum is not good for '$FILE_CSNEW', local file is corrupted or obsolete and should be re-downloaded from '$IMAGE_URL'"
        RETAIN_FILE="$FILE_CSNEW" remove_image "$FILE_DATA"
        return 1
    fi

    # Here we do not have a new checksum value for whatever reason
    [ -n "$CSOLD" ] && \
    if verify_checksum "$FILE_DATA" "$FILE_CSOLD" ; then
        logmsg_info "Local checksum matched for '$FILE_CSOLD'"
        return 0
    else
        # Verifying against old checksum failed, so data file and its related
        # files (checksums) should be removed; keep the FILE_CSNEW if available
        logmsg_info "Local checksum mismatched for '$FILE_CSOLD', local file is corrupted and should be re-downloaded from '$IMAGE_URL'"
        RETAIN_FILE="$FILE_CSNEW" remove_image "$FILE_DATA"
        return 1
    fi

    logmsg_info "Neither path of three-way verification has succeeded for '$FILE_DATA', it should be re-downloaded from '$IMAGE_URL'"
    RETAIN_FILE="$FILE_CSNEW" remove_image "$FILE_DATA"
    return 1
)

##################################################

lshost_http() (
    # List the remote resource "$1" which is an apache-style http directory
    # (HTML) and return links that are relative or under the same virtserver
    REMOTE_DIR="`echo "$1" | sed 's,/$,,g'`"
    REMOTE_ROOTURL="`echo "$REMOTE_DIR" | sed 's,^\(.*://[^/]*\)/.*$,\1,'`"
    # Hostname from the URL, without schema and port
    REMOTE_VIRTHOST="`echo "$REMOTE_DIR" | sed 's,^.*://\([^/:]*\)[/:].*$,\1,'`"
    wget -q -O - "$REMOTE_DIR"/ | \
        sed -n 's|.*href="\([^\"]*\)".*|\1|pg' | \
    while read URL ; do
        case "$URL" in
            "[Hh][Tt]|[Tt][Pp]?([Ss])://${REMOTE_VIRTHOST}[:/]"*)
                # URL is under this virthost
                echo "$URL" ;;
            "[Hh][Tt][Tt][Pp]?([Ss])://"*)
                # URL is under some other virthost
                ;;
            *://*)
                # URL is under some unknown schema (e.g. FTP)
                ;;
            /*)  # Assume relative URL under server root
                echo "${REMOTE_ROOTURL}/${URL}" ;;
            *)  # Assume relative URL under current dir
                echo "${REMOTE_DIR}/${URL}" ;;
        esac
    done | sed 's,\([^:]\)//,\1/,g'
)

lsdir_http() (
    # List the remote resource "$1/" which is an apache-style http directory
    # and selects URLs starting with this "$1/"
    REMOTE_DIR="`echo "$1" | sed 's,/$,,g'`"
    lshost_http "$REMOTE_DIR" | egrep -i "^$REMOTE_DIR/"
)

lsdir_http_pattern() {
    # List the remote directory resource "$1/" and select sub-files by glob $2
    # See "Pathname Expansion" in `man bash` for syntax details
    REMOTE_DIR="`echo "$1" | sed 's,/$,,g'`"
    REMOTE_GLOB="$2"
    lsdir_http "$REMOTE_DIR" | while read URL; do case "$URL" in
        $REMOTE_DIR/$REMOTE_GLOB) echo "$URL" ;;
    esac; done
}


##################################################

findnewest_osimage() (
    # Echo the URL to the newest OS image file found on remote resource, if any
    # Note: currently expects certain filename patterns and http-dir listing markup
    IMAGE_URL="`lsdir_http_pattern "${SOURCESITEROOT_OSIMAGE}" "simpleimage*.${EXT}"`"
    if [ $? = 0 -a x"$IMAGE_URL" != x ]; then
        [ x"`basename "$IMAGE_URL" .${EXT}`" != x ] && \
        echo "$IMAGE_URL" && return 0
    fi
    return 1
)

download_osimage() (
    # If the caller sets CHECK_ONLY=yes and no copy of the remote image is
    # found on this local system, then the routine just returns code "42"
    # instead of downloading this detected new image otherwise.
    # A successful download of an image (consistent non-empty file) is 42 too
    cd "${DOWNLOADROOT_OSIMAGE}" || die "Can not use DOWNLOADROOT_OSIMAGE='$DOWNLOADROOT_OSIMAGE'"

    case "${1-}" in
            *://*)
                logmsg_info "download_osimage() was asked to try downloading '$1' as the ${IMGTYPE} OS image for ${ARCH}"
                IMAGE_URL="$1" ;;
            "")
                logmsg_info "Fetching newest filename for ${ARCH} OS image of type ${IMGTYPE}..."
                IMAGE_URL="`findnewest_osimage`" && [ -n "$IMAGE_URL" ] \
                && logmsg_info "download_osimage() detected '$IMAGE_URL' as the newest ${IMGTYPE} OS image for ${ARCH}" \
                || { logmsg_error "Could not find any remote OS image"; IMAGE_URL="";} ;;
            *)  logmsg_error "download_osimage() got an unsupported argument: $*"
                IMAGE_URL=""
                ;; # This dies a bit below
    esac

    case "$IMAGE_URL" in
            *"${IMGTYPE}"*) ;;
            "") ;; # This dies a bit below
            *)  logmsg_warn "The IMAGE_URL='$IMAGE_URL' does not contain IMGTYPE='$IMGTYPE'!" ; sleep 5 ;;
    esac

    case "$IMAGE_URL" in
            *"${ARCH}"*) ;;
            "") ;; # This dies a bit below
            *)  logmsg_warn "The IMAGE_URL='$IMAGE_URL' does not contain ARCH='$ARCH'!" ; sleep 5 ;;
    esac

    [ -n "$IMAGE_URL" ] && \
    rIMAGE_URL_BASENAME="`basename "$IMAGE_URL" ".${EXT}"`" && \
        [ -n "$rIMAGE_URL_BASENAME" ] && \
        rIMAGE_URL_BASENAME_EXT="${rIMAGE_URL_BASENAME}${EXT:+.$EXT}" || \
        die "Can not find the remote image URL"

    # TODO: Currently hardcoded for md5 accompanying checksums only
    # TODO (later): Support presence of multiple checksum files (e.g. sha* and md5)
    IMAGE_CSALGO="${CHECKSUM_ALGO_DEFAULT}"

    # NOTE: "Old" filename and checksum are basenames that can be located under
    # different directories ("r"elative varnames), but e.g. a "new" checksum is
    # ensured to be in a temporary location and a newly downloaded file should
    # land into the recovery location ("a"bsolute varnames)
    IMAGE_CSURL="${IMAGE_URL}.${IMAGE_CSALGO}"
    rIMAGE_CSOLD="${rIMAGE_URL_BASENAME_EXT}.${IMAGE_CSALGO}"
    aIMAGE_CSNEW="/tmp/${rIMAGE_URL_BASENAME_EXT}.$$.${IMAGE_CSALGO}.tmp"

    # We rename the incoming image to include the type in flat directory space
    rTGT_FILE="${rIMAGE_URL_BASENAME_EXT}"
    case "${rIMAGE_URL_BASENAME}" in
        *__${ARCH}__${IMGTYPE}) # Already good and flat
            ;;
        *)  if [ x"$FLAG_FLATTEN_FILENAMES" = xyes ]; then
                rTGT_FILE="${rIMAGE_URL_BASENAME}__${ARCH}__${IMGTYPE}${EXT:+.$EXT}" && \
                [ -n "$rTGT_FILE" ] || \
                die "Can not produce the relative TGT_FILE value to save into"
            fi
            ;;  # Had to define TGT_FILE different from rIMAGE_URL_BASENAME
    esac

    rTGT_FILE_CSOLD="${rTGT_FILE}.${IMAGE_CSALGO}"
    aTGT_FILE_CSNEW="/tmp/${rTGT_FILE}.$$.${IMAGE_CSALGO}.tmp"

    trap 'TRAPCODE=$?; rm -f "$aTGT_FILE_CSNEW" "$aIMAGE_CSNEW"; exit $TRAPCODE' 0

    logmsg_info "Downloading '${IMAGE_CSURL}' (if any) into '${aIMAGE_CSNEW}'..."
    rm -f "${aIMAGE_CSNEW}"
    wget -q -O - "${IMAGE_CSURL}" > "${aIMAGE_CSNEW}" || \
        { logmsg_error "Could not save '${IMAGE_CSURL}' into '${aIMAGE_CSNEW}'"
          rm -f "${aIMAGE_CSNEW}"
          if [ x"${CHECK_ONLY-}" = xyes ]; then
            die "Got an error while checking if there is something new to download, so no reason to proceed"
          fi
        }

    if [ ! -s "${aTGT_FILE_CSNEW}" ] ; then
        logmsg_info "Processing '${IMAGE_CSURL}' (if any) to flatten the names into '${aTGT_FILE_CSNEW}'..."
        { [ -s "${aIMAGE_CSNEW}" ] && cat "${aIMAGE_CSNEW}" || wget -q -O - "${IMAGE_CSURL}"; } | \
        sed 's,  .*$,  '"`basename "$rTGT_FILE"`", > "${aTGT_FILE_CSNEW}" || \
            { logmsg_error "Could not save and process '${IMAGE_CSURL}' into '${aTGT_FILE_CSNEW}'"
              rm -f "${aTGT_FILE_CSNEW}"
            }
    fi

    # First try the modified filenames in local directories: more probable hit
    if [ x"$rTGT_FILE" != x"$rIMAGE_URL_BASENAME_EXT" ] ; then
        if [ -s "$aTGT_FILE_CSNEW" ] && [ x"$aTGT_FILE_CSNEW" != x"${aIMAGE_CSNEW}" ]; then
            logmsg_info "Verifying if we have this checksum and corresponding file under flat name of data and checksum files..."
            verify_threeway_checksum "${IMAGE_URL}" "${rTGT_FILE}" "${rTGT_FILE_CSOLD}" "${aTGT_FILE_CSNEW}" && return 0
            if [ -d "${DEPLOYMENTROOT_OSIMAGE}" ] ; then
                # Do not remove deployed files!
                FLAG_CAN_REMOVE_IMAGES="no" verify_threeway_checksum "${IMAGE_URL}" \
                    "${DEPLOYMENTROOT_OSIMAGE}/${rTGT_FILE}" \
                    "${DEPLOYMENTROOT_OSIMAGE}/${rTGT_FILE_CSOLD}" \
                    "${aTGT_FILE_CSNEW}" && return 0
            fi
        fi
        logmsg_info "Verifying if we have this checksum and corresponding file under flat name of data and original name of checksum file..."
        verify_threeway_checksum "${IMAGE_URL}" "${rTGT_FILE}" "${rTGT_FILE_CSOLD}" "${aIMAGE_CSNEW}" && return 0
        if [ -d "${DEPLOYMENTROOT_OSIMAGE}" ] ; then
            # Do not remove deployed files!
            FLAG_CAN_REMOVE_IMAGES="no" verify_threeway_checksum "${IMAGE_URL}" \
                "${DEPLOYMENTROOT_OSIMAGE}/${rTGT_FILE}" \
                "${DEPLOYMENTROOT_OSIMAGE}/${rTGT_FILE_CSOLD}" \
                "${aIMAGE_CSNEW}" && return 0
        fi
    fi

    # Then try unmodified filenames in local directories (e.g. USB download)
    logmsg_info "Verifying if we have this checksum and corresponding file under original name in base dir..."
    verify_threeway_checksum "${IMAGE_URL}" "${rIMAGE_URL_BASENAME_EXT}" "${rIMAGE_CSOLD}" "${aIMAGE_CSNEW}" && return 0
    if [ -d "${DEPLOYMENTROOT_OSIMAGE}" ] ; then
        # Do not remove deployed files!
        FLAG_CAN_REMOVE_IMAGES="no" verify_threeway_checksum "${IMAGE_URL}" \
            "${DEPLOYMENTROOT_OSIMAGE}/${rIMAGE_URL_BASENAME_EXT}" \
            "${DEPLOYMENTROOT_OSIMAGE}/${rIMAGE_CSOLD}" \
            "${aIMAGE_CSNEW}" && return 0
    fi
    if [ -d "./$IMGTYPE/$ARCH" ]; then
        # Bit of support for container hosts
        logmsg_info "Verifying if we have this checksum and corresponding file under original name in hierarchy..."
        verify_threeway_checksum "${IMAGE_URL}" "./$IMGTYPE/$ARCH/${rIMAGE_URL_BASENAME_EXT}" "./$IMGTYPE/$ARCH/${rIMAGE_CSOLD}" "${aIMAGE_CSNEW}" && return 0
    fi

    if [ x"${CHECK_ONLY-}" = xyes ]; then
        logmsg_info "According to checksums, the remote resource '$IMAGE_URL' points to an OS image we do not have on this system"
        return 42
    fi

    # If we are here, the IMAGE_URL is valid and points to a different content
    # than what we already have; the TGT_FILE names the ultimate local filename
    if [ -d "./$IMGTYPE/$ARCH" ]; then
        aTGT_FILE="`pwd`/$IMGTYPE/$ARCH/${rTGT_FILE}"
        aTGT_FILE_CSOLD="`pwd`/$IMGTYPE/$ARCH/${rTGT_FILE_CSOLD}"
    else
        aTGT_FILE="`pwd`/${rTGT_FILE}"
        aTGT_FILE_CSOLD="`pwd`/${rTGT_FILE_CSOLD}"
    fi

    if [ x"$aTGT_FILE_CSNEW" != x"${aIMAGE_CSNEW}" ] && [ -s "$aIMAGE_CSNEW" ] && [ -s "$aTGT_FILE_CSNEW" ] ; then
        # We have both a flat and original checksum files; keep one
        if [ x"$FLAG_FLATTEN_FILENAMES" = xyes ]; then
            rm -f "$aIMAGE_CSNEW"
        else
            rm -f "$aTGT_FILE_CSNEW"
        fi
    fi

    if [ ! -s "${aTGT_FILE_CSOLD}" ]; then
        [ -s "${aIMAGE_CSNEW}" ] && mv -f "${aIMAGE_CSNEW}" "${aTGT_FILE_CSOLD}"
        [ -s "${aTGT_FILE_CSNEW}" ] && mv -f "${aTGT_FILE_CSNEW}" "${aTGT_FILE_CSOLD}"
    fi

    logmsg_info "Downloading '$IMAGE_URL' into '$aTGT_FILE'..."
    rm -f "${aTGT_FILE}"
    wget -O "${aTGT_FILE}" "$IMAGE_URL" && [ -s "$aTGT_FILE" ] || \
        { remove_image "$aTGT_FILE"; die "Could not download '$IMAGE_URL' into '$aTGT_FILE'"; }

    if [ -s "${aTGT_FILE_CSOLD}" ]; then
        ensure_checksum "${aTGT_FILE}" "${aTGT_FILE_CSOLD}" || return $?
    else
        logmsg_warn "Generating '${aTGT_FILE_CSOLD}' because there was none at the source..."
        echo "`calculate_stream_checksum "${IMAGE_CSALGO}" < "$aTGT_FILE"`  `basename "$aTGT_FILE"`" > "${aTGT_FILE_CSOLD}" || \
        { rm -f "${aTGT_FILE_CSOLD}"; die "Could not generate '${aTGT_FILE_CSOLD}'"; }
    fi

    [ -s "${aTGT_FILE}" ] && [ -s "${aTGT_FILE_CSOLD}" ] && \
    touch -r "${aTGT_FILE}" "${aTGT_FILE_CSOLD}" && \
    logmsg_info "Got OS image OK:" && \
    ls -ld "${aTGT_FILE}" "${aTGT_FILE_CSOLD}" && \
    cat "${aTGT_FILE_CSOLD}" && \
    return 42
)

removeold_osimage() (
    cd "${DOWNLOADROOT_OSIMAGE}" || die "Can not use DOWNLOADROOT_OSIMAGE='$DOWNLOADROOT_OSIMAGE'"
    # Sort of implementation for BIOS-1566 snatched from bios-boot::Makefile
    # This removes all but the newest (alphabetically) files for the pattern
    # TODO: add support for hierarchical namespace (container hosts) with
    #       flattened or original filenames inside
    VICTIMS=0
    if [ x"$FLAG_FLATTEN_FILENAMES" = xyes ] ; then
        for F in `ls -1d *__${ARCH}__${IMGTYPE}.${EXT} 2>/dev/null | head -n -1` ; do
            logmsg_info "Removing older OS image: '`pwd`/$F' and its checksum(s)"
            remove_image "$F"
            VICTIMS=$(($VICTIMS+1))
        done
    else
        [ -d "./$IMGTYPE/$ARCH" ] && cd "./$IMGTYPE/$ARCH"
        for F in `ls -1d *.${EXT} 2>/dev/null | grep -v _ | head -n -1` ; do
            logmsg_info "Removing older OS image: '`pwd`/$F' and its checksum(s)"
            remove_image "$F"
            VICTIMS=$(($VICTIMS+1))
        done
    fi
    [ "$VICTIMS" -eq 0 ] && logmsg_info "removeold_osimage() had nothing to remove" || \
        logmsg_info "removeold_osimage() requested to remove $VICTIMS file(s)"
    return 0
)

##################################################

findnewest_rawfwimage_uboot() (
    # Echo the URL to the newest "raw" (not tarballed, only one)
    # uBoot image file found on remote resource, if any
    # Note: currently expects certain filename patterns and http-dir listing markup
    for P in 'u-Boot' 'uBoot' ; do
        IMAGE_URL="`lsdir_http_pattern "${SOURCESITEROOTFW_UBOOT}" "$P"`"
        if [ $? = 0 -a x"$IMAGE_URL" != x ]; then
            echo "$IMAGE_URL" && return 0
        fi
    done
    return 1
)

download_rawfwimage_uboot() (
    cd "${DOWNLOADROOTFW_UBOOT}" || die "Can not use DOWNLOADROOTFW_UBOOT='$DOWNLOADROOTFW_UBOOT'"
    logmsg_error "download_rawfwimage_uboot() : NOT IMPLEMENTED YET"
    return 0

    case "${1-}" in
            *://*)
                logmsg_info "download_rawfwimage_uboot() was asked to try downloading '$1' as the raw u-Boot loader image"
                IMAGE_URL="$1" ;;
            "")
                logmsg_info "Fetching newest filename for the raw u-Boot loader image..."
                IMAGE_URL="`findnewest_rawfwimage_uboot`" && [ -n "$IMAGE_URL" ] \
                && logmsg_info "download_rawfwimage_uboot() detected '$IMAGE_URL' as the newest raw u-Boot loader image" \
                || { logmsg_error "Could not find any remote raw u-Boot loader image"; IMAGE_URL="";} ;;
            *)  logmsg_error "download_rawfwimage_uboot() got an unsupported argument: $*"
                IMAGE_URL=""
                ;;
    esac

    [ -n "$IMAGE_URL" ] && \
    rIMAGE_URL_BASENAME="`basename "$IMAGE_URL"`" && \
        [ -n "$rIMAGE_URL_BASENAME" ] && \
        die "Can not find the remote image URL"

    # TODO: Currently hardcoded for md5 accompanying checksums only
    # TODO (later): Support presence of multiple checksum files (e.g. sha* and md5)
    # TODO: Also support checksum-verifying against the flashed partition bits
    IMAGE_CSALGO="${CHECKSUM_ALGO_DEFAULT}"

    # NOTE: "Old" filename and checksum are basenames that can be located under
    # different directories ("r"elative varnames), but e.g. a "new" checksum is
    # ensured to be in a temporary location and a newly downloaded file should
    # land into the recovery location ("a"bsolute varnames)
    IMAGE_CSURL="${IMAGE_URL}.${IMAGE_CSALGO}"
    rIMAGE_CSOLD="${rIMAGE_URL_BASENAME}.${IMAGE_CSALGO}"
    aIMAGE_CSNEW="/tmp/${rIMAGE_URL_BASENAME}.$$.${IMAGE_CSALGO}.tmp"

    trap 'TRAPCODE=$?; rm -f "$aIMAGE_CSNEW"; exit $TRAPCODE' 0

    logmsg_info "Downloading '${IMAGE_CSURL}' (if any) into '${aIMAGE_CSNEW}'..."
    rm -f "${aIMAGE_CSNEW}"
    wget -q -O - "${IMAGE_CSURL}" > "${aIMAGE_CSNEW}" || \
        { logmsg_error "Could not save '${IMAGE_CSURL}' into '${aIMAGE_CSNEW}'"
          rm -f "${aIMAGE_CSNEW}"
          if [ x"${CHECK_ONLY-}" = xyes ]; then
            die "Got an error while checking if there is something new to download, so no reason to proceed"
          fi
        }

    # Try the filenames in local directories
    logmsg_info "Verifying if we have this checksum and corresponding file under original name in base dir..."
    verify_threeway_checksum "${IMAGE_URL}" "${rIMAGE_URL_BASENAME}" "${rIMAGE_CSOLD}" "${aIMAGE_CSNEW}" && return 0
    if [ -d "${DEPLOYMENTROOT_OSIMAGE}" ] ; then
        # Do not remove deployed files!
        FLAG_CAN_REMOVE_IMAGES="no" verify_threeway_checksum "${IMAGE_URL}" \
            "${DEPLOYMENTROOT_OSIMAGE}/${rIMAGE_URL_BASENAME}" \
            "${DEPLOYMENTROOT_OSIMAGE}/${rIMAGE_CSOLD}" \
            "${aIMAGE_CSNEW}" && return 0
    fi
    # TODO: Verify partition flashed bits here ...

    if [ x"${CHECK_ONLY-}" = xyes ]; then
        logmsg_info "According to checksums, the remote resource '$IMAGE_URL' points to an OS image we do not have on this system"
        return 42
    fi

    # If we are here, the IMAGE_URL is valid and points to a different content
    # than what we already have; the aTGT_FILE names the ultimate local filename
    aTGT_FILE="`pwd`/${rIMAGE_URL_BASENAME}"
    aIMAGE_CSOLD="`pwd`/${rIMAGE_CSOLD}"

    if [ x"$aIMAGE_CSNEW" != x"${aIMAGE_CSNEW}" ] && [ -s "$aIMAGE_CSNEW" ] && [ -s "$aIMAGE_CSNEW" ] ; then
        # We have both a flat and original checksum files; keep one
        if [ x"$FLAG_FLATTEN_FILENAMES" = xyes ]; then
            rm -f "$aIMAGE_CSNEW"
        else
            rm -f "$aIMAGE_CSNEW"
        fi
    fi

    if [ ! -s "${aIMAGE_CSOLD}" ]; then
        [ -s "${aIMAGE_CSNEW}" ] && mv -f "${aIMAGE_CSNEW}" "${aIMAGE_CSOLD}"
        [ -s "${aIMAGE_CSNEW}" ] && mv -f "${aIMAGE_CSNEW}" "${aIMAGE_CSOLD}"
    fi

    logmsg_info "Downloading '$IMAGE_URL' into '$aTGT_FILE'..."
    rm -f "${aTGT_FILE}"
    wget -O "${aTGT_FILE}" "$IMAGE_URL" && [ -s "$aTGT_FILE" ] || \
        { remove_image "$aTGT_FILE"; die "Could not download '$IMAGE_URL' into '$aTGT_FILE'"; }

    if [ -s "${aIMAGE_CSOLD}" ]; then
        ensure_checksum "${aTGT_FILE}" "${aIMAGE_CSOLD}" || return $?
    else
        logmsg_warn "Generating '${aIMAGE_CSOLD}' because there was none at the source..."
        echo "`calculate_stream_checksum "${IMAGE_CSALGO}" < "$aTGT_FILE"`  `basename "$aTGT_FILE"`" > "${aIMAGE_CSOLD}" || \
        { rm -f "${aIMAGE_CSOLD}"; die "Could not generate '${aIMAGE_CSOLD}'"; }
    fi

    [ -s "${aTGT_FILE}" ] && [ -s "${aIMAGE_CSOLD}" ] && \
    touch -r "${aTGT_FILE}" "${aIMAGE_CSOLD}" && \
    logmsg_info "Got OS image OK:" && \
    ls -ld "${aTGT_FILE}" "${aIMAGE_CSOLD}" && \
    cat "${aIMAGE_CSOLD}" && \
    return 42

)

removeold_rawfwimage_uboot() (
    cd "${DOWNLOADROOTFW_UBOOT}" || die "Can not use DOWNLOADROOTFW_UBOOT='$DOWNLOADROOTFW_UBOOT'"
    logmsg_info "NOTE: removeold_rawfwimage_uboot() is likely a no-op at this point"
    VICTIMS=0
    for F in `ls -1d u-Boot 2>/dev/null | head -n -1` ; do
        logmsg_info "Removing older u-Boot loader image: '`pwd`/$F' and its checksum(s)"
        remove_image "$F"
        VICTIMS=$(($VICTIMS+1))
    done
    [ "$VICTIMS" -eq 0 ] && logmsg_info "removeold_rawfwimage_uboot() had nothing to remove" || \
        logmsg_info "removeold_rawfwimage_uboot() requested to remove $VICTIMS file(s)"
    return 0
)


##################################################

findnewest_rawfwimage_uimage() (
    # Echo the URL to the newest "raw" (not tarballed, only one)
    # uImage image file found on remote resource, if any
    # Note: currently expects certain filename patterns and http-dir listing markup
    IMAGE_URL="`lsdir_http_pattern "${SOURCESITEROOTFW_UIMAGE}" "uImage"`"
    if [ $? = 0 -a x"$IMAGE_URL" != x ]; then
        echo "$IMAGE_URL" && return 0
    fi
    return 1
)

download_rawfwimage_uimage() (
    cd "${DOWNLOADROOTFW_UIMAGE}" || die "Can not use DOWNLOADROOTFW_UIMAGE='$DOWNLOADROOTFW_UIMAGE'"
    logmsg_error "download_rawfwimage_uimage() : NOT IMPLEMENTED YET"
)

removeold_rawfwimage_uimage() (
    cd "${DOWNLOADROOTFW_UIMAGE}" || die "Can not use DOWNLOADROOTFW_UIMAGE='$DOWNLOADROOTFW_UIMAGE'"
    logmsg_info "NOTE: removeold_rawfwimage_uimage() is likely a no-op at this point"
    VICTIMS=0
    for F in `ls -1d uImage 2>/dev/null | head -n -1` ; do
        logmsg_info "Removing older kernel uImage: '`pwd`/$F' and its checksum(s)"
        remove_image "$F"
        VICTIMS=$(($VICTIMS+1))
    done
    [ "$VICTIMS" -eq 0 ] && logmsg_info "removeold_rawfwimage_uimage() had nothing to remove" || \
        logmsg_info "removeold_rawfwimage_uimage() requested to remove $VICTIMS file(s)"
    return 0
)

##################################################

findnewest_rawfwimage_modules() (
    # Echo the URL to the newest "raw" (not tarballed, only one)
    # uImage image file found on remote resource, if any
    # Note: currently expects certain filename patterns and http-dir listing markup
    IMAGE_URL="`lsdir_http_pattern "${SOURCESITEROOTFW_MODULES}" "*[0-9].[0-9]*.${EXT}"`"
    if [ $? = 0 -a x"$IMAGE_URL" != x ]; then
        echo "$IMAGE_URL" && return 0
    fi
    return 1
)

download_rawfwimage_modules() (
    cd "${DOWNLOADROOTFW_MODULES}" || die "Can not use DOWNLOADROOTFW_MODULES='$DOWNLOADROOTFW_MODULES'"
    logmsg_error "download_rawfwimage_modules() : NOT IMPLEMENTED YET"
)

removeold_rawfwimage_modules() (
    cd "${DOWNLOADROOTFW_MODULES}" || die "Can not use DOWNLOADROOTFW_MODULES='$DOWNLOADROOTFW_MODULES'"
    logmsg_info "NOTE: removeold_rawfwimage_modules() is likely a no-op at this point"
    VICTIMS=0
    for F in `ls -1d *[0-9]*.*[0-9]*.${EXT} 2>/dev/null | head -n -1` ; do
        logmsg_info "Removing older modules archive: '`pwd`/$F' and its checksum(s)"
        remove_image "$F"
        VICTIMS=$(($VICTIMS+1))
    done
    [ "$VICTIMS" -eq 0 ] && logmsg_info "removeold_rawfwimage_modules() had nothing to remove" || \
        logmsg_info "removeold_rawfwimage_modules() requested to remove $VICTIMS file(s)"
    return 0
)


###########################################################################
### Start of application logic
###########################################################################

logmsg_info "`date`: Starting ${_SCRIPT_PATH} ${_SCRIPT_ARGS}"

if [ -d "/etc/update-rc3.d/" ]; then
    for F in "/etc/update-rc3.d/"*.conf ; do
        if [ -s "$F" ] && [ -r "$F" ] ; then
            logmsg_info "Sourcing configuration file: '$F' ..."
            . "$F" || logmsg_error "Possibly got an error sourcing '$F', see above..."
        fi
    done
fi
config_defaults

# TODO: Locking against multiple runs
# TODO: define CLI methods for status/size/... checks per BIOS-1563
# TODO: Free space verification before download - BIOS-1562?
# TODO: Expose more methods via CLI, e.g. to verify checksums of an image file
# TODO: Methods to compare if we have a candidate image newer than flashed bits
#       (and so if the user should reboot)

ACTION_DOWNLOAD_OSIMAGE="yes"
case "$ARCH" in
    *arm*)  ACTION_DOWNLOAD_FWIMAGE="yes" ;;
    *)      ACTION_DOWNLOAD_FWIMAGE="no" ;;
esac

ACTION_CHECK_OSIMAGE="no"
ACTION_CHECK_FWIMAGE="no"

# The routines can force a specific URL rather than detecting the "newest" one
[ -z "${URL_DOWNLOAD_OSIMAGE-}" ] &&                URL_DOWNLOAD_OSIMAGE=""
[ -z "${URL_DOWNLOAD_FWIMAGE_RAW_UBOOT-}" ] &&      URL_DOWNLOAD_FWIMAGE_RAW_UBOOT=""
[ -z "${URL_DOWNLOAD_FWIMAGE_RAW_UIMAGE-}" ] &&     URL_DOWNLOAD_FWIMAGE_RAW_UIMAGE=""
[ -z "${URL_DOWNLOAD_FWIMAGE_RAW_MODULES-}" ] &&    URL_DOWNLOAD_FWIMAGE_RAW_MODULES=""

ACTION_REMOVEOLD_OSIMAGE="yes"
# This is currently no-op because we only track "raw" FW images which have one
# data file per fwimage sub-type, unpacked on remote server
# TODO: Support creation, download and installation of timestamped FW tarballs
ACTION_REMOVEOLD_FWIMAGE="no"

# Ultimate exit code of the script
ACTION_RESULT=0

while [ $# -gt 0 ]; do
        case "${1-}" in
                -h|--help|-help)        usage; exit 0 ;;
                --debug-calls|--debug-calls-x)
                    if [ $# -eq 1 ]; then
                        die "The '$1' option requires further arguments"
                    fi
                    [ "$1" = "--debug-calls" ] && shift || { shift; set -xv; }
                    "$@" ; exit $? ;;
                -c|--config) [ -n "$2" ] && [ -s "$2" ] && [ -r "$2" ] && \
                        logmsg_info "Sourcing configuration file: '$2' ..." && \
                        . "$2" || die "Possibly got an error sourcing '$2', see above..."
                    shift ;;
                --remove-files)         FLAG_CAN_REMOVE_IMAGES="yes";;
                --no-remove-files)      FLAG_CAN_REMOVE_IMAGES="no";;
                --flatten-filenames)    FLAG_FLATTEN_FILENAMES="yes";;
                --no-flatten-filenames) FLAG_FLATTEN_FILENAMES="no";;
                --download-image-os)    ACTION_DOWNLOAD_OSIMAGE="yes";;
                --download-image-fw)    ACTION_DOWNLOAD_FWIMAGE="yes";;
                --download-images)      ACTION_DOWNLOAD_OSIMAGE="yes"; ACTION_DOWNLOAD_FWIMAGE="yes";;
                --no-download-image-os) ACTION_DOWNLOAD_OSIMAGE="no";;
                --no-download-image-fw) ACTION_DOWNLOAD_FWIMAGE="no";;
                --no-download-images)   ACTION_DOWNLOAD_OSIMAGE="no"; ACTION_DOWNLOAD_FWIMAGE="no";;
                --check-image-os)       ACTION_CHECK_OSIMAGE="yes";;
                --check-image-fw)       ACTION_CHECK_FWIMAGE="yes";;
                --check-images)         ACTION_CHECK_OSIMAGE="yes"; ACTION_CHECK_FWIMAGE="yes";;
                --no-check-image-os)    ACTION_CHECK_OSIMAGE="no";;
                --no-check-image-fw)    ACTION_CHECK_FWIMAGE="no";;
                --no-check-images)      ACTION_CHECK_OSIMAGE="no"; ACTION_CHECK_FWIMAGE="no";;
                --url-image-*)
                    [ $# -eq 1 ] && die "The '$1' option requires a further argument"
                    case "${1-}" in
                        --url-image-os)         URL_DOWNLOAD_OSIMAGE="$2"; shift;;
                        --url-image-fw-raw-uboot)   URL_DOWNLOAD_FWIMAGE_RAW_UBOOT="$2"; shift;;
                        --url-image-fw-raw-uimage)  URL_DOWNLOAD_FWIMAGE_RAW_UIMAGE="$2"; shift;;
                        --url-image-fw-raw-modules) URL_DOWNLOAD_FWIMAGE_RAW_MODULES="$2"; shift;;
                        *)  die "Aborting due to unknown command-line argument(s): $*" ;;
                    esac ;;
                --removeold-image-os)   ACTION_REMOVEOLD_OSIMAGE="yes";;
                --removeold-image-fw)   ACTION_REMOVEOLD_FWIMAGE="yes";;
                --removeold-images)     ACTION_REMOVEOLD_OSIMAGE="yes"; ACTION_REMOVEOLD_FWIMAGE="yes";;
                --no-removeold-image-os)ACTION_REMOVEOLD_OSIMAGE="no";;
                --no-removeold-image-fw)ACTION_REMOVEOLD_FWIMAGE="no";;
                --no-removeold-images)  ACTION_REMOVEOLD_OSIMAGE="no"; ACTION_REMOVEOLD_FWIMAGE="no";;
                *)  die "Aborting due to unknown command-line argument(s): $*" ;;
        esac
        shift
done

# Checks are special - after we do all which were requested (if any), we exit
if [ x"$ACTION_CHECK_OSIMAGE" = xyes ] || [ x"$ACTION_CHECK_FWIMAGE" = xyes ]; then
    RESULT_ACTION_CHECK_ANYIMAGE=0
    if [ x"$ACTION_CHECK_OSIMAGE" = xyes ]; then
        CHECK_ONLY=yes download_osimage $URL_DOWNLOAD_OSIMAGE || RESULT_ACTION_CHECK_ANYIMAGE=$?
    fi
    if [ x"$ACTION_CHECK_FWIMAGE" = xyes ]; then
        CHECK_ONLY=yes download_rawfwimage_uboot   $URL_DOWNLOAD_FWIMAGE_RAW_UBOOT   || RESULT_ACTION_CHECK_ANYIMAGE=$?
        CHECK_ONLY=yes download_rawfwimage_uimage  $URL_DOWNLOAD_FWIMAGE_RAW_UIMAGE  || RESULT_ACTION_CHECK_ANYIMAGE=$?
        CHECK_ONLY=yes download_rawfwimage_modules $URL_DOWNLOAD_FWIMAGE_RAW_MODULES || RESULT_ACTION_CHECK_ANYIMAGE=$?
    fi
    RES_STR="$RESULT_ACTION_CHECK_ANYIMAGE"
    case "$RESULT_ACTION_CHECK_ANYIMAGE" in
        0)  RES_STR="$RESULT_ACTION_CHECK_ANYIMAGE = Local files are OK, but there is nothing new to download" ;;
        42) RES_STR="$RESULT_ACTION_CHECK_ANYIMAGE = Should download something different from what we have locally" ;;
    esac
    logmsg_info "Exiting after completion of requested --check-* operations ($RES_STR)"
    exit $RESULT_ACTION_CHECK_ANYIMAGE
fi

RESULT_ACTION_DOWNLOAD_FWIMAGE=0
RESULT_ACTION_DOWNLOAD_FWIMAGE_RAW_UBOOT=0
RESULT_ACTION_DOWNLOAD_FWIMAGE_RAW_UIMAGE=0
RESULT_ACTION_DOWNLOAD_FWIMAGE_RAW_MODULES=0
if [ "$ACTION_DOWNLOAD_FWIMAGE" = yes ]; then
        download_rawfwimage_uboot $URL_DOWNLOAD_FWIMAGE_RAW_UBOOT
        RESULT_ACTION_DOWNLOAD_FWIMAGE_RAW_UBOOT=$?
        download_rawfwimage_uimage $URL_DOWNLOAD_FWIMAGE_RAW_UIMAGE
        RESULT_ACTION_DOWNLOAD_FWIMAGE_RAW_UIMAGE=$?
        download_rawfwimage_modules $URL_DOWNLOAD_FWIMAGE_RAW_MODULES
        RESULT_ACTION_DOWNLOAD_FWIMAGE_RAW_MODULES=$?

        [ "$RESULT_ACTION_DOWNLOAD_FWIMAGE_RAW_UBOOT" -gt 0 ] && \
            ACTION_RESULT=$RESULT_ACTION_DOWNLOAD_FWIMAGE_RAW_UBOOT && \
            if [ "$ACTION_REMOVEOLD_FWIMAGE" = yes ] ; then
                logmsg_warn "New u-Boot image was not downloaded successfully, so old ones are not purged"
                ACTION_REMOVEOLD_FWIMAGE=no_BadDownload
            fi

        [ "$RESULT_ACTION_DOWNLOAD_FWIMAGE_RAW_UIMAGE" -gt 0 ] && \
            ACTION_RESULT=$RESULT_ACTION_DOWNLOAD_FWIMAGE_RAW_UIMAGE && \
            if [ "$ACTION_REMOVEOLD_FWIMAGE" = yes ] ; then
                logmsg_warn "New kernel uImage was not downloaded successfully, so old ones are not purged"
                ACTION_REMOVEOLD_FWIMAGE=no_BadDownload
            fi

        [ "$RESULT_ACTION_DOWNLOAD_FWIMAGE_RAW_MODULES" -gt 0 ] && \
            ACTION_RESULT=$RESULT_ACTION_DOWNLOAD_FWIMAGE_RAW_MODULES && \
            if [ "$ACTION_REMOVEOLD_FWIMAGE" = yes ] ; then
                logmsg_warn "New modules archive was not downloaded successfully, so old ones are not purged"
                ACTION_REMOVEOLD_FWIMAGE=no_BadDownload
            fi
fi

if [ "$ACTION_REMOVEOLD_FWIMAGE" = yes ]; then
        removeold_rawfwimage_modules || ACTION_RESULT=$?
        removeold_rawfwimage_uimage || ACTION_RESULT=$?
        removeold_rawfwimage_uboot || ACTION_RESULT=$?
else
        logmsg_info "Not purging old FW images because ACTION_REMOVEOLD_FWIMAGE=$ACTION_REMOVEOLD_FWIMAGE"
fi

RESULT_ACTION_DOWNLOAD_OSIMAGE=0
if [ "$ACTION_DOWNLOAD_OSIMAGE" = yes ]; then
        download_osimage $URL_DOWNLOAD_OSIMAGE
        RESULT_ACTION_DOWNLOAD_OSIMAGE=$?
        # If there was indeed a successful download, we have code=42 from the
        # routine; however the script succeeded - so overall exitcode stays 0
        [ "$RESULT_ACTION_DOWNLOAD_OSIMAGE" -gt 0 -a "$RESULT_ACTION_DOWNLOAD_OSIMAGE" -ne 42 ] && \
            ACTION_RESULT=$RESULT_ACTION_DOWNLOAD_OSIMAGE && \
            if [ "$ACTION_REMOVEOLD_OSIMAGE" = yes ] ; then
                logmsg_warn "New OS image was not downloaded successfully, so old ones are not purged"
                ACTION_REMOVEOLD_OSIMAGE=no_BadDownload
            fi
fi

if [ "$ACTION_REMOVEOLD_OSIMAGE" = yes ]; then
        removeold_osimage || ACTION_RESULT=$?
else
        logmsg_info "Not purging old OS images because ACTION_REMOVEOLD_OSIMAGE=$ACTION_REMOVEOLD_OSIMAGE"
fi

exit $ACTION_RESULT
