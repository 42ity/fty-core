#!/bin/bash
#
# Copyright (C) 2015 Eaton
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
#! \file    systemctl
#  \brief   Helper script for REST API /admin/systemctl and /admin/sysinfo
#  \author  Michal Hrusecky <MichalHrusecky@Eaton.com>
#  \author  Jim Klimov <EvgenyKlimov@Eaton.com>
#  \details Helper script for REST API /admin/systemctl and /admin/sysinfo
#           Wraps the OS-provided /bin/systemctl to apply filters and allow
#           only those actions over those objects as needed for our project.
#

SYSTEMCTL_COMMANDS="show start stop restart enable disable status"

# TODO: Match this up with web/systemctl.ecpp and maybe the Makefile variables
# List of fixed strings that are good both for "case" and regexp matching
SYSTEMCTL_UNITS_COMMON="mariadb mysql mysqld ntp saslauthd malamute     \
                 bios-reset-button tntnet@bios bios-agent-alert-smtp    \
                 bios-agent-alert bios-agent-autoconfig bios-agent-cm   \
                 bios-agent-dbstore bios-agent-inventory bios-agent-nut \
                 bios-agent-th bios-agent-tpower bios-db-init           \
                 bios-server-agent                                      \
                 networking nut-monitor nut-server"

# For regexp matching
SYSTEMCTL_UNITS_REGEX='nut-driver@[^[:blank:]]*'
# Same for "case" matching
SYSTEMCTL_UNITS_GLOBS='nut-driver@*'

SYSTEMCTL="/bin/systemctl"

# Note: The matching code seems a bit overcomplicated, but it evolved
# to be almost 30x faster than the original simple-looking case ;)
SYSTEMCTL_UNITS_REGEX_SINGLE=""
FIRST=yes
for unit in ${SYSTEMCTL_UNITS_COMMON} ${SYSTEMCTL_UNITS_REGEX}; do
    [[ "$FIRST" = yes ]] && SYSTEMCTL_UNITS_REGEX_SINGLE="$unit" || \
        SYSTEMCTL_UNITS_REGEX_SINGLE="$SYSTEMCTL_UNITS_REGEX_SINGLE|$unit"
    FIRST=no
done
SYSTEMCTL_UNITS_REGEX_SINGLE='^('"${SYSTEMCTL_UNITS_REGEX_SINGLE}"')(|\.(service|timer|target))$'

isAllowed_Unit() {
    # $1 is a specific unit name, at most basename without an extension
    # We test if it matches one of the regexps listed in SYSTEMCTL_UNITS
    [[ -z "$1" ]] && return 2
    # NOTE: bash regex matching requires the regex to be not quoted, slashed etc
    [[ "$1" =~ $SYSTEMCTL_UNITS_REGEX_SINGLE ]] > /dev/null && return 0
#    echo "$1" | egrep "$SYSTEMCTL_UNITS_REGEX_SINGLE" > /dev/null && return 0
    return 1
}

isAllowed_cmd() {
    [[ -z "$1" ]] && return 2
    for cmd in ${SYSTEMCTL_COMMANDS}; do
        if [[ "x$cmd" = "x$1" ]] ; then
            return 0
        fi
    done
    return 1
}

case "$1" in
    list-units|--all|-a)
        SYSTEMCTL_ARGS=""
        while [ $# -gt 0 ]; do
            case "$1" in
                list-units|--all|-a|--full|-l)
                    SYSTEMCTL_ARGS="$SYSTEMCTL_ARGS $1" ;;
                *) echo "Action not allowed" >&2; exit 1;;
            esac
            shift
        done
        exec $SYSTEMCTL $SYSTEMCTL_ARGS
        # Should not get to this line
        ;;
esac

if  isAllowed_Cmd "$1" && \
    isAllowed_Unit "$2"
then
    cmd="$1"
    SYSTEMCTL_UNIT="$2"
    SYSTEMCTL_ARGS=""
    shift 2
    while [ $# -gt 0 ]; do
        case "$1" in
            --all|-a|--full|-l)
                SYSTEMCTL_ARGS="$SYSTEMCTL_ARGS $1" ;;
            *) echo "Action not allowed" >&2; exit 1;;
        esac
        shift
    done
    exec $SYSTEMCTL "$cmd" "$SYSTEMCTL_UNIT" $SYSTEMCTL_ARGS
    # Should not get to this line
fi

echo "Action not allowed" >&2
exit 1
