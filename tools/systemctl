#!/bin/bash
#
# Copyright (C) 2015-2016 Eaton
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
#! \file    systemctl
#  \brief   Helper script for REST API /admin/systemctl and /admin/sysinfo
#  \author  Michal Hrusecky <MichalHrusecky@Eaton.com>
#  \author  Jim Klimov <EvgenyKlimov@Eaton.com>
#  \details Helper script for REST API /admin/systemctl and /admin/sysinfo
#           as well as command-line usage via "sudo" for non-root users.
#           Wraps the OS-provided /bin/systemctl to apply filters and allow
#           only those actions over those objects as needed for our project.
#           Also adds a "list-json" command to display some details on units
#           we are allowed to see through the filter.
#           Similarly, wraps /bin/journalctl with same unit filters.
#

if [ -n "${BASH-}" ]; then
    set -o pipefail 2>/dev/null || true
else
    echo "systemctl: WARNING: It seems you execute '$0' not with 'bash' - this can fail!" >&2
fi

LANG=C
LC_ALL=C
TZ=UTC
export LANG LC_ALL TZ

# We can filter-wrap these programs
SYSTEMCTL="/bin/systemctl"
JOURNALCTL="/bin/journalctl"

SYSTEMCTL_COMMANDS="show start stop restart enable disable daemon-reload status is-active"
# NOTE: We do not support "--unit=UNITNAME" because it is too much hassle here
# NOTE: We also support "-n NUMBER" below
JOURNALCTL_COMMANDS="-f --follow -l -u -fl -lf -fu -uf -lu -ul -flu -ful -luf -lfu -ulf -ufl -a --all --no-pager -r --reverse -k --dmesg"

# TODO: Match this up with web/systemctl.ecpp and maybe the Makefile variables
# List of fixed strings that are good both for "case" and regexp matching
# NOTE: The web/systemctl.ecpp implementation maps "restart" requests for
# service name "networking" to be actually implemented by calling our own
# service named "bios-networking".
# NOTE-DEV: Validate that this filter is still valid with "systemctl-uptodate"
SYSTEMCTL_UNITS_COMMON="mariadb mysql mysqld ntp ntpd ntpdate sntp bios \
                 bios-reset-button tntnet@bios bios-db-init             \
                 bios-agent-alert-generator agent-alerts-list           \
                 bios-agent-autoconfig bios-agent-cm                    \
                 bios-agent-inventory                                   \
                 bios-agent-nut bios-agent-nut-configurator             \
                 bios-agent-asset bios-agent-legacy-metrics kpi-uptime  \
                 agent-th dc_th bios-agent-outage bios-agent-smtp       \
                 bios-agent-tpower bios-agent-rt bios-agent-ms          \
                 biostimer-warranty-metric biostimer-agent-ms-cleaner   \
                 malamute saslauthd networking network bios-networking  \
                 nut-driver nut-monitor nut-server"

# For regexp matching
SYSTEMCTL_UNITS_REGEX='(nut-driver|composite-metrics|biostimer-graphs-prefetch|biostimer-graphs-prefetch__.+)@[^[:blank:]]*'
# Same for "case" matching
SYSTEMCTL_UNITS_GLOBS='nut-driver@* composite-metrics@* biostimer-graphs-prefetch@* biostimer-graphs-prefetch__*@*'

# Note: The matching code seems a bit overcomplicated, but it evolved
# to be almost 30x faster than the original simple-looking case ;)
SYSTEMCTL_UNITS_REGEX_SINGLE=""
FIRST=yes
for unit in ${SYSTEMCTL_UNITS_COMMON} ${SYSTEMCTL_UNITS_REGEX}; do
    [[ "$FIRST" = yes ]] && SYSTEMCTL_UNITS_REGEX_SINGLE="$unit" || \
        SYSTEMCTL_UNITS_REGEX_SINGLE="$SYSTEMCTL_UNITS_REGEX_SINGLE|$unit"
    FIRST=no
done
SYSTEMCTL_UNITS_REGEX_SINGLE='^('"${SYSTEMCTL_UNITS_REGEX_SINGLE}"')($|\.(service|timer|target))$'

die_ACTION_NOT_ALLOWED() {
    # NOTE: These stderr-string and exit-code are expected by some clients
    # like CI tests or maybe even web-GUI
    # Do not change without good reason and inspection of other code!
    echo "Action not allowed" >&2
    exit 1
}

die_INTERNAL_ERROR() {
    echo "Internal error" >&2
    exit 2
}

isAllowed_Unit() {
    # $1 is a specific unit name, at most basename without an extension
    # We test if it matches one of the regexps listed in SYSTEMCTL_UNITS
    [[ -z "$1" ]] && return 2
    # NOTE: bash regex matching requires the regex to be NOT quoted, slashed etc
    [[ "$1" =~ $SYSTEMCTL_UNITS_REGEX_SINGLE ]] > /dev/null && return 0
#    echo "$1" | egrep "$SYSTEMCTL_UNITS_REGEX_SINGLE" > /dev/null && return 0
    return 1
}

isAllowed_Cmd_systemctl() {
    [[ -z "$1" ]] && return 2
    for cmd in ${SYSTEMCTL_COMMANDS}; do
        if [[ "x$cmd" = "x$1" ]] ; then
            return 0
        fi
    done
    return 1
}

isAllowed_Cmd_journalctl() {
    [[ -z "$1" ]] && return 2
    for cmd in ${JOURNALCTL_COMMANDS}; do
        if [[ "x$cmd" = "x$1" ]] ; then
            return 0
        fi
    done
    return 1
}

systemctl_list_json() {
	# This is our custom feature to speed up the "sysinfo" REST API.
        # TODO: List of "interesting" fields is currently hardcoded here and in
        # the two "case"s below, and in variable mapping too; there is quite a
        # bit to rewrite should we want this to be anyhow dynamic/on-request.
        SYSTEMCTL_ATTRS="-p Id -p SubState -p ActiveState -p UnitFileState -p LoadState"
        SYSTEMCTL_UNITS=""  # If empty, default of 'all allowed' will be used
        while [ $# -gt 0 ]; do
            case "$1" in
                --all|-a)
                        SYSTEMCTL_ATTRS="--all" ;;
                --full|-l) ;; # We do not truncate anyway
                *)  if isAllowed_Unit "$1" ; then
                        SYSTEMCTL_UNITS="$SYSTEMCTL_UNITS $1"
                    else
                        die_ACTION_NOT_ALLOWED
                    fi;;
            esac
            shift
        done

        # We need to convert a potentially multi-line or quoted values into an
        # escaped single-line token for valid markup; our JSON.sh can do that.
        [ -n "$JSONSH" ] && [ -s "$JSONSH" ] && [ -x "$JSONSH" ] || \
        for F in "`dirname $0`/JSON.sh" "/usr/share/bios/scripts/JSON.sh" \
            "$CHECKOUTDIR/tools/JSON.sh"; do
                [ -x "$F" -a -s "$F" ] && JSONSH="$F" && break
        done
        if [ -x "$JSONSH" ] ; then
            if [ -n "${BASH-}" ]; then
                . "$JSONSH"
            else
                logmsg_info "systemctl: Will fork to use JSON.sh from '$JSONSH' to cook strings"
                cook_a_string_arg() { "$JSONSH" -QQ "$1"; }
            fi
        else
            logmsg_warn "systemctl: FAILED to use JSON.sh from '$JSONSH'; will not cook strings" && JSONSH=""
            cook_a_string_arg() { echo "$*"; }
        fi

        FIRST=yes
        vID=""; vSS=""; vLS=""; vAS=""; vUFS=""; lOTHER=""
        # If the caller named certain unit names (and they were allowed) then
        # we pass them for listing; otherwise list everything and the filtered
        # pattern list (since "everything" on a local system might not include
        # items from this list because not installed). But this causes duplicates.
        # So we make single-lines of markup and follow up with sort|uniq and the
        # comma-adder in the end (possible loophole: case-sensitive matching).

        if [ "$DEBUG_SYSTEMCTL" = yes ]; then
            SYSTEMCTL="time $SYSTEMCTL"
            echo "$SYSTEMCTL show --full $SYSTEMCTL_ATTRS ${SYSTEMCTL_UNITS:-'*' $SYSTEMCTL_UNITS_COMMON $SYSTEMCTL_UNITS_GLOBS}" >&2
        fi

        ( $SYSTEMCTL show --full $SYSTEMCTL_ATTRS \
          ${SYSTEMCTL_UNITS:-'*' $SYSTEMCTL_UNITS_COMMON $SYSTEMCTL_UNITS_GLOBS} && echo "" ) | \
        while IFS='=' read -r KEY VALUE; do
            case "$KEY" in
                "") if [ -n "$vID" ] && [ x"$vID" != x".skip.$$" ]; then
                        sOTHER=""
                        if [[ x"$SYSTEMCTL_ATTRS" = 'x--all' ]] && [[ -n "$lOTHER" ]]; then
                            sOTHER="$(echo "$lOTHER" | while IFS== read K V; do printf ',"%s":"%s"' "`cook_a_string_arg "$K"`" "`cook_a_string_arg "$V"`" ; done )"
                        fi
                        printf '{"unit":"%s",\t"LoadState":"%s","ActiveState":"%s","UnitFileState":"%s","SubState":"%s"%s}\n' \
                            "`cook_a_string_arg "$vID"`" "$vLS" "$vAS" "`cook_a_string_arg "$vUFS"`" "$vSS" "$sOTHER"
                    fi
                    vID=""; vSS=""; vLS=""; vAS=""; vUFS=""; lOTHER=""
                    ;;
                Id)
                    isAllowed_Unit "$VALUE" && vID="$VALUE" || vID=".skip.$$" ;;
                UnitFileState)
                    vUFS="$VALUE";;
                ActiveState)
                    vAS="$VALUE";;
                LoadState)
                    vLS="$VALUE";;
                SubState)
                    vSS="$VALUE";;
                *) # Fallback for different casing, separate to optimize
                   # Do not waste time if the ID is known bad; empty is OK here
                    [ x"$vID" != x".skip.$$" ] && \
                    case "$KEY" in
                    [Ii][Dd])
                        isAllowed_Unit "$VALUE" && vID="$VALUE" || vID=".skip.$$" ;;
                    [Uu][Nn][Ii][Tt][Ff][Ii][Ll][Ss][Tt][Aa][Tt][Ee])
                        vUFS="$VALUE";;
                    [Aa][Cc][Tt][Ii][Vv][Ee][Ss][Tt][Aa][Tt][Ee])
                        vAS="$VALUE";;
                    [Ll][Oo][Aa][Dd][Ss][Tt][Aa][Tt][Ee])
                        vLS="$VALUE";;
                    [Ss][Uu][Bb][Ss][Tt][Aa][Tt][Ee])
                        vSS="$VALUE";;
                    *) # Ignore or expose unsupported fields?
                        if [[ x"$SYSTEMCTL_ATTRS" == 'x--all' ]]; then
                            # Display ALL
                            lOTHER="$KEY=$VALUE
$lOTHER"
                        fi # else = Ignore unknown
                        ;;
                    esac;;
            esac
        done | sort | uniq | { echo "["; while IFS='' read -r LINE; do
                [[ x"$FIRST" = xyes ]] && printf ' %s\n' "$LINE" || printf ',%s\n' "$LINE"
                FIRST=no
            done; echo "]"; }
}

process_CLI_systemctl() {
    # Quick support for specific commands
    case "$1" in
        list-units|--all|-a)
            SYSTEMCTL_ARGS=""
            while [ $# -gt 0 ]; do
                case "$1" in
                    list-units|--all|-a|--full|-l)
                        # NOTE: This allows to list ALL units, not just our filter
                        SYSTEMCTL_ARGS="$SYSTEMCTL_ARGS $1" ;;
                    *) die_ACTION_NOT_ALLOWED ;;
                esac
                shift
            done
            exec $SYSTEMCTL $SYSTEMCTL_ARGS
            # Should not get to this line
            die_INTERNAL_ERROR
            ;;
        list-json)
            shift
            systemctl_list_json "$@"
            exit $?
            ;;
    esac

    # Patch through some commands we allow over objects we allow
    if  isAllowed_Cmd_systemctl "$1" && \
        isAllowed_Unit "$2"
    then
        cmd="$1"
        SYSTEMCTL_UNIT="$2"
        SYSTEMCTL_ARGS=""
        ABORT=no
        shift 2
        while [ $# -gt 0 ]; do
            case "$1" in
                --all|-a|--full|-l|--quiet)
                    SYSTEMCTL_ARGS="$SYSTEMCTL_ARGS $1" ;;
                -n) if [ "$cmd" = status ] && [ -n "$2" ] && [ "$2" -gt 0 ]; then
                        SYSTEMCTL_ARGS="$SYSTEMCTL_ARGS $1 $2"
                        shift
                    else
                        ABORT=yes
                    fi
                    ;;
                *)  ABORT=yes ;;
            esac
            [ "$ABORT" = yes ] && die_ACTION_NOT_ALLOWED
            shift
        done
        exec $SYSTEMCTL "$cmd" "$SYSTEMCTL_UNIT" $SYSTEMCTL_ARGS
        # Should not get to this commented line
        die_INTERNAL_ERROR
    fi

    # Command and/or object were not among permitted ones
    die_ACTION_NOT_ALLOWED
}

process_CLI_journalctl() {
    # Patch through some commands we allow over objects we allow
    ABORT=no
    JOURNALCTL_ARGS=""

    while [ $# -gt 0 ]; do
        case "$1" in
            -n) if [ -n "$2" ] && [ "$2" -gt 0 ]; then
                    JOURNALCTL_ARGS="$JOURNALCTL_ARGS $1 $2"
                    shift 2
                else
                    ABORT=yes
                fi
                ;;
            *)
                if  isAllowed_Cmd_journalctl "$1" || \
                    isAllowed_Unit "$1"
                then
                    JOURNALCTL_ARGS="$JOURNALCTL_ARGS $1"
                    shift
                else
                    ABORT=yes
                fi
                ;;
        esac
        [ "$ABORT" = yes ] && die_ACTION_NOT_ALLOWED
    done
    [ -z "$JOURNALCTL_ARGS" ] && die_ACTION_NOT_ALLOWED
    exec $JOURNALCTL $JOURNALCTL_ARGS
    # Should not get to and beyond this commented line
    die_INTERNAL_ERROR
}

case "`basename $0`" in
    systemctl) process_CLI_systemctl "$@"; exit $? ;;
    journalctl) process_CLI_journalctl "$@"; exit $? ;;
esac

# Basename was not what this script wraps
die_ACTION_NOT_ALLOWED
