#!/bin/bash
# WARNING: bash syntax and capabilities are used intensively in code below!
#
# Copyright (C) 2015-2020 Eaton
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
#! \file    systemctl
#  \brief   Helper script for REST API /admin/systemctl and /admin/sysinfo
#  \author  Michal Hrusecky <MichalHrusecky@Eaton.com>
#  \author  Jim Klimov <EvgenyKlimov@Eaton.com>
#  \details Helper script for REST API /admin/systemctl and /admin/sysinfo
#           as well as command-line usage via "sudo" for non-root users.
#           Wraps the OS-provided /bin/systemctl to apply filters and allow
#           only those actions over those objects as needed for our project.
#           Also adds a "list-json" command to display some details on units
#           we are allowed to see through the filter.
#           Similarly, wraps /bin/journalctl with same unit filters.
#

if [ -n "${BASH-}" ] && [[ doublebracket = doublebracket ]]; then
    set -o pipefail 2>/dev/null || true
else
    echo "systemctl: WARNING: It seems you execute '$0' not with 'bash' - this can fail!" >&2
fi

LANG=C
LC_ALL=C
TZ=UTC
export LANG LC_ALL TZ

# We can filter-wrap these programs
SYSTEMCTL="/bin/systemctl"
JOURNALCTL="/bin/journalctl"

SCRIPT_BASENAME="`basename "$0"`"
SCRIPT_DIRNAME="`dirname "$0"`"
MAINPID="$$"
MAINARGS="$0 $*"

# Use syslog if "logger" is available
LOGGER="$(which logger)" 2>/dev/null || LOGGER=""

SYSTEMCTL_COMMANDS="show start stop restart reload reload-or-restart try-reload-or-restart enable disable mask unmask daemon-reload status is-active list-dependencies"
# NOTE: We do not support "--unit=UNITNAME" because it is too much hassle here
# NOTE: We do also support the two-token "-n NUMBER" explicitly below
JOURNALCTL_COMMANDS="-f --follow -l -u -fl -lf -fu -uf -lu -ul -flu -ful -luf -lfu -ulf -ufl -a --all --no-pager -r --reverse -k --dmesg"

# List of fixed strings that are good both for "case" and regexp matching
# TODO: Provide here only the framework for listing (unique) unit names
# which would be pulled from config snippets delivered by 42ity packages.
# NOTE: The web/systemctl.ecpp implementation maps "restart" requests for
# service name "networking" to be actually implemented by calling our own
# service named "bios-networking".
# NOTE-DEV: Validate that this filter is still valid with "systemctl-uptodate"
# SYSTEMCTL_UNITS_COMMON_EXTERNAL is a list of third-party services we rely on
SYSTEMCTL_UNITS_COMMON_EXTERNAL="mariadb mysql mysqld                   \
                 ntp ntpd ntpdate sntp                                  \
                 networking network                                     \
                 nut-driver nut-monitor nut-server                      \
                 nut-driver-enumerator nut-client nut                   \
                 nut-driver-enumerator-daemon nut-driver-enumerator-daemon-activator \
                 malamute saslauthd rsyslog rsyslogd"
# SYSTEMCTL_UNITS_COMMON_INTERNAL lists the services delivered by our project
# TODO: legacy-metrics will be removed, drop it there
SYSTEMCTL_UNITS_COMMON_INTERNAL="bios tntnet@bios fty-outage fty-metric-store   \
                                fty-tntnet@bios fty-envvars fty-hostname-setup  \
                                fty-license-accepted fty-db-init fty-db-engine  \
                                fty-kpi-power-uptime fty-alert-list fty-asset   \
                                fty-metric-store-cleaner fty-alert-engine       \
                                fty-email fty-metric-composite-configurator     \
                                fty-metric-tpower                               \
                                fty-info fty-mdns-sd fty-metric-snmp            \
                                bios-db-init bios-networking                    \
                                bios-reset-button bios-ssh-last-resort          \
                                biostimer-compress-logs biostimer-verify-fs     \
                                biostimer-loghost-rsyslog-netconsole fty-nut    \
                                biostimer-warranty-metric ifplug-dhcp-autoconf  \
                                ipc-meta-setup fty-sensor-env fty-discovery     \
                                fty-sensor-gpio                                 \
                                fty-nut-configurator fty-metric-compute         \
                                fty-metric-cache fty-alert-flexible             \
                                fty-metric-ambient-location"

SYSTEMCTL_UNITS_COMMON="$SYSTEMCTL_UNITS_COMMON_EXTERNAL $SYSTEMCTL_UNITS_COMMON_INTERNAL"

# For regexp matching of multi-instance services (a pipe-separated list)
SYSTEMCTL_UNITS_REGEX_EXTERNAL_LIST='nut-driver'
SYSTEMCTL_UNITS_REGEX_INTERNAL_LIST='composite-metrics|fty-metric-composite'
SYSTEMCTL_UNITS_REGEX_EXTERNAL="($SYSTEMCTL_UNITS_REGEX_EXTERNAL_LIST)"'@[^[:blank:]]*'
# Add vendor added-value units; note that ipc-* units that are
# intended for physical appliance are listed above explicitly
SYSTEMCTL_UNITS_REGEX_INTERNAL="($SYSTEMCTL_UNITS_REGEX_INTERNAL_LIST)"'@[^[:blank:]]*|(etn|ipm|ova)-[^[:blank:]]*'
SYSTEMCTL_UNITS_REGEX="($SYSTEMCTL_UNITS_REGEX_EXTERNAL_LIST|$SYSTEMCTL_UNITS_REGEX_INTERNAL_LIST)"'@[^[:blank:]]*'
# SAME data for "case" matching of multi-instance services
SYSTEMCTL_UNITS_GLOBS_EXTERNAL='nut-driver@*'
SYSTEMCTL_UNITS_GLOBS_INTERNAL='composite-metrics@* etn-* ipm-* ova-*'
SYSTEMCTL_UNITS_GLOBS="$SYSTEMCTL_UNITS_GLOBS_EXTERNAL $SYSTEMCTL_UNITS_GLOBS_INTERNAL"

# Note: The matching code seems a bit overcomplicated, but it evolved
# to be almost 30x faster than the original simple-looking case ;)
SYSTEMCTL_UNITS_REGEX_SINGLE=""
SYSTEMCTL_UNITS_REGEX_SINGLE_EXTERNAL=""
SYSTEMCTL_UNITS_REGEX_SINGLE_INTERNAL=""

FIRST=yes
for unit in ${SYSTEMCTL_UNITS_COMMON_EXTERNAL} ${SYSTEMCTL_UNITS_REGEX_EXTERNAL}; do
    [[ "$FIRST" = yes ]] && SYSTEMCTL_UNITS_REGEX_SINGLE_EXTERNAL="$unit" || \
        SYSTEMCTL_UNITS_REGEX_SINGLE_EXTERNAL="$SYSTEMCTL_UNITS_REGEX_SINGLE_EXTERNAL|$unit"
    FIRST=no
done

FIRST=yes
for unit in ${SYSTEMCTL_UNITS_COMMON_INTERNAL} ${SYSTEMCTL_UNITS_REGEX_INTERNAL}; do
    [[ "$FIRST" = yes ]] && SYSTEMCTL_UNITS_REGEX_SINGLE_INTERNAL="$unit" || \
        SYSTEMCTL_UNITS_REGEX_SINGLE_INTERNAL="$SYSTEMCTL_UNITS_REGEX_SINGLE_INTERNAL|$unit"
    FIRST=no
done

SYSTEMCTL_UNITS_REGEX_SINGLE="$SYSTEMCTL_UNITS_REGEX_SINGLE_EXTERNAL"
if [[ -n "$SYSTEMCTL_UNITS_REGEX_SINGLE_INTERNAL" ]]; then
    [[ -n "$SYSTEMCTL_UNITS_REGEX_SINGLE" ]] \
        && SYSTEMCTL_UNITS_REGEX_SINGLE="$SYSTEMCTL_UNITS_REGEX_SINGLE|$SYSTEMCTL_UNITS_REGEX_SINGLE_INTERNAL" \
        || SYSTEMCTL_UNITS_REGEX_SINGLE="$SYSTEMCTL_UNITS_REGEX_SINGLE_INTERNAL"
fi

SYSTEMCTL_UNITS_REGEX_SINGLE_INTERNAL_EXT='('"${SYSTEMCTL_UNITS_REGEX_SINGLE_INTERNAL}"')($|\.(service|timer|path|target))'
SYSTEMCTL_UNITS_REGEX_SINGLE_EXTERNAL_EXT='('"${SYSTEMCTL_UNITS_REGEX_SINGLE_EXTERNAL}"')($|\.(service|timer|path|target))'
SYSTEMCTL_UNITS_REGEX_SINGLE_EXT='('"${SYSTEMCTL_UNITS_REGEX_SINGLE}"')($|\.(service|timer|path|target))'

SYSTEMCTL_UNITS_REGEX_SINGLE_INTERNAL='^'"${SYSTEMCTL_UNITS_REGEX_SINGLE_INTERNAL_EXT}"'$'
SYSTEMCTL_UNITS_REGEX_SINGLE_EXTERNAL='^'"${SYSTEMCTL_UNITS_REGEX_SINGLE_EXTERNAL_EXT}"'$'
SYSTEMCTL_UNITS_REGEX_SINGLE='^'"${SYSTEMCTL_UNITS_REGEX_SINGLE_EXT}"'$'

write_syslog() {
    # TODO: Extend with config files and/or BIOS_* variables to point
    # logging directly to remote servers. etc?
    if [[ $# -gt 0 ]]; then
        if [[ -n "$LOGGER" ]] && [[ -x "$LOGGER" ]] ; then
            USER_PREFIX=""
            [[ -n "${SUDO_USER-}" ]] && \
                USER_PREFIX="sudo ${SUDO_USER-} (${SUDO_UID-}:${SUDO_GID-})"
            [[ -n "${USER-}" ]] && \
                USER_PREFIX="${USER_PREFIX:+$USER_PREFIX as }$USER (${UID-}/${EUID-}:${GID-})"
            [[ -n "$USER_PREFIX" ]] && USER_PREFIX="$USER_PREFIX:"
            $LOGGER -p auth.notice -t "${SCRIPT_BASENAME}-wrapper[$$]" "$USER_PREFIX" "$@" || true
        fi
        echo "$@" >&2
    fi
    return 0
}

cat_uniq() (
    # This prints input to output line by line, skipping lines that were
    # already printed (not necessarily in immediately previous line as uniq
    # requires). Note that a sort|uniq is still faster ATM (where keeping
    # the original line ordering does not matter).
    local LINE=""
    local LINES=""
    declare -A OUTARR   # Assoc.array to track printed lines
    while IFS= read LINE ; do
        # A mode to strip leading/trailing whitespace and
        # so only compare the not-empty payloads
        if [[ "$1" = "ignore_whitespace_around" ]] ; then
            LINES="`echo "$LINE" | ( IFS=" 	" read LINES ; echo "$LINES" )`"
            if [[ "${OUTARR["$LINES"]}" = 1 ]]; then : ; else
                echo "$LINE"
                OUTARR["$LINES"]=1
            fi
        else
            if [[ "${OUTARR["$LINE"]}" = 1 ]]; then : ; else
                echo "$LINE"
                OUTARR["$LINE"]=1
            fi
        fi
    done
)

echo_indent() {
    if [[ "${ECHO_INDENT-}" = no ]] ; then
        printf '%s\n' "$*"
        return $?
    fi
    [[ -z "${ECHO_INDENT_DEPTH-}" ]] && ECHO_INDENT_DEPTH="0" # Negative is ok = left-align
    [[ -z "${ECHO_INDENT_TEXT-}" ]] && ECHO_INDENT_TEXT="" # empty is ok
    printf "%${ECHO_INDENT_DEPTH}s%s\n" "$ECHO_INDENT_TEXT" "$*"
}

print_item_list() {
    { [[ -n "$1" ]] && [[ "$1" -gt 10 ]] && MAXLEN="$1" && shift || MAXLEN="73" ; } 2>/dev/null
    LL=0
    UL=0
    for U in "$@" ; do
        UL="${#U}"
        if [ "$LL" = 0 ]; then
            printf '  %s' "$U"
            LL="$((2+$UL))"
        else
            if [ "$(($LL+$UL))" -gt "$MAXLEN" ] ; then
                printf ' \\\n  %s' "$U"
                LL="$((2+$UL))"
            else
                printf ' %s' "$U"
                LL="$(($LL+1+$UL))"
            fi
        fi
    done
    echo""; echo ""
    unset LL UL U MAXLEN
}

usage_systemctl() {
    cat << EOF
Usage: ${SCRIPT_BASENAME} {list-units|--all|-a} [--full|-l]
    List the unit states for all units on this system (not filtered),
    optionally with full-length lines (by default truncated to terminal).

Usage: ${SCRIPT_BASENAME} list-json [modifiers] [list of units]
    List states of the units allowed by filter in JSON representation as
    expected by REST API calls, including the following systemd attributes:
      Id SubState ActiveState UnitFileState LoadState
    An optional "[-l|--full]" modifier is accepted and silently ignored.
    An optional "--all" modifier causes the script to list states of all
    units on this system in JSON format for REST API (may take obscene
    amount of time to parse this all - mode not intended for production).
    An empty list of units means to display all unit names that match the
    filter; otherwise the allowed unit names must be specified (whether they
    exist on this system or not) or an "Action not allowed" error will occur.

Usage: ${SCRIPT_BASENAME} list-ipm-units [modifiers] [unitnames]
    List names or some more details of the units allowed by filter.
    The listing may be further tuned for the following modifiers:
      --ipm-installed|--internal  List units developed as part of IPM
      --ipm-deps|--external       List units installed as dependencies for IPM
      --active                    List units with state "active" defined as:
        if "ActiveState" is "failed", "inactive", "activating", or "SubState"
        is "failed" or "dead" - skip this unit; else if "ActiveState" is
        "active" or if "SubState" is "running" or "waiting" - show this unit;
        otherwise skip it
      --inactive|--not-active     List units with state "inactive" defined as:
        if "ActiveState" is "active" or if "SubState" is "running" or "waiting"
        then skip this unit; else if "ActiveState" is "failed", "inactive", or
        "activating", or if "SubState" is "failed" or "dead" or "exited" - show
        this unit; otherwise skip it
      --enabled                   List units with state "enabled" defined as:
        if "LoadState" is "not-loaded" or if "UnitFileState" is "disabled"
        then skip this unit; else if "LoadState" is "loaded" or "UnitFileState"
        is "enabled" or "static" or empty - show this unit; otherwise skip
      --disabled|--not-enabled    List units with state "disabled" defined as:
        if "LoadState" is "loaded" or if "UnitFileState" is "enabled" or
        "static" or empty - skip this unit; otherwise show it
      --failed or --not-failed    List units that are in "failed" state vs.
                                  those that are running (or not) as expected
                                  Note that "activating" is "failed" for us
                                  (e.g. broken DB can be activating for days)
      --missing                   ONLY list unitnames that are in the filter
                                  but files are not installed in this system
      --init-script|--not-init-script ONLY list unit names that are implemented
                                  as init-script (or real units) based on an
                                  empty or populated value of UnitFileState
      --detailed|--details|--long|-l  List more than just the unit names
                                  (same data as JSON, but a TSV markup)
    Specifying all origins (e.g. "--internal --external") or all states means
    to disable output filtering by these criteria, which is the default setup.
    Defaults are to print one unit name per line (without further details),
    and to only print those units which are defined on this system, coming
    from any origin and having any state. By default all units in the filter
    are listed, however the caller may specify particular unit basenames
    (this is ignored in "--missing" mode).

Usage: ${SCRIPT_BASENAME} list-dependencies <modifiers or unit names>
    List the systemd units which have a defined dependency relation to the
    named unit(s) ("bios.target" by default), filtered by allowed unit names.
    The default mode is to show the "required" and "wanted" units of the
    specified unit (these should run for the specified one to begin starting).
    This mode accepts standard modifiers "--reverse", "--after" and "--before";
    the "--plain" representation for standard output is enforced, though this
    command-line argument also disables indentation in recursion. Acceptable
    non-standard modifiers are "--json" for same markup and data selection as
    list-json action (JSON for REST API), and "--detailed|--details|--long|-l"
    for same markup as "list-ipm-units --detailed".
Usage: ${SCRIPT_BASENAME} list-dependents <modifiers or unit names>
    A shortcut for "list-dependencies --reverse --before" to display those
    units which require the named one to run.

    Several custom options are available in the area of unit depenedcies:
Usage: ${SCRIPT_BASENAME} list-requires [--recursive|-r] [--uniq] <unit names>
Usage: ${SCRIPT_BASENAME} list-requiredby [--recursive|-r] [--uniq] <unit names>
Usage: ${SCRIPT_BASENAME} list-wants [--recursive|-r] [--uniq] <unit names>
Usage: ${SCRIPT_BASENAME} list-wantedby [--recursive|-r] [--uniq] <unit names>
Usage: ${SCRIPT_BASENAME} list-partof [--recursive|-r] [--uniq] <unit names>
    Walk the tree of standard unit attributes (just for this unit or recurse.
    The recursion stops at leaf units that have no direct requirements on
    further units that match the filter (so e.g. the "network{,ing}.service"
    hidden a few system hops away (e.g. behind a "basic.target") would not
    show up - use "list-dependencies" if those are needed).
    The output is filtered by the defined list of allowed IPM units, and with
    "--uniq" in place each unit name is only printed once (on first hit).
    The "--json" and "--detailed" modifiers explained above are also supported
    and enable "--uniq" mode as well. If no units are specified, lists all
    units allowed by filter, starting with tntnet@bios and bios service+target.
Usage: ${SCRIPT_BASENAME} list-depends-on [--recursive|-r] [--uniq] <unit names>
    A custom option to list units that the named one(s) "Requires" or "Wants"
    in order to run. Modifiers same as above.
Usage: ${SCRIPT_BASENAME} list-needed-by [--recursive|-r] [--uniq] <unit names>
    A custom option to list units for which the named one(s) are "RequiredBy",
    "WantedBy" or "PartOf" needed for those units run. Modifiers same as above.

Usage: ${SCRIPT_BASENAME} <certain allowed actions> <unitname> <modifiers>
    This wrapper allows certain standard actions to be done, against one of
    the units allowed by the filter (one at a time) if this is a unit action:
EOF
print_item_list ${SYSTEMCTL_COMMANDS}
    cat << EOF
    The "daemon-reload" action is passed without any further arguments.
    Actions that accept the [--all|-a|--full|-l|--quiet] modifiers will
    get them. The "status" action may additionally use [-n POSITIVENUMBER]
    modifier (Number of journal entries to show). The "show" action may
    additionally use one or more [-p KeyName] modifiers to list specific data.
EOF
}

usage_journalctl() {
    cat << EOF
Usage: ${SCRIPT_BASENAME} <allowed keywords or unitname>
    This wrapper allows certain standard actions and their combinations (as
    listed below) to be done, against the units allowed by the filter:
EOF
print_item_list "{-n POSITIVENUMBER}" ${JOURNALCTL_COMMANDS}

    cat << EOF
    These arguments may be specified in any order acceptable to the standard
    ${SCRIPT_BASENAME} program; its general usage follows:
EOF

    PAGER="" ${JOURNALCTL} --help
}

usage() {
    cat << EOF
This ${SCRIPT_BASENAME} is a wrapper for same-named system utility which limits the
scope of actions and targets available for a privilege-elevated user such as
the web-server process, and adds some custom actions that the standard utility
does not have. A "root" system administrator might want to use the original
"/bin/${SCRIPT_BASENAME}" program for standard functionality (but without our project
extensions).

This wrapper only allows actions against following unit basenames (with no
extension as defaulted by systemd, or any one from these three - .service,
.timer, .path or .target):
EOF
print_item_list ${SYSTEMCTL_UNITS_COMMON} ${SYSTEMCTL_UNITS_GLOBS}
    cat << EOF
Using any actions or targets not allowed by the filters will result in
a fatal error (non-zero exit code) and an "Action not allowed" message.

EOF

case "${SCRIPT_BASENAME}" in
    systemctl) usage_systemctl "$@";;
    journalctl) usage_journalctl "$@" ;;
esac
}

DIED=no
trap_exit() {
    EXITCODE=$?
    if [[ "$DEBUG_SYSTEMCTL" = yes ]]; then
        echo "TRAPPED EXIT: '$MAINARGS' DIED='$DIED' EXITCODE='$EXITCODE'" >&2
    fi
    { [[ "$EXITCODE" = 0 ]] && \
        write_syslog "Completed OK" || \
        write_syslog "Completed with code $EXITCODE" ; } >/dev/null 2>&1
    exit $EXITCODE
}

die_ACTION_NOT_ALLOWED() {
    # NOTE: These stderr-string and exit-code are expected by some clients
    # like CI tests or maybe even web-GUI
    # Do not change without good reason and inspection of other code!
    write_syslog "Action not allowed"
    [[ -n "$MAINPID" ]] && [[ -d "/proc/$MAINPID" ]] && kill -SIGUSR1 "$MAINPID"
    exit 1
}

die_INTERNAL_ERROR() {
    write_syslog "Internal error"
    [[ -n "$MAINPID" ]] && [[ -d "/proc/$MAINPID" ]] && kill -SIGUSR1 "$MAINPID"
    exit 2
}

isAllowed_Unit() {
    # $1 is a specific unit name, at most basename without an extension
    # We test if it matches one of the regexps listed in SYSTEMCTL_UNITS
    [[ -z "$1" ]] && return 2
    # NOTE: bash regex matching requires the regex to be NOT quoted, slashed etc
    [[ "$1" =~ $SYSTEMCTL_UNITS_REGEX_SINGLE ]] > /dev/null && return 0
#    echo "$1" | egrep "$SYSTEMCTL_UNITS_REGEX_SINGLE" > /dev/null && return 0
    return 1
}

isAllowed_Cmd_systemctl() {
    [[ -z "$1" ]] && return 2
    for cmd in ${SYSTEMCTL_COMMANDS}; do
        if [[ "x$cmd" = "x$1" ]] ; then
            return 0
        fi
    done
    return 1
}

isAllowed_Cmd_journalctl() {
    [[ -z "$1" ]] && return 2
    for cmd in ${JOURNALCTL_COMMANDS}; do
        if [[ "x$cmd" = "x$1" ]] ; then
            return 0
        fi
    done
    return 1
}

systemctl_list_json() {
        # This is our custom feature to speed up the "sysinfo" REST API.
        # TODO: The listing of units that do NOT exist on this system works
        # on systemd version in IPM (215?) but fails on newer one (e.g. 231).
        # TODO: List of "interesting" fields is currently hardcoded here and in
        # the two "case"s below, and in variable mapping too; there is quite a
        # bit to rewrite should we want this to be anyhow dynamic/on-request.
        SYSTEMCTL_ATTRS="-p Id -p SubState -p ActiveState -p UnitFileState -p LoadState"
        SYSTEMCTL_UNITS=""  # If empty, default of 'all allowed' will be used
        while [[ $# -gt 0 ]]; do
            case "$1" in
                --all|-a)
                        SYSTEMCTL_ATTRS="--all" ;;
                --full|-l) ;; # We do not truncate anyway
                *)  if isAllowed_Unit "$1" ; then
                        SYSTEMCTL_UNITS="$SYSTEMCTL_UNITS $1"
                    else
                        die_ACTION_NOT_ALLOWED
                    fi;;
            esac
            shift
        done

        # We need to convert a potentially multi-line or quoted values into an
        # escaped single-line token for valid markup; our JSON.sh can do that.
        [[ -n "$JSONSH" ]] && [[ -s "$JSONSH" ]] && [[ -x "$JSONSH" ]] || \
        for F in "${SCRIPT_DIRNAME}/JSON.sh" "/usr/share/fty/scripts/JSON.sh" "/usr/share/bios/scripts/JSON.sh" \
            "$CHECKOUTDIR/tools/JSON.sh"; do
                [[ -x "$F" ]] && [[ -s "$F" ]] && JSONSH="$F" && break
        done
        if [[ -x "$JSONSH" ]] ; then
            if [[ -n "${BASH-}" ]]; then
                . "$JSONSH"
            else
                logmsg_info "systemctl: Will fork to use JSON.sh from '$JSONSH' to cook strings"
                cook_a_string_arg() { "$JSONSH" -QQ "$1"; }
            fi
        else
            logmsg_warn "systemctl: FAILED to use JSON.sh from '$JSONSH'; will not cook strings" && JSONSH=""
            cook_a_string_arg() { echo "$*"; }
        fi

        FIRST=yes
        vID=""; vSS=""; vLS=""; vAS=""; vUFS=""; lOTHER=""
        # If the caller named certain unit names (and they were allowed) then
        # we pass them for listing; otherwise list everything and the filtered
        # pattern list (since "everything" on a local system might not include
        # items from this list because not installed). But this causes duplicates.
        # So we make single-lines of markup and follow up with sort|uniq and the
        # comma-adder in the end (possible loophole: case-sensitive matching).

        if [[ "$DEBUG_SYSTEMCTL" = yes ]]; then
            SYSTEMCTL="time $SYSTEMCTL"
            echo "$SYSTEMCTL show --full $SYSTEMCTL_ATTRS ${SYSTEMCTL_UNITS:-'*' $SYSTEMCTL_UNITS_COMMON $SYSTEMCTL_UNITS_GLOBS}" >&2
        fi

        ( $SYSTEMCTL show --full $SYSTEMCTL_ATTRS \
          ${SYSTEMCTL_UNITS:-'*' $SYSTEMCTL_UNITS_COMMON $SYSTEMCTL_UNITS_GLOBS} && echo "" ) | \
        while IFS='=' read -r KEY VALUE; do
            case "$KEY" in
                "") if [[ -n "$vID" ]] && [[ x"$vID" != x".skip.$$" ]]; then
                        sOTHER=""
                        if [[ x"$SYSTEMCTL_ATTRS" = 'x--all' ]] && [[ -n "$lOTHER" ]]; then
                            sOTHER="$(echo "$lOTHER" | while IFS== read K V; do printf ',"%s":"%s"' "`cook_a_string_arg "$K"`" "`cook_a_string_arg "$V"`" ; done )"
                        fi
                        printf '{"unit":"%s",\t"LoadState":"%s","ActiveState":"%s","UnitFileState":"%s","SubState":"%s"%s}\n' \
                            "`cook_a_string_arg "$vID"`" "$vLS" "$vAS" "`cook_a_string_arg "$vUFS"`" "$vSS" "$sOTHER"
                    fi
                    vID=""; vSS=""; vLS=""; vAS=""; vUFS=""; lOTHER=""
                    ;;
                Id)
                    isAllowed_Unit "$VALUE" && vID="$VALUE" || vID=".skip.$$" ;;
                UnitFileState)
                    vUFS="$VALUE";;
                ActiveState)
                    vAS="$VALUE";;
                LoadState)
                    vLS="$VALUE";;
                SubState)
                    vSS="$VALUE";;
                *) # Fallback for different casing, separate to optimize
                   # Do not waste time if the ID is known bad; empty is OK here
                    [[ x"$vID" != x".skip.$$" ]] && \
                    case "$KEY" in
                    [Ii][Dd])
                        isAllowed_Unit "$VALUE" && vID="$VALUE" || vID=".skip.$$" ;;
                    [Uu][Nn][Ii][Tt][Ff][Ii][Ll][Ss][Tt][Aa][Tt][Ee])
                        vUFS="$VALUE";;
                    [Aa][Cc][Tt][Ii][Vv][Ee][Ss][Tt][Aa][Tt][Ee])
                        vAS="$VALUE";;
                    [Ll][Oo][Aa][Dd][Ss][Tt][Aa][Tt][Ee])
                        vLS="$VALUE";;
                    [Ss][Uu][Bb][Ss][Tt][Aa][Tt][Ee])
                        vSS="$VALUE";;
                    *) # Ignore or expose unsupported fields?
                        if [[ x"$SYSTEMCTL_ATTRS" == 'x--all' ]]; then
                            # Display ALL
                            lOTHER="$KEY=$VALUE
$lOTHER"
                        fi # else = Ignore unknown
                        ;;
                    esac;;
            esac
        done | sort | uniq | { echo "["; while IFS='' read -r LINE; do
                [[ x"$FIRST" = xyes ]] && printf ' %s\n' "$LINE" || printf ',%s\n' "$LINE"
                FIRST=no
            done; echo "]"; }
}

list_known_unit_files() {
    # This lists ALL unit file pathnames (in locations we care about, at least)
    find {/usr/lib,/lib,/etc,/var/run}/systemd/system /var/run/systemd/generator.late -type f -or -type l
}

list_known_ipm_unit_files() (
    # NOTE: This prints pathnames, so there may be several hits per unit, e.g.
    # with a packaged implementation, local customization and "/etc/...wants"
    # For mass-matching sed+egrep are more efficient than multiple shell calls
    # ...by about 45 times over 35 unit matches in test...
    ###list_known_unit_files | while read F ; do isAllowed_Unit "`basename "$F"`" && echo "$F" ; done
    SYSTEMCTL_UNITS_REGEX_SINGLE_BY_BASENAME="`echo "$SYSTEMCTL_UNITS_REGEX_SINGLE" | sed 's,^\^,(^|/),'`"
    list_known_unit_files | egrep "$SYSTEMCTL_UNITS_REGEX_SINGLE_BY_BASENAME"
)

list_known_ipm_units() {
    # NOTE: This prints just sorted unique basenames
    # Piping directly from list_known_unit_files() is just marginally faster
    list_known_ipm_unit_files | sed 's,^.*/\([^/]*\)$,\1,' | sort | uniq
}

systemctl_list_ipm_units() (
    # This routine is our custom feature to speed up field support.
    # It lists units whose files are installed (or defined, for svc@instances)
    # locally, and can filter by certain states. It does not pollute the output
    # with unit names that are NOT INSTALLED.
    # We support listing of "--missing" units explicitly for non-regex names.
    LIST_UNITS=""
    LIST_STATES=""
    LIST_UNITTYPES=""
    LIST_MISSING="no"
    SHOW_DETAILS="no"
    SYSTEMCTL_UNITS=""
    ALL_KNOWN_UNITS=""
    REQUESTED_UNITS_REGEX=""
    REQUESTED_UNITS=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --ipm-installed|--internal) LIST_UNITS="$LIST_UNITS ORIGIN:INTERNAL" ;;
            --ipm-deps|--external) LIST_UNITS="$LIST_UNITS ORIGIN:EXTERNAL" ;;
            --active) LIST_STATES="$LIST_STATES STATE:ACTIVE" ;;
            --inactive|--not-active) LIST_STATES="$LIST_STATES STATE:INACTIVE" ;;
            --enabled) LIST_STATES="$LIST_STATES STATE:ENABLED" ;;
            --disabled|--not-enabled) LIST_STATES="$LIST_STATES STATE:DISABLED" ;;
            --failed) LIST_STATES="$LIST_STATES STATE:FAILED" ;;
            --not-failed) LIST_STATES="$LIST_STATES STATE:NOTFAILED" ;;
            --init-script) LIST_UNITTYPES="$LIST_UNITTYPES UNITTYPE:INITSCRIPT" ;;
            --not-init-script) LIST_UNITTYPES="$LIST_UNITTYPES UNITTYPE:REALUNIT" ;;
            --missing) LIST_MISSING="yes" ;;
            --detailed|--details|--long|-l) SHOW_DETAILS="yes" ;;
            *)  if isAllowed_Unit "$1" ; then
                    REQUESTED_UNITS="$REQUESTED_UNITS $1"
                    [[ -z "$REQUESTED_UNITS_REGEX" ]] && \
                        REQUESTED_UNITS_REGEX="$1" || \
                        REQUESTED_UNITS_REGEX="$REQUESTED_UNITS_REGEX|$1"
                else
                    die_ACTION_NOT_ALLOWED
                fi
                ;;
        esac
        shift
    done

    # Mutually exclusive options effectively mean we want everything...
    # Also note they are alphabetically pre-sorted ;)
    [[ -n "$LIST_UNITS" ]] && \
    LIST_UNITS="`for T in $LIST_UNITS ; do echo "$T" ; done | sort | uniq | tr '\n' " "`" && \
    [[ "$LIST_UNITS" =~ ORIGIN:EXTERNAL.*ORIGIN:INTERNAL ]] && LIST_UNITS=""

    # If caller wants missing units, they have no systemd state to care about
    [[ x"$LIST_MISSING" = x"yes" ]] && LIST_STATES=""

    [[ -n "$LIST_STATES" ]] && \
    LIST_STATES="`for T in $LIST_STATES ; do echo "$T" ; done | sort | uniq | tr '\n' " "`" && \
    [[ "$LIST_STATES" =~ (STATE:ACTIVE.*STATE:INACTIVE|STATE:DISABLED.*STATE:ENABLED|STATE:FAILED.*STATE:NOTFAILED) ]] && LIST_STATES=""

    [[ -n "$LIST_UNITTYPES" ]] && \
    LIST_UNITTYPES="`for T in $LIST_UNITTYPES ; do echo "$T" ; done | sort | uniq | tr '\n' " "`" && \
    [[ "$LIST_UNITTYPES" =~ (UNITTYPE:INITSCRIPT.*UNITTYPE:REALUNIT) ]] && LIST_UNITTYPES=""

    [[ -z "$LIST_UNITS" ]] && LIST_UNITS="ORIGIN:ANY"
    [[ -z "$LIST_STATES" ]] && LIST_STATES="STATE:ANY"
    [[ -z "$LIST_UNITTYPES" ]] && LIST_UNITTYPES="UNITTYPE:ANY"

    # List of unique unit filenames known to the system that match our filter
    if [[ -z "$REQUESTED_UNITS_REGEX" ]] || [[ "$LIST_MISSING" = yes ]]; then
        ALL_KNOWN_UNITS="`list_known_ipm_units`" || ALL_KNOWN_UNITS=""
    else
        REQUESTED_UNITS_REGEX_EXT='^[ \t]*('"$REQUESTED_UNITS_REGEX"')($|\.(service|timer|path|target))[ \t]*$'
        ALL_KNOWN_UNITS="`list_known_ipm_units | egrep "$REQUESTED_UNITS_REGEX_EXT"`" || ALL_KNOWN_UNITS=""
        if [[ -n "$ALL_KNOWN_UNITS" ]] && [[ -n "$REQUESTED_UNITS" ]] ; then
            # Keep the caller's order of unit names, not necessarily alphabetic
            SORTED_ALL_KNOWN_UNITS="$(for U in $REQUESTED_UNITS ; do echo "$ALL_KNOWN_UNITS" | egrep '^[ \t]*('"$U"')($|\.(service|timer|path|target))[ \t]*$' ; done)"
            ALL_KNOWN_UNITS="$SORTED_ALL_KNOWN_UNITS"
        fi
    fi
    unset REQUESTED_UNITS_REGEX REQUESTED_UNITS_REGEX_EXT

    [[ -z "$ALL_KNOWN_UNITS" ]] && \
    { if [[ x"$LIST_MISSING" != x"yes" ]] ; then
        # Handle the list-missing report uniformly below
        echo "No installed units match the filter" >&2
        return 3
      fi
    } || \
    if [[ "$LIST_UNITS" = "ORIGIN:ANY" ]]; then
        # Avoid two loops of regex over the same data
        SYSTEMCTL_UNITS="$ALL_KNOWN_UNITS"
    else
        # NOTE/TODO: Potentially support more than these two types later on
        # NOTE: "egrep" is a bit faster than bash while+regex here, but it
        # relies on unit entries being one per line
        SYSTEMCTL_UNITS_INTERNAL=""
        SYSTEMCTL_UNITS_EXTERNAL=""
        if [[ "$LIST_UNITS" =~ ORIGIN:INTERNAL ]] > /dev/null ; then
            #SYSTEMCTL_UNITS_INTERNAL="`echo "$ALL_KNOWN_UNITS" | while read F ; do [[ "$F" =~ $SYSTEMCTL_UNITS_REGEX_SINGLE_INTERNAL ]] > /dev/null && echo "$F"; done`"
            SYSTEMCTL_UNITS_INTERNAL="`echo "$ALL_KNOWN_UNITS" | egrep "$SYSTEMCTL_UNITS_REGEX_SINGLE_INTERNAL"`"
        fi
        if [[ "$LIST_UNITS" =~ ORIGIN:EXTERNAL ]] > /dev/null ; then
            #SYSTEMCTL_UNITS_EXTERNAL="`echo "$ALL_KNOWN_UNITS" | while read F ; do [[ "$F" =~ $SYSTEMCTL_UNITS_REGEX_SINGLE_EXTERNAL ]] > /dev/null && echo "$F"; done`"
            SYSTEMCTL_UNITS_EXTERNAL="`echo "$ALL_KNOWN_UNITS" | egrep "$SYSTEMCTL_UNITS_REGEX_SINGLE_EXTERNAL"`"
        fi

        SYSTEMCTL_UNITS="$SYSTEMCTL_UNITS_INTERNAL"
        if [[ -n "$SYSTEMCTL_UNITS_EXTERNAL" ]] ; then
            [[ -z "$SYSTEMCTL_UNITS" ]] \
                && SYSTEMCTL_UNITS="$SYSTEMCTL_UNITS_EXTERNAL" \
                || SYSTEMCTL_UNITS="$SYSTEMCTL_UNITS
$SYSTEMCTL_UNITS_EXTERNAL"
        fi
    fi

    if [[ x"$LIST_MISSING" = x"yes" ]] ; then
        # NOTE: This mode lists something or nothing and exits, always
        # It only lists missing unit names, there are no details to show etc.
        SHOW_UNITS=""
        if [[ -z "$SYSTEMCTL_UNITS" ]] ; then
            # Nothing found == all missing
            SHOW_UNITS="`echo "$SYSTEMCTL_UNITS_COMMON $SYSTEMCTL_UNITS_GLOBS" | tr ' ' '\n'`"
        else
            _SYSTEMCTL_UNITS_COMMON=""
            _SYSTEMCTL_UNITS_GLOBS=""
            if [[ "$LIST_UNITS" = "ORIGIN:ANY" ]]; then
                _SYSTEMCTL_UNITS_COMMON="$SYSTEMCTL_UNITS_COMMON"
                _SYSTEMCTL_UNITS_GLOBS="$SYSTEMCTL_UNITS_GLOBS"
            else
                # NOTE/TODO: Potentially support more than these two types later on
                if [[ "$LIST_UNITS" =~ ORIGIN:INTERNAL ]] > /dev/null ; then
                    _SYSTEMCTL_UNITS_COMMON="${_SYSTEMCTL_UNITS_COMMON} $SYSTEMCTL_UNITS_COMMON_INTERNAL"
                    _SYSTEMCTL_UNITS_GLOBS="${_SYSTEMCTL_UNITS_GLOBS} $SYSTEMCTL_UNITS_GLOBS_INTERNAL"
                fi
                if [[ "$LIST_UNITS" =~ ORIGIN:EXTERNAL ]] > /dev/null ; then
                    _SYSTEMCTL_UNITS_COMMON="${_SYSTEMCTL_UNITS_COMMON} $SYSTEMCTL_UNITS_COMMON_EXTERNAL"
                    _SYSTEMCTL_UNITS_GLOBS="${_SYSTEMCTL_UNITS_GLOBS} $SYSTEMCTL_UNITS_GLOBS_EXTERNAL"
                fi
            fi

            [[ -n "${_SYSTEMCTL_UNITS_COMMON}" ]] && \
            for U in ${_SYSTEMCTL_UNITS_COMMON} ; do
                echo "$SYSTEMCTL_UNITS" | \
                egrep "^$U"'($|\.(service|timer|path|target))$' > /dev/null \
                || SHOW_UNITS="$SHOW_UNITS
$U"
            done

            [[ -n "${_SYSTEMCTL_UNITS_GLOBS}" ]] && \
            for U in `echo "${_SYSTEMCTL_UNITS_GLOBS}" | sed 's,@\*$,,'` ; do
                echo "$SYSTEMCTL_UNITS" | \
                egrep "^$U"'@[^[:blank:]]+($|\.(service|timer|path|target))$' > /dev/null \
                || SHOW_UNITS="$SHOW_UNITS
$U"
            done
        fi

        [[ -n "$SHOW_UNITS" ]] && echo "$SHOW_UNITS" | egrep -v '^$' | sort | uniq && return 0

        echo "No installed units match your selection: $LIST_UNITS STATE:MISSING" | sed 's,  , ,g' >&2
        return 3
    fi

    [[ -n "$SYSTEMCTL_UNITS" ]] && \
    if [[ "$LIST_STATES" != "STATE:ANY" ]] || [[ "$LIST_UNITTYPES" != "UNITTYPE:ANY" ]] || [[ "$SHOW_DETAILS" = yes ]]; then
        # Logic borrowed from "--list-json" feature and simplified since
        # we have all the unit-naming data pre-filtered already
        # TODO: same issue as above that newer systemctl (v231) aborts
        # when trying to list units not defined on the local system.
        SHOW_UNITS=""
        SYSTEMCTL_ATTRS="-p Id -p SubState -p ActiveState -p UnitFileState -p LoadState"
        SYSTEMCTL_INFO="$( vID=""; vSS=""; vLS=""; vAS=""; vUFS=""; \
        ($SYSTEMCTL show --full $SYSTEMCTL_ATTRS `echo "$SYSTEMCTL_UNITS" | sed 's,\@\.,@.*\\.,g'` && echo "") | \
        while IFS='=' read -r KEY VALUE; do
            case "$KEY" in
                "") if [[ -n "$vID" ]] ; then
                        printf '%s\tL:%s\tA:%s\tU:%s\tS:%s\t\n' "$vID" "$vLS" "$vAS" "$vUFS" "$vSS"
                    fi
                    vID=""; vSS=""; vLS=""; vAS=""; vUFS=""
                    ;;
                Id)
                    vID="$VALUE";;
                UnitFileState)
                    vUFS="$VALUE";;
                ActiveState)
                    vAS="$VALUE";;
                LoadState)
                    vLS="$VALUE";;
                SubState)
                    vSS="$VALUE";;
                *) # Fallback for different casing, separate to optimize
                    case "$KEY" in
                    [Ii][Dd])
                        vID="$VALUE";;
                    [Uu][Nn][Ii][Tt][Ff][Ii][Ll][Ss][Tt][Aa][Tt][Ee])
                        vUFS="$VALUE";;
                    [Aa][Cc][Tt][Ii][Vv][Ee][Ss][Tt][Aa][Tt][Ee])
                        vAS="$VALUE";;
                    [Ll][Oo][Aa][Dd][Ss][Tt][Aa][Tt][Ee])
                        vLS="$VALUE";;
                    [Ss][Uu][Bb][Ss][Tt][Aa][Tt][Ee])
                        vSS="$VALUE";;
                    esac;;
            esac
        done )" || SYSTEMCTL_INFO=""

        if [[ "$DEBUG_SYSTEMCTL" = yes ]] ; then
            echo "$SYSTEMCTL_INFO"
        fi >&2

        [[ -z "$SYSTEMCTL_INFO" ]] && \
            echo "ERROR: No detailed information was collected from systemctl, will only print unit names" >&2 || \
        if [[ "$LIST_STATES" == "STATE:ANY" ]] \
        && [[ "$LIST_UNITTYPES" == "UNITTYPE:ANY" ]] \
        && [[ "$SHOW_DETAILS" = yes ]] \
        ; then
            # Shortcut : we want it all
            SYSTEMCTL_UNITS="$SYSTEMCTL_INFO"
        else
            for U in $SYSTEMCTL_UNITS ; do
                SHOW_THIS_UNIT=no # Match something below to show up
                # TODO: This egrep would be cleaner with '^'"$U"'[\t\ ]' - but for some reason that does not match our units
                I="`echo "$SYSTEMCTL_INFO" | egrep '^'"$U"`" || I=""
                if [[ -n "$I" ]]; then
                    ( # Subshell to simplify exit code passing and to limit shopt
                    # TODO: More research into evaluated strings is desirable here
                    SHOW1=""
                    SHOW2=""
                    SHOW3=""
                    SHOW4=""
                    shopt -s nocasematch
                    case "$LIST_STATES" in
                        *STATE:ENABLED*)
                            case "$I" in
                                *L:not-loaded*|*L:masked*|*U:disabled*|*U:bad*) SHOW1=no ;;
                                *L:loaded*|U:enabled*|*U:static*|*U:"	"S:*|*U:generated*) SHOW1=yes ;; # NOTE: It is a TAB character after U:
                                *) SHOW1=no ;;
                            esac
                            ;;
                        *STATE:DISABLED*)
                            case "$I" in
                                *L:not-loaded*|*L:masked*|*U:disabled*|*U:bad*) SHOW1=yes ;;
                                *L:loaded*|*U:enabled*|*U:static*|*U:"	"S:*|*U:generated*) SHOW1=no ;;
                                *) SHOW1=yes ;;
                            esac
                            ;;
                    esac

                    # NOTE: One-shot services can be "active" and "exited" if they ran OK
                    case "$LIST_STATES" in
                        *STATE:ACTIVE*)
                            case "$I" in
                                *[AS]:failed*|*A:inactive*|*A:activating*|*S:dead*) SHOW2=no ;;
                                *A:active*|*S:running*|*S:waiting*) SHOW2=yes ;;
                                *S:exited*) SHOW2=no ;;
                                *) SHOW2=no ;;
                            esac
                            ;;
                        *STATE:INACTIVE*)
                            case "$I" in
                                *A:active*|*S:running*|*S:waiting*) SHOW2=no ;;
                                *[AS]:failed*|*A:inactive*|*A:activating*|*S:dead*|*S:exited*) SHOW2=yes ;;
                                *) SHOW2=no ;;
                            esac
                            ;;
                    esac

                    case "$LIST_STATES" in
                        *STATE:FAILED*)
                            case "$I" in
                                *[AS]:failed*|*:active*:dead*|*A:activating*|*:enabled*:dead*) SHOW3=yes ;;
                                *) SHOW3=no ;;
                            esac
                            ;;
                        *STATE:NOTFAILED*)
                            case "$I" in
                                *[AS]:failed*|*:active*:dead*|*A:activating*|*:enabled*:dead*) SHOW3=no ;;
                                *) SHOW3=yes ;;
                            esac
                            ;;
                    esac

                    case "$LIST_UNITTYPES" in
                        *UNITTYPE:INITSCRIPT*)
                            case "$I" in
                                *U:"	"S:*|*U:generated*) SHOW4=yes ;; # NOTE: It is a TAB character after U:
                                *) SHOW4=no ;;
                            esac
                            ;;
                        *UNITTYPE:REALUNIT*)
                            case "$I" in
                                *U:"	"S:*|*U:generated*) SHOW4=no ;;
                                *) SHOW4=yes ;;
                            esac
                            ;;
                    esac

                    # We show units not filtered away by requirements listed on CLI
                    [[ x"$SHOW1" != xno ]] && [[ x"$SHOW2" != xno ]] && [[ x"$SHOW3" != xno ]] && [[ x"$SHOW4" != xno ]] # Return this test's exitcode
                    ) && SHOW_THIS_UNIT=yes
                fi
                if [[ "$SHOW_THIS_UNIT" = yes ]] ; then
                    if [[ "$DEBUG_SYSTEMCTL" = yes ]] ; then
                        echo "D: $I"
                    fi >&2
                    if [[ "$SHOW_DETAILS" = yes ]]; then
                        [[ -z "$SHOW_UNITS" ]] && SHOW_UNITS="$I" || SHOW_UNITS="$SHOW_UNITS
$I"
                    else
                        [[ -z "$SHOW_UNITS" ]] && SHOW_UNITS="$U" || SHOW_UNITS="$SHOW_UNITS
$U"
                    fi
                fi
            done
            SYSTEMCTL_UNITS="$SHOW_UNITS"
        fi
    fi

    [[ -z "$SYSTEMCTL_UNITS" ]] && \
        echo "No installed units match your selection: $LIST_UNITS $LIST_STATES $LIST_UNITS" | sed 's,  , ,g' >&2 && \
        return 3

    echo "$SYSTEMCTL_UNITS"
)

# Associative arrays used for caching the service requirements/wants
# Populated in systemctl_list_needs() by calling this routine:
declare -A SYSTEMCTL_DEPS_CACHED_REQUIRES
declare -A SYSTEMCTL_DEPS_CACHED_REQUIREDBY
declare -A SYSTEMCTL_DEPS_CACHED_WANTS
declare -A SYSTEMCTL_DEPS_CACHED_WANTEDBY
declare -A SYSTEMCTL_DEPS_CACHED_PARTOF
do_systemctl_list_deps_all() {
    # Prepare cached content in one shot
    local ALL_DEPS
    local _ID
    ALL_DEPS="$($SYSTEMCTL show -p Id -p Requires -p Wants -p RequiredBy -p WantedBy -p PartOf --all '*' '*.service' '*.target' '*.timer' '*.path' ; echo "")"

    _ID=""
    while IFS='=' read K V ; do
        case "$K" in
            Id) _ID="$V" ;;
            Requires) [[ -n "$_ID" ]] && SYSTEMCTL_DEPS_CACHED_REQUIRES["$_ID"]="$V" ;;
            RequiredBy) [[ -n "$_ID" ]] && SYSTEMCTL_DEPS_CACHED_REQUIREDBY["$_ID"]="$V" ;;
            Wants) [[ -n "$_ID" ]] && SYSTEMCTL_DEPS_CACHED_WANTS["$_ID"]="$V" ;;
            WantedBy) [[ -n "$_ID" ]] && SYSTEMCTL_DEPS_CACHED_WANTEDBY["$_ID"]="$V" ;;
            PartOf) [[ -n "$_ID" ]] && SYSTEMCTL_DEPS_CACHED_PARTOF["$_ID"]="$V" ;;
            "") _ID="" ;;
            *) ;;
        esac
    done << EOF
"$ALL_DEPS"
EOF
}

# The following routines just call systemctl and filters output.
# The input checking is in systemctl_list_needs() below.
# The dispatcher variable allows run-time code to call one of these routines.
dispatch_systemctl_list_deps_filtered=""
do_systemctl_list_requires_filtered() {
    local RR

    [[ -n "$1" ]] && \
    for RR in ${SYSTEMCTL_DEPS_CACHED_REQUIRES["$1"]} ; do
        [[ "$RR" =~ $SYSTEMCTL_UNITS_REGEX_SINGLE ]] > /dev/null && echo "$RR"
    done
}

do_systemctl_list_requiredby_filtered() {
    local RR

    [[ -n "$1" ]] && \
    for RR in ${SYSTEMCTL_DEPS_CACHED_REQUIREDBY["$1"]} ; do
        [[ "$RR" =~ $SYSTEMCTL_UNITS_REGEX_SINGLE ]] > /dev/null && echo "$RR"
    done
}

do_systemctl_list_wants_filtered() {
    local RR

    [[ -n "$1" ]] && \
    for RR in ${SYSTEMCTL_DEPS_CACHED_WANTS["$1"]} ; do
        [[ "$RR" =~ $SYSTEMCTL_UNITS_REGEX_SINGLE ]] > /dev/null && echo "$RR"
    done
}

do_systemctl_list_wantedby_filtered() {
    local RR

    [[ -n "$1" ]] && \
    for RR in ${SYSTEMCTL_DEPS_CACHED_WANTEDBY["$1"]} ; do
        [[ "$RR" =~ $SYSTEMCTL_UNITS_REGEX_SINGLE ]] > /dev/null && echo "$RR"
    done
}

do_systemctl_list_partof_filtered() {
    local RR

    [[ -n "$1" ]] && \
    for RR in ${SYSTEMCTL_DEPS_CACHED_PARTOF["$1"]} ; do
        [[ "$RR" =~ $SYSTEMCTL_UNITS_REGEX_SINGLE ]] > /dev/null && echo "$RR"
    done
}

do_systemctl_list_dependson_filtered() {
    local RR

    [[ -n "$1" ]] && \
    for RR in ${SYSTEMCTL_DEPS_CACHED_REQUIRES["$1"]} ${SYSTEMCTL_DEPS_CACHED_WANTS["$1"]} ; do
        [[ "$RR" =~ $SYSTEMCTL_UNITS_REGEX_SINGLE ]] > /dev/null && echo "$RR"
    done
}

do_systemctl_list_neededby_filtered() {
    local RR

    [[ -n "$1" ]] && \
    for RR in ${SYSTEMCTL_DEPS_CACHED_REQUIREDBY["$1"]} ${SYSTEMCTL_DEPS_CACHED_WANTEDBY["$1"]} ${SYSTEMCTL_DEPS_CACHED_PARTOF["$1"]} ; do
        [[ "$RR" =~ $SYSTEMCTL_UNITS_REGEX_SINGLE ]] > /dev/null && echo "$RR"
    done
}

do_systemctl_list_needs() {
    # This routine just calls systemctl and filters output.
    # The input checking is in systemctl_list_dependencies() below.
    local S
    local R
    local RLIST
    local ECHO_INDENT_DEPTH_PREV
    for S in "$@" ; do
        echo_indent "$S"
        RLIST="`$dispatch_systemctl_list_deps_filtered "$S"`"
        if [[ -n "$RLIST" ]] ; then
            ECHO_INDENT_DEPTH_PREV="$ECHO_INDENT_DEPTH"
            ECHO_INDENT_DEPTH="$(($ECHO_INDENT_DEPTH+1))"
            if [[ "$RECURSIVE" = yes ]]; then
                do_systemctl_list_needs $RLIST
            else
                for R in $RLIST ; do echo_indent "$R"; done
            fi
            ECHO_INDENT_DEPTH="$ECHO_INDENT_DEPTH_PREV"
        fi
    done
}

systemctl_list_needs() (
    if [[ -z "$dispatch_systemctl_list_deps_filtered" ]]; then
        die_ACTION_NOT_ALLOWED
    fi
    RECURSIVE="no"
    SYSTEMCTL_UNITS=""
    FILTER=""
    UNIQ=no
    ABORT=no
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --plain) ECHO_INDENT=no ;;
            --recursive|-r)
                RECURSIVE=yes ;;
            --all|-a)
                SYSTEMCTL_UNITS="$SYSTEMCTL_UNITS --all" ;;
            --uniq) UNIQ=yes ;;
            --detailed|--details|--long|-l) FILTER="systemctl_list_ipm_units $1" ;;
            --json) FILTER="systemctl_list_json" ;;
            *)  if isAllowed_Unit "$1" ; then
                    SYSTEMCTL_UNITS="$SYSTEMCTL_UNITS $1"
                else
                    ABORT=yes
                fi
                ;;
        esac
        [[ "$ABORT" = yes ]] && die_ACTION_NOT_ALLOWED
        shift
    done
    if [[ -n "$SYSTEMCTL_UNITS" ]] ; then
        SYSTEMCTL_UNITS="`$SYSTEMCTL show -p Id $SYSTEMCTL_UNITS | sed 's,^.*=,,'`"
    else
        SYSTEMCTL_UNITS="tntnet@bios.service bios.service bios.target fty-license-accepted.service `list_known_ipm_units | egrep -v 'tntnet@bios.service|bios.service|bios.target|fty-license-accepted.service'`"
    fi
    export RECURSIVE

    do_systemctl_list_deps_all

    if [[ -z "$FILTER" ]] ; then
        do_systemctl_list_needs $SYSTEMCTL_UNITS
    else
        $FILTER `do_systemctl_list_needs $SYSTEMCTL_UNITS`
    fi | \
    if [[ "$UNIQ" = yes ]] || [[ -n "$FILTER" ]]; then
        cat_uniq ignore_whitespace_around
    else cat ; fi
)

do_systemctl_list_dependencies() {
    # This routine just calls systemctl and filters output.
    # The input checking is in systemctl_list_dependencies() below.
    $SYSTEMCTL list-dependencies "$@" | \
    egrep '^[ \t\*]*'"$SYSTEMCTL_UNITS_REGEX_SINGLE_EXT"'[ \t]*$' | \
    sed 's,^\*, ,g' | \
    cat_uniq ignore_whitespace_around
}

systemctl_list_dependencies() (
    SYSTEMCTL_ARGS="--plain"
    SYSTEMCTL_UNITS=""
    FILTER=""
    ABORT=no
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --plain) ;;
            --reverse|--before|--after)
                SYSTEMCTL_ARGS="$SYSTEMCTL_ARGS $1" ;;
            --all|-a)
                SYSTEMCTL_UNITS="$SYSTEMCTL_UNITS --all" ;;
            --detailed|--details|--long|-l) FILTER="systemctl_list_ipm_units $1" ;;
            --json) FILTER="systemctl_list_json" ;;
            *)  if isAllowed_Unit "$1" ; then
                    SYSTEMCTL_UNITS="$SYSTEMCTL_UNITS $1"
                else
                    ABORT=yes
                fi
                ;;
        esac
        [[ "$ABORT" = yes ]] && die_ACTION_NOT_ALLOWED
        shift
    done
    [[ -n "$SYSTEMCTL_UNITS" ]] || SYSTEMCTL_UNITS="bios.target"
    if [[ -z "$FILTER" ]] ; then
        do_systemctl_list_dependencies $SYSTEMCTL_ARGS $SYSTEMCTL_UNITS
        return $?
    else
        $FILTER `do_systemctl_list_dependencies $SYSTEMCTL_ARGS $SYSTEMCTL_UNITS`
        return $?
    fi
)

process_CLI_systemctl() {
    # Quick support for specific commands
    case "$1" in
        help|-h|-help|--help) usage; exit 1 ;;
        list-units|--all|-a)
            SYSTEMCTL_ARGS=""
            while [[ $# -gt 0 ]]; do
                case "$1" in
                    list-units|--all|-a|--full|-l|--no-block)
                        # NOTE: This allows to list ALL units, not just our filter
                        SYSTEMCTL_ARGS="$SYSTEMCTL_ARGS $1" ;;
                    *) die_ACTION_NOT_ALLOWED ;;
                esac
                shift
            done
            $SYSTEMCTL $SYSTEMCTL_ARGS
            exit $?
            # Should not get to this line
            die_INTERNAL_ERROR
            ;;
        daemon-reload)
            $SYSTEMCTL "$1"
            exit $?
            ;;
        list-dependencies)
            shift
            systemctl_list_dependencies "$@"
            exit $?
            ;;
        list-dependents)
            shift
            systemctl_list_dependencies --before --reverse "$@"
            exit $?
            ;;
        list-requires)
            shift
            dispatch_systemctl_list_deps_filtered="do_systemctl_list_requires_filtered"
            systemctl_list_needs "$@"
            exit $?
            ;;
        list-requiredby)
            shift
            dispatch_systemctl_list_deps_filtered="do_systemctl_list_requiredby_filtered"
            systemctl_list_needs "$@"
            exit $?
            ;;
        list-wants)
            shift
            dispatch_systemctl_list_deps_filtered="do_systemctl_list_wants_filtered"
            systemctl_list_needs "$@"
            exit $?
            ;;
        list-wantedby)
            shift
            dispatch_systemctl_list_deps_filtered="do_systemctl_list_wantedby_filtered"
            systemctl_list_needs "$@"
            exit $?
            ;;
        list-partof)
            shift
            dispatch_systemctl_list_deps_filtered="do_systemctl_list_partof_filtered"
            systemctl_list_needs "$@"
            exit $?
            ;;
        list-depends-on)
            shift
            dispatch_systemctl_list_deps_filtered="do_systemctl_list_dependson_filtered"
            systemctl_list_needs "$@"
            exit $?
            ;;
        list-needed-by)
            shift
            dispatch_systemctl_list_deps_filtered="do_systemctl_list_neededby_filtered"
            systemctl_list_needs "$@"
            exit $?
            ;;
        list-json)
            shift
            systemctl_list_json "$@"
            exit $?
            ;;
        list-ipm-units)
            shift
            systemctl_list_ipm_units "$@"
            exit $?
            ;;
    esac

    # Patch through some commands we allow over objects we allow
    if  isAllowed_Cmd_systemctl "$1" && \
        isAllowed_Unit "$2"
    then
        cmd="$1"
        SYSTEMCTL_UNITS="$2"
        SYSTEMCTL_ARGS=""
        ABORT=no
        NOBREAK=no
        shift 2
        while [[ $# -gt 0 ]]; do
            case "$1" in
                help|-h|-help|--help) usage; exit 1 ;;
                --all|-a|--full|-l|--quiet|--now|--runtime)
                    SYSTEMCTL_ARGS="$SYSTEMCTL_ARGS $1" ;;
                --no-block)
                    # NOTE: Avoid early kills inside a dependency loop too
                    NOBREAK=yes
                    SYSTEMCTL_ARGS="$SYSTEMCTL_ARGS $1" ;;
                -n) if [[ "$cmd" = status ]] && [[ -n "$2" ]] && [[ "$2" -gt 0 ]]; then
                        SYSTEMCTL_ARGS="$SYSTEMCTL_ARGS $1 $2"
                        shift
                    else
                        ABORT=yes
                    fi
                    ;;
                -p) if [[ "$cmd" = show ]] && [[ -n "$2" ]] ; then
                        SYSTEMCTL_ARGS="$SYSTEMCTL_ARGS $1 $2"
                        shift
                    else
                        ABORT=yes
                    fi
                    ;;
                *)  if isAllowed_Unit "$1" ; then
                        SYSTEMCTL_UNITS="$SYSTEMCTL_UNITS $1"
                    else
                        ABORT=yes
                    fi
                    ;;
            esac
            [[ "$ABORT" = yes ]] && die_ACTION_NOT_ALLOWED
            shift
        done
        if [[ "$NOBREAK" = yes ]]; then
            # Inspired by http://veithen.github.io/2014/11/16/sigterm-propagation.html
            # except our goal is opposite ;) Still, two waits are the trick.
            trap 'echo "Interruption avoided due to no-block mode: $?" >&2' 1 2 3 15
            $SYSTEMCTL "$cmd" $SYSTEMCTL_UNITS $SYSTEMCTL_ARGS &
            CHILDPID=$!
            wait $CHILDPID
            wait $CHILDPID
            RES=$?
            [[ "$RES" -ge 128 ]] && RES=0 # wait broken by signal instantly returns 128+SIGNUM
            exit $RES
        else
            $SYSTEMCTL "$cmd" $SYSTEMCTL_UNITS $SYSTEMCTL_ARGS
            exit $?
        fi
        # Should not get to this commented line
        die_INTERNAL_ERROR
    fi

    # Command and/or object were not among permitted ones
    die_ACTION_NOT_ALLOWED
}

process_CLI_journalctl() {
    # Patch through some commands we allow over objects we allow
    ABORT=no
    JOURNALCTL_ARGS=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            help|-h|-help|--help) usage; exit 1 ;;
            -n) if [[ -n "$2" ]] && [[ "$2" -gt 0 ]]; then
                    JOURNALCTL_ARGS="$JOURNALCTL_ARGS $1 $2"
                    shift 2
                else
                    ABORT=yes
                fi
                ;;
            *)
                if  isAllowed_Cmd_journalctl "$1" || \
                    isAllowed_Unit "$1"
                then
                    JOURNALCTL_ARGS="$JOURNALCTL_ARGS $1"
                    shift
                else
                    ABORT=yes
                fi
                ;;
        esac
        [[ "$ABORT" = yes ]] && die_ACTION_NOT_ALLOWED
    done
    [[ -z "$JOURNALCTL_ARGS" ]] && die_ACTION_NOT_ALLOWED
    $JOURNALCTL $JOURNALCTL_ARGS
    exit $?
    # Should not get to and beyond this commented line
    die_INTERNAL_ERROR
}

# Set up exit-traps
trap "DIED=yes" SIGUSR1 # May be signalled by child processes
trap "trap_exit" EXIT SIGHUP SIGINT SIGABRT SIGQUIT SIGTERM

if [[ "$DEBUG_SYSTEMCTL" = yes ]]; then
    write_syslog "Starting $0 $*"
else
    write_syslog "Starting $0 $*" >/dev/null 2>&1
fi

case "${SCRIPT_BASENAME}" in
    systemctl) process_CLI_systemctl "$@"; exit $? ;;
    journalctl) process_CLI_journalctl "$@"; exit $? ;;
esac

# Basename was not what this script wraps
die_ACTION_NOT_ALLOWED
