#!/bin/sh

# Copyright (C) 2015 Eaton
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#   
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Author(s): Michal Vyskocil <MichalVyskocil@eaton.com>,
#
# Description:
#   tool for starting processes with proper dependencies and in a
#       user/developer friendly way
#   It has two main modes of operations:
#       1.) priviledged user under systemd - unit files are installed to /run
#           and executed
#       2.) non-priviledged user or non systemd - dependencies and arguments
#           are extracted and script run them on its own
#
#   TODO: it will be convenient if stdout/stderr of manually started processes
#         will be duplicated to 
#   TODO: what about mysql?
#

if [ "x$CHECKOUTDIR" = "x" ]; then
    SCRIPTDIR="$(cd "`dirname $0`" && pwd)" || \
    SCRIPTDIR="`dirname $0`"
    case "$SCRIPTDIR" in
        */tests/CI|tests/CI)
           CHECKOUTDIR="$( echo "$SCRIPTDIR" | sed 's|/tests/CI$||' )" || \
           CHECKOUTDIR="" ;;
        */tools|tools)
           CHECKOUTDIR="$( echo "$SCRIPTDIR" | sed 's|/tools$||' )" || \
           CHECKOUTDIR="" ;;
    esac
fi
[ "x$CHECKOUTDIR" = "x" ] && CHECKOUTDIR=~/project
echo "INFO: Test '$0 $@' will (try to) commence under CHECKOUTDIR='$CHECKOUTDIR'..."

[ -z "$BUILDSUBDIR" -a -d "$BUILDSUBDIR" ] && BUILDSUBDIR="$CHECKOUTDIR"
[ ! -x "$BUILDSUBDIR/config.status" ] && BUILDSUBDIR="$PWD"
if [ ! -x "$BUILDSUBDIR/config.status" ]; then
    echo "Cannot find $BUILDSUBDIR/config.status, did you run configure?"
    echo "Search path: $CHECKOUTDIR, $PWD"
    exit 1
fi
echo "INFO: Using BUILDSUBDIR='$BUILDSUBDIR' to locate project binaries..."

die() {
    echo "FATAL: ${@}" >&2
    exit 1
}

warn() {
    echo "WARNING: ${@}" >&2
}

usage() {
    echo "Usage: rc [--kill] names [of [processes [to [start]]]]" >&2
    if can_use_sysd; then
        echo "       systemd activation WILL BE used" >&2
    else
        echo "       systemd activation WILL NOT BE used" >&2
    fi
    echo "       tool supports short names, so rc nut == rc bios-driver-nut" >&2
    exit 1
}


my_systemctl() {
    /usr/bin/systemctl --system --no-pager --full "${@}"
}

is_external_unit() {
    local unit
    unit=${1}

    case "${unit}" in
        malamute|mysql|saslauthd)
            return 0
            ;;
    esac

    return 1
}

# find a proper name for unit file
# unit_name nut -> bios-driver-nut
# unit_name db -> bios-db
# unit_name malamute -> malamute
# unit_name mysql.service -> mysql
unit_name() {
    local arg
    arg=${1}

    [ -n "${arg}" ] || die "unit name must not be empty"

    arg=$(echo "${arg}" | sed -e 's/.service$//')

    if is_external_unit "${arg}"; then
        echo "${arg}"
        return 0
    fi

    for i in ${arg} bios-${arg} bios-driver-${arg}; do
        if [ -r "${CHECKOUTDIR}/tools/${i}.service.in" ]; then
            echo "${i}"
            return 0
        fi
    done

    return 1
}

subst_unit() {
    local unit
    unit=$(unit_name ${1})

    [ -n "${unit}" ] || \
        die "${CHECKOUTDIR}/tools/${unit}.service.in does not exist"

    sed -e "s|@libdir[@]/bios|${BUILDSUBDIR}|" \
        -e "s|@libexecdir[@]/bios|${BUILDSUBDIR}|" \
        -- "${CHECKOUTDIR}/tools/${unit}.service.in" | \
    sed 's|//|/|g'
}

# install unit file
install_unit_sysd() {
    local unit
    unit=$(unit_name ${1})

    [ -n "${unit}" ] || \
        die "${CHECKOUTDIR}/tools/${unit}.service.in does not exist"

    subst_unit "${unit}" > /run/systemd/system/${unit}.service
    my_systemctl daemon-reload
}

get_unit_dependencies() {
    local unit
    unit=$(unit_name ${1})

    [ -n "${unit}" ] || \
        die "${CHECKOUTDIR}/tools/${unit}.service.in does not exist"

    grep '^Requires=' "${CHECKOUTDIR}/tools/${unit}.service.in" | \
        cut -d '=' -f 2 | sed -e 's/.service\>//g' -e 's/[ \t]\+/\n/'
}

get_unit_exec() {
    local unit
    unit=$(unit_name ${1})

    [ -n "${unit}" ] || \
        die "${CHECKOUTDIR}/tools/${unit}.service.in does not exist"

    subst_unit "${unit}" | grep -e '^ExecStart=' | cut -d '=' -f 2
}

is_daemon_running() {
    local name pid pidfile
    name=${1}
    pidfile="${BUILDSUBDIR}/`basename ${name}`.pid"
    
    [ ! -r "${pidfile}" ] && return 1
    pid=$(head -1 "${pidfile}")
    if [ -z "$pid" -o ! -d "/proc/${pid}" ]; then
        warn "stale pid file ${pidfile} found, removing"
        rm -f ${pidfile}
        return 1
    fi
    return 0
}

start_daemon() {
    local name args pid
    name="${1}"
    shift 1
    args="${@}"

    is_daemon_running "${name}" && return 0

    type "${name}" >/dev/null || \
        [ -x ${name} ] || \
        die "Can't find executable ${name}"

    warn "START-DAEMON: ${name} ${args}"
    ${name} "${args}" &
    pid=$!
    warn "START-DAEMON: ${name}[${pid}] started"
    echo "${pid}" > "${BUILDSUBDIR}/`basename ${name}`.pid"

    # nasty hack to check if pid is still alive - we assume no daemonization
    # will be done by a program! this was script reports success or a fail
    sleep 3
    warn "START-DAEMON: Testing if PID $pid is still alive..."
    kill -0 ${pid}
}

stop_daemon() {
    local name pid pidfile
    name="${1}"
    shift 1
    pidfile="${BUILDSUBDIR}/`basename ${name}`.pid"

    if ! is_daemon_running "${name}"; then
        rm -f "${pidfile}"
        return 0
    fi

    pid=$(cat ${pidfile})
    kill -TERM ${pid}
    sleep 1
    kill -0 ${pid} 2>/dev/null && sleep 5
    kill -0 ${pid} 2>/dev/null && kill -KILL ${pid}
    rm -f "${pidfile}"
}

run_malamute_user() {
    [ -x /usr/bin/malamute ] || die "can't find /usr/bin/malamute"

    start_daemon malamute /etc/malamute/malamute.cfg
}

run_unit_user() {
    local unit args
    unit=$(unit_name ${1})

    [ -n "${unit}" ] || \
        die "${CHECKOUTDIR}/tools/${unit}.service.in does not exist"

    if [ "${unit}" = "malamute" ]; then
        run_malamute_user || die "cant run malamute"
        return 0
    fi

    if [ "${unit}" = "mysql" ]; then
        pgrep mysql || \
            die "starting of mysql is not yet implemented! run it manually"
        return 0
    fi

    is_daemon_running "${unit}" && return 0
    
    for dep_unit in $(get_unit_dependencies "${unit}"); do
        run_unit_user "${dep_unit}"
    done

    args=$(get_unit_exec "${unit}")
    start_daemon "${args}"
}

run_unit_sysd() {
    local unit
    unit=$(unit_name ${1})

    [ -n "${unit}" ] || \
        die "${CHECKOUTDIR}/tools/${unit}.service.in does not exist"

    if ! is_external_unit "${unit}"; then
        install_unit_sysd ${unit} || die "Can't install unit file for ${unit}"
    fi
    my_systemctl start ${unit}.service
}

can_use_sysd() {
    if [ $(id -u) != 0 ]; then
        return 1
    fi
    
    readlink -f /proc/1/exe | grep -q "/lib/systemd/systemd$"
}

main() {

    [ -n "${1}" ] || usage

    if [ "${1}" = "--kill" ]; then
        if can_use_sysd; then
            for unit in \
                $(my_systemctl list-units | grep ^bios- | cut -f 1 -d ' ') \
                malamute \
            ; do
                my_systemctl stop "${unit}"
                rm -f /run/systemd/system/${unit}.service
            done
        else
            for name in $(ls -1 *.pid | sed -e 's/\.pid$//'); do
                stop_daemon "${name}"
            done
        fi
        return $?
    fi

    local run
    if can_use_sysd; then
        run=run_unit_sysd
    else
        run=run_unit_user
    fi

    for i in "${@}"; do
        ${run} "${i}"
    done
}

main "${@}"
