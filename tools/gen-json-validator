#!/bin/bash

# Header
################################################################################
#                                                                              #
#  FILE        : gen-json-validator                                            #
#  VERSION     : 1.0                                                           #
#  CREATED     : 9.9.2014                                                      #
#  REVISION    : 10.9.2014                                                     #
#  AUTHOR      : Karol Hrdina (karolhrdina@eaton.com)                          #
#  COMPANY     : Eaton EEIC                                                    #
#                                                                              #
#  USAGE                                                                       #
#      gen-json-validator <path_to_topsrc_dir>                                 #
#                                                                              #
#  OPTIONS                                                                     #
#    self-describing                                                           #
#                                                                              #
#  DESCRIPTION                                                                 #
#  --------------------------------------------------------------------------  #
#    Generate c++ header file with functionality for automatic json            #
#  validation.                                                                 #
#  Produces 'json_schemas.h' in $(topsrc_dir)/src/utils/messages               #
#  --------------------------------------------------------------------------  #
#                                                                              #
#  TODOS                                                                       #
#    - Implement cleanup/trap                                                  #
#                                                                              #
#  BUGS                                                                        #
#    None known                                                                #
#                                                                              #
#  NOTES                                                                       #
#    When adding any further major features please consider python.            #
#                                                                              #
################################################################################



# Grandma friendly explanation (TODO i need to rewrite this, my grandma wouldn't
# undestand this yet :( )
# Requirements
# - files need to be in format '<message_name>Message.json'
# - contents of the file ( the json schema ) needs to have 'schema' property
#   defined and this needs to be the <message_name> string. To encode message
#   type into the schema itself is the only way to be able to recognize message
#   types later.
# 
# Now the algo of the generator istelf
# 1.
#   Go to messages/json_schema/ directory
# 2.
#   Take all files that end in 'Message.json'
# 3.
#   One by one, do the following for each file
# 3a.
#   read the schema, replace the <message_name> string in the "schema" property
#   with a unique natural number. This number will be later used when generating
#   enumtable/codetable functions
# 3b.
#   encode this modified schema into c friendly hex array
# 3c.
#   create a getter function for this message type using the c friendly hex array
# 3d.
#   add <message_name> into the message enumeration
# 3e.
#   create a libvariant::Variant with a deserialized JSON,
#   insert this object into a map with it's message enumeration
#   as the key.
# 3f.
#   add case branches into switch statements for codetable/enumtable    
# 3g.
# TODO    
#

# CHALLENGE (Reward = Beer):
# If you know about a better way of combining declare and heredoc in 
# bash, please let me know. I'll buy you a beer. However please be aware
# that using a bash external (i.e. cat) instead of bash builtin (i.e. 
# read) is not considered a better way :)

# check that we are in the correct place and that certain directories exist
declare -r SRC_DIR="${1}"
declare -r DEP_DIR_OUT="${SRC_DIR}/utils/messages"
declare -r DEP_DIR_IN="${SRC_DIR}/utils/messages/json_schema"

if [[ ! -d "${DEP_DIR_OUT}" ||
      ! -d "${DEP_DIR_IN}" ]]; then
  echo "ERROR: Directories don't exits."
  exit 1
fi

pushd "${DEP_DIR_OUT}"
if [[ $? -ne 0 ]]; then
  echo "ERROR: Cannot change to ${DEP_DIR_OUT}"  
  exit 1
fi

declare -r OUTPUT_FILENAME="json_schemas"
declare -r OUTPUT_FILENAME_EXT="h"
declare -r OUTPUT="${OUTPUT_FILENAME}.${OUTPUT_FILENAME_EXT}"

function fwrite_escape() {
  echo -e "${1}" >> "${OUTPUT}"
}
function fwrite() {
  echo "${1}" >> "${OUTPUT}"
}
rm -f ./"${OUTPUT}"

################################
###    LICENSE BOILERPLATE   ###
################################
read -r -d '' tmp <<EOF
/* ${OUTPUT}: json validation helpers generator
 
Copyright (C) 2014 Eaton
 
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or
(at your option) any later version.
 
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
 
You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

/*
Author(s): Karol Hrdina <karolhrdina@eaton.com>
 
Description: generator of automated json validator using libvirt
References: BIOS-347, BIOS-377
*/
EOF
declare -r LICENSE_BOILERPLATE="$tmp"

#######################################
###    FUNCTION WRAPPER TEMPLATE    ###
#######################################
read -r -d '' tmp <<EOF
inline const std::string& ##NAME##() {
  static std::string ret = {
##ARRAY##
  };
  return ret; 
}
EOF
declare -r FUNC_WRAPPER_TMPL="$tmp"

#######################################
###          HEADER GUARD           ###
#######################################
declare -r HEADER_GUARD_TERM="utils_messages_${OUTPUT_FILENAME}_H__"
read -r -d '' tmp <<EOF
#ifndef ${HEADER_GUARD_TERM}
#define ${HEADER_GUARD_TERM}

#include <string>
#include <map>

#include <Variant/Variant.h>
#include <Variant/Schema.h>

namespace utils {
\tnamespace json {
EOF
declare -r HEADER_GUARD_BEGIN="$tmp"

read -r -d '' tmp<<EOF
\t} // namespace json
} // namespace utils
#endif // ${HEADER_GUARD_TERM}
EOF
declare -r HEADER_GUARD_END="$tmp"

#######################################
###             ENUM                ###
#######################################
ENUM_SECTION=
declare -r ENUM_NAME="MessageTypesEnum"
declare -r ENUM_TMPL_PREFIX="enum class ${ENUM_NAME} {"
declare -r ENUM_TMPL_POSTFIX="UNKNOWN };"


#######################################
###           MAP_GETTER            ###
#######################################
declare MAP_GETTER_SECTION
read -r -d '' tmp<<EOF
const std::map<int, libvariant::Variant>& get_map() {
\tstatic std::map<int, libvariant::Variant> map = {
EOF
declare -r MAP_GETTER_TMPL_PREFIX="$tmp"

read -r -d '' tmp<<EOF
\t\tstd::pair<int, libvariant::Variant>(
\t\t\tstatic_cast<int>(${ENUM_NAME}::##ENUM##),
\t\t\tlibvariant::DeserializeJSON(utils::json::##NAME##().c_str())
\t\t),
EOF
declare -r MAP_GETTER_TMPL_ITEM="$tmp"

read -r -d '' tmp<<EOF
\t};
\treturn map;
}
EOF
declare -r MAP_GETTER_TMPL_POSTFIX="$tmp"

#######################################
###       CODETABLE SECTION         ###
#######################################
# TODO
read -r -d '' tmp<<EOF
/*!
\\brief 

Detailed description TODO

\\param[in] code 
\\return ${ENUM_NAME} 
\\see
\\author Karol Hrdina <karolhrdina@eaton.com>
*/
EOF
declare -r CODETABLE_FNC_DOXY="$tmp"

read -r -d '' tmp<<EOF
\tcase ##NUMBER##:
\t{
\t\treturn ${ENUM_NAME}::##ENUM_NAME##;
\t\tbreak;
\t}  
EOF
declare -r CODETABLE_CASE_TMPL="$tmp"

read -r -d '' tmp<<EOF
${ENUM_NAME} codetable(unsigned int code) {
\tswitch(code) {

EOF
declare -r CODETABLE_FNC_TMPL_PREFIX="$tmp"

read -r -d '' tmp<<EOF
\tdefault:
\t\treturn ${ENUM_NAME}::UNKNOWN;
\t\tbreak;
\t}
}
EOF
declare -r CODETABLE_FNC_TMPL_POSTFIX="$tmp"

#######################################
###       ENUMTABLE SECTION         ###
#######################################
# TODO
read -r -d '' tmp<<EOF
/*!
\\brief

Detailed description TODO

\\param[in] message_type 

\\return ${ENUM_NAME}

\\author Karol Hrdina <karolhrdina@eaton.com>
*/
EOF
declare -r ENUMTABLE_FNC_DOXY="$tmp"

read -r -d '' tmp<<EOF
\tcase ${ENUM_NAME}::##ENUM_NAME##:
\t{
\t\treturn ##NUMBER##;
\t\tbreak;
\t}  
EOF
declare -r ENUMTABLE_CASE_TMPL="$tmp"

read -r -d '' tmp<<EOF
unsigned int enumtable(${ENUM_NAME} message_type) {
\tswitch(message_type) {

EOF
declare -r ENUMTABLE_FNC_TMPL_PREFIX="$tmp"

read -r -d '' tmp<<EOF
\tdefault:
\t\treturn 0;
\t\tbreak;
\t}
}
EOF
declare -r ENUMTABLE_FNC_TMPL_POSTFIX="$tmp"


#######################################
###       VALIDATOR SECTION         ###
#######################################
declare -r VALIDATOR_FNC_RET_TYPE_NAME="ValidateResultEnum"
read -r -d '' tmp<<EOF
enum class ${VALIDATOR_FNC_RET_TYPE_NAME} {
\tValid,
\tInvalid,
\tSchemaError
};
EOF
declare -r VALIDATOR_FNC_RET_TYPE_DECL="$tmp"

###      VALIDATE PARSE      ###
read -r -d '' tmp<<EOF
/*!
\\brief Perform validation of json string against a given "message type" (i.e.
given json schema) and deserialize the json string

\\param[in]  json					 json string to be validated
\\param[in]  message_type  message type to validate the json string against  
\\param[out] root					 deserialized json string			 
\\param[out] strerr				 error string

\\return If successfull, return ${VALIDATOR_FNC_RET_TYPE_NAME}::Valid and assign
deserialized json string into 'root' parameter.
Otherwise, return either ${VALIDATOR_FNC_RET_TYPE_NAME}::Invalid (in case of input
json string being invalid) or ${VALIDATOR_FNC_RET_TYPE_NAME}::SchemaError (in case
of syntax error in json schema of the given message type) and assign error string
to strerr parameter.

\\author Karol Hrdina <karolhrdina@eaton.com>
*/
EOF
declare -r VALIDATE_PARSE_DOXY="$tmp"

read -r -d '' tmp<<EOF
${VALIDATOR_FNC_RET_TYPE_NAME}
validate_parse(
const char *json,
${ENUM_NAME} message_type,
libvariant::VariantRef root,
std::string& strerr) {
\tif (json == NULL) {
\t\treturn ${VALIDATOR_FNC_RET_TYPE_NAME}::Invalid;
\t}
\troot = libvariant::DeserializeJSON(json);
\tlibvariant::SchemaResult sr = SchemaValidate(
\t\tutils::json::get_map().at(static_cast<int>(message_type)),
\t\troot);
\tif(sr.SchemaErrors()) {
\t\tstrerr.assign(sr.PrettyPrintMessage());
\t\treturn ${VALIDATOR_FNC_RET_TYPE_NAME}::SchemaError;
\t}
\tif (sr.ValidationErrors()) {
\t\tstrerr.assign(sr.PrettyPrintMessage());
\t\treturn ${VALIDATOR_FNC_RET_TYPE_NAME}::Invalid;
\t}
\treturn ${VALIDATOR_FNC_RET_TYPE_NAME}::Valid;
}
EOF
declare -r VALIDATE_PARSE_FNC_DECL="$tmp"

###      VALIDATE PARSE OVERLOAD1     ###
read -r -d '' tmp<<EOF
/*!
\\brief Perform validation of json string against a given "message type" (i.e.
given json schema) and deserialize the json string

\\param[in]  json					 json string to be validated
\\param[in]  message_type  message type to validate the json string against  
\\param[out] root					 deserialized json string			 

\\return If successfull, return ${VALIDATOR_FNC_RET_TYPE_NAME}::Valid and assign
deserialized json string into 'root' parameter.
Otherwise, return either ${VALIDATOR_FNC_RET_TYPE_NAME}::Invalid (in case of input
json string being invalid) or ${VALIDATOR_FNC_RET_TYPE_NAME}::SchemaError (in case
of syntax error in json schema of the given message type).

\\author Karol Hrdina <karolhrdina@eaton.com>
*/
EOF
declare -r VALIDATE_PARSE_OVRLD1_DOXY="$tmp"

read -r -d '' tmp<<EOF
${VALIDATOR_FNC_RET_TYPE_NAME}
validate_parse(
const char *json,
${ENUM_NAME} message_type,
libvariant::VariantRef root) {
\tif (json == NULL) {
\t\treturn ${VALIDATOR_FNC_RET_TYPE_NAME}::Invalid;
\t}
\troot = libvariant::DeserializeJSON(json);
\tlibvariant::SchemaResult sr = SchemaValidate(
\t\tutils::json::get_map().at(static_cast<int>(message_type)),
\t\troot);
\tif(sr.SchemaErrors()) {
\t\treturn ${VALIDATOR_FNC_RET_TYPE_NAME}::SchemaError;
\t}
\tif (sr.ValidationErrors()) {
\t\treturn ${VALIDATOR_FNC_RET_TYPE_NAME}::Invalid;
\t}
\treturn ${VALIDATOR_FNC_RET_TYPE_NAME}::Valid;
}
EOF
declare -r VALIDATE_PARSE_OVRLD1_FNC_DECL="$tmp"


###      VALIDATE       ###
read -r -d '' tmp<<EOF
/*!
\\brief Perform validation of deserialized json against a given "message type" (i.e.
given json schema).

\\param[in]  json					 json string to be validated
\\param[in]  message_type  message type to validate the json string against  
\\param[out] strerr				 error string

\\return If successfull, return ${VALIDATOR_FNC_RET_TYPE_NAME}::Valid.
Otherwise, return either ${VALIDATOR_FNC_RET_TYPE_NAME}::Invalid (in case of input
json string being invalid) or ${VALIDATOR_FNC_RET_TYPE_NAME}::SchemaError (in case
of syntax error in json schema of the given message type) and assign error string
to strerr parameter.

\\author Karol Hrdina <karolhrdina@eaton.com>
*/
EOF
declare -r VALIDATE_DOXY="$tmp"


read -r -d '' tmp<<EOF
${VALIDATOR_FNC_RET_TYPE_NAME}
validate(
const char *json,
${ENUM_NAME} message_type,
std::string& strerr) {
\tif (json == NULL) {
\t\treturn ${VALIDATOR_FNC_RET_TYPE_NAME}::Invalid;
\t}
\tlibvariant::Variant temp = libvariant::DeserializeJSON(json);
\tlibvariant::SchemaResult sr = SchemaValidate(
\t\tutils::json::get_map().at(static_cast<int>(message_type)),
\t\ttemp);
\tif(sr.SchemaErrors()) {
\t\tstrerr.assign(sr.PrettyPrintMessage());
\t\treturn ${VALIDATOR_FNC_RET_TYPE_NAME}::SchemaError;
\t}
\tif (sr.ValidationErrors()) {
\t\tstrerr.assign(sr.PrettyPrintMessage());
\t\treturn ${VALIDATOR_FNC_RET_TYPE_NAME}::Invalid;
\t}
\treturn ${VALIDATOR_FNC_RET_TYPE_NAME}::Valid;
}
EOF
declare -r VALIDATE_FNC_DECL="$tmp"


###      VALIDATE OVERLOAD 1      ###
read -r -d '' tmp<<EOF
/*!
\\brief Perform validation of json string against a given "message type" (i.e.
given json schema).

\\param[in]  json					 json string to be validated
\\param[in]  message_type  message type to validate the json string against
  
\\return If successfull, return ${VALIDATOR_FNC_RET_TYPE_NAME}::Valid.
Otherwise, return either ${VALIDATOR_FNC_RET_TYPE_NAME}::Invalid (in case of input
json string being invalid) or ${VALIDATOR_FNC_RET_TYPE_NAME}::SchemaError (in case
of syntax error in json schema of the given message type)

\\author Karol Hrdina <karolhrdina@eaton.com>
*/
EOF
declare -r VALIDATE_OVRLD1_DOXY="$tmp"

read -r -d '' tmp<<EOF
${VALIDATOR_FNC_RET_TYPE_NAME}
validate(
const char *json,
${ENUM_NAME} message_type) {
\tif (json == NULL) {
\t\treturn ${VALIDATOR_FNC_RET_TYPE_NAME}::Invalid;
\t}
\tlibvariant::Variant temp = libvariant::DeserializeJSON(json);
\tlibvariant::SchemaResult sr = SchemaValidate(
\t\tutils::json::get_map().at(static_cast<int>(message_type)),
\t\ttemp);
\tif(sr.SchemaErrors()) {
\t\treturn ${VALIDATOR_FNC_RET_TYPE_NAME}::SchemaError;
\t}
\tif (sr.ValidationErrors()) {
\t\treturn ${VALIDATOR_FNC_RET_TYPE_NAME}::Invalid;
\t}
\treturn ${VALIDATOR_FNC_RET_TYPE_NAME}::Valid;
}
EOF
declare -r VALIDATE_OVRLD1_FNC_DECL="$tmp"

###      VALIDATE OVERLOAD 2      ###
read -r -d '' tmp<<EOF
/*!
\\brief Perform validation of deserialized json against a given "message type" (i.e.
given json schema).

\\param[in]  root					 deserialized json to be validated
\\param[in]  message_type  message type to validate the deserialized json against  
\\param[out] strerr				 error string

\\return If successfull, return ${VALIDATOR_FNC_RET_TYPE_NAME}::Valid.
Otherwise, return either ${VALIDATOR_FNC_RET_TYPE_NAME}::Invalid (in case of input
deserialized json being invalid) or ${VALIDATOR_FNC_RET_TYPE_NAME}::SchemaError (in
case of syntax error in json schema of the given message type) and assign error string
to strerr parameter.

\\author Karol Hrdina <karolhrdina@eaton.com>
*/
EOF
declare -r VALIDATE_PARSE_OVRLD2_DOXY="$tmp"

read -r -d '' tmp<<EOF
${VALIDATOR_FNC_RET_TYPE_NAME}
validate(
const libvariant::Variant& root,
${ENUM_NAME} message_type,
std::string& strerr) {
\tlibvariant::SchemaResult sr = SchemaValidate(
\t\tutils::json::get_map().at(static_cast<int>(message_type)),
\t\troot);
\tif(sr.SchemaErrors()) {
\t\tstrerr.assign(sr.PrettyPrintMessage());
\t\treturn ${VALIDATOR_FNC_RET_TYPE_NAME}::SchemaError;
\t}
\tif (sr.ValidationErrors()) {
\t\tstrerr.assign(sr.PrettyPrintMessage());
\t\treturn ${VALIDATOR_FNC_RET_TYPE_NAME}::Invalid;
\t}
\treturn ${VALIDATOR_FNC_RET_TYPE_NAME}::Valid;
}
EOF
declare -r VALIDATE_PARSE_OVRLD2_FNC_DECL="$tmp"

###      VALIDATE OVERLOAD 3      ###
read -r -d '' tmp<<EOF
/*!
\\brief Perform validation of deserialized json against a given "message type" (i.e.
given json schema).

\\param[in]  root					 deserialized json to be validated
\\param[in]  message_type  message type to validate the json string against  

\\return If successfull, return ${VALIDATOR_FNC_RET_TYPE_NAME}::Valid.
Otherwise, return either ${VALIDATOR_FNC_RET_TYPE_NAME}::Invalid (in case of input
json string being invalid) or ${VALIDATOR_FNC_RET_TYPE_NAME}::SchemaError (in case
of syntax error in json schema of the given message type).

\\author Karol Hrdina <karolhrdina@eaton.com>
*/
EOF
declare -r VALIDATE_PARSE_OVRLD3_DOXY="$tmp"
read -r -d '' tmp<<EOF
${VALIDATOR_FNC_RET_TYPE_NAME}
validate(
const libvariant::Variant& root,
MessageTypesEnum message_type) {
\tlibvariant::SchemaResult sr = SchemaValidate(
\t\tutils::json::get_map().at(static_cast<int>(message_type)),
\t\troot);
\tif(sr.SchemaErrors()) {
\t\treturn ${VALIDATOR_FNC_RET_TYPE_NAME}::SchemaError;
\t}
\tif (sr.ValidationErrors()) {
\t\treturn ${VALIDATOR_FNC_RET_TYPE_NAME}::Invalid;
\t}
\treturn ${VALIDATOR_FNC_RET_TYPE_NAME}::Valid;

}
EOF
declare -r VALIDATE_PARSE_OVRLD3_FNC_DECL="$tmp"

# START

# Init
ENUM_SECTION="${ENUM_TMPL_PREFIX}"
MAP_GETTER_SECTION="${MAP_GETTER_TMPL_PREFIX}\n"
CODETABLE_SECTION="${CODETABLE_FNC_TMPL_PREFIX}\n"
ENUMTABLE_SECTION="${ENUMTABLE_FNC_TMPL_PREFIX}\n"

declare -i COUNTER=0
###         REGEXP SECTION          ###
#read -r -d '' MODIFY_SCHEMAS_REGEXP<<EOF
#s/(\\s*"schema"\\s*:\\s*\{\\s*"type"\\s*:\\s*")string"(\\s*,\\s*"enum"\\s*:\\s*\[\\s*)"\\s*CliNetworkAddDel\\s*"(\\s*\]\\s*\})/\1number", "multipleOf" : 1.0, "minumum" : 1\2${COUNTER}\3/
#EOF

fwrite_escape "${LICENSE_BOILERPLATE}"
fwrite_escape ""
fwrite_escape "${HEADER_GUARD_BEGIN}"
fwrite_escape ""
for f in ./json_schema/*.json; do
  filename=`basename ${f%.json}` # TODO rewrite using builtins
  COUNTER="$COUNTER + 1"
  enum="${filename/Message/}"
  read -r -d '' MODIFY_SCHEMAS_REGEXP<<EOF
s/(\\s*"schema"\\s*:\\s*\{\\s*"type"\\s*:\\s*")string"(\\s*,\\s*"enum"\\s*:\\s*\[\\s*)"\\s*${enum}\\s*"(\\s*\]\\s*\})/\1number", "multipleOf" : 1.0, "minumum" : 1\2${COUNTER}\3/
EOF

  out=$(cat "$f" | sed -re "$MODIFY_SCHEMAS_REGEXP" | xxd -i)
#  out="${out}, 0x00"
  tmp="${FUNC_WRAPPER_TMPL}"
  tmp="${tmp/\#\#NAME\#\#/$filename}"
  tmp="${tmp/\#\#ARRAY\#\#/$out}"
  fwrite_escape "$tmp"
  fwrite_escape "" 
  ENUM_SECTION="${ENUM_SECTION}\n\t${enum},"
  tmp="${MAP_GETTER_TMPL_ITEM}"
  tmp="${tmp/\#\#NAME\#\#/$filename}"
  tmp="${tmp/\#\#ENUM\#\#/$enum}"
  MAP_GETTER_SECTION="${MAP_GETTER_SECTION}\n${tmp}"

  tmp="${CODETABLE_CASE_TMPL}"
  tmp="${tmp/\#\#NUMBER\#\#/${COUNTER}}"
  tmp="${tmp/\#\#ENUM_NAME\#\#/${enum}}"
  CODETABLE_SECTION="${CODETABLE_SECTION}\n${tmp}"

  tmp="${ENUMTABLE_CASE_TMPL}"
  tmp="${tmp/\#\#NUMBER\#\#/${COUNTER}}"
  tmp="${tmp/\#\#ENUM_NAME\#\#/${enum}}"
  ENUMTABLE_SECTION="${ENUMTABLE_SECTION}\n${tmp}"
  
done
fwrite_escape ""

# End
ENUM_SECTION="$ENUM_SECTION\n$ENUM_TMPL_POSTFIX\n"
MAP_GETTER_SECTION="${MAP_GETTER_SECTION}\n\n${MAP_GETTER_TMPL_POSTFIX}\n"
CODETABLE_SECTION="${CODETABLE_SECTION}\n${CODETABLE_FNC_TMPL_POSTFIX}\n"
ENUMTABLE_SECTION="${ENUMTABLE_SECTION}\n${ENUMTABLE_FNC_TMPL_POSTFIX}\n"

fwrite_escape "${ENUM_SECTION}"
fwrite_escape "${MAP_GETTER_SECTION}"

fwrite "${CODETABLE_FNC_DOXY}"
fwrite ""
fwrite_escape "${CODETABLE_SECTION}"

fwrite "${ENUMTABLE_FNC_DOXY}"
fwrite ""
fwrite_escape "${ENUMTABLE_SECTION}"

fwrite_escape "${VALIDATOR_FNC_RET_TYPE_DECL}\n"
fwrite ""

fwrite "${VALIDATE_PARSE_DOXY}"
fwrite ""
fwrite_escape "${VALIDATE_PARSE_FNC_DECL}\n"
fwrite ""

fwrite "${VALIDATE_PARSE_OVRLD1_DOXY}"
fwrite ""
fwrite_escape "${VALIDATE_PARSE_OVRLD1_FNC_DECL}\n"
fwrite ""

fwrite "${VALIDATE_DOXY}"
fwrite ""
fwrite_escape "${VALIDATE_FNC_DECL}\n"
fwrite ""

fwrite "${VALIDATE_OVRLD1_DOXY}"
fwrite ""
fwrite_escape "${VALIDATE_OVRLD1_FNC_DECL}\n"
fwrite ""

fwrite "${VALIDATE_OVRLD2_DOXY}"
fwrite ""
fwrite_escape "${VALIDATE_OVRLD2_FNC_DECL}\n"
fwrite ""

fwrite "${VALIDATE_OVRLD3_DOXY}"
fwrite ""
fwrite_escape "${VALIDATE_OVRLD3_FNC_DECL}\n"
fwrite ""

fwrite_escape "${HEADER_GUARD_END}\n"

exit 0
