#!/bin/sh

#
# Copyright (C) 2015 - 2020 Eaton
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#

#! \file   ssl-create.sh
#  \author Michal Hrusecky <MichalHrusecky@Eaton.com>
#  \author Jim Klimov <EvgenyKlimov@Eaton.com>
#  \brief  Initialize webserver X509 certificate
#  \details Prepares a new self-signed certificate if one is missing
#           or has expired or is not yet valid or is for another host.
#           Does not replace CA-issued certs, even if they seem invalid.

CN=""
FROM=""
TO=""
SIG="Autogenerated self-signed"

PEM_FINAL_CERT="/etc/tntnet/bios.pem"
PEM_KEY="/etc/tntnet/bios.key"
PEM_CERT="/etc/tntnet/bios.crt"

for F in "$PEM_FINAL_CERT" "$PEM_KEY" "$PEM_CERT" ; do
    D="`dirname "$F"`"
    if [ ! -d "$D/" ]; then
        echo "FATAL: Directory '$D' to hold the PEM files does not exist!" >&2
        exit 1
    fi
done

# Warn about expiration this much in advance, e.g. 45 days
WARN_EXPIRE="`expr 45 \* 24 \* 3600`"

TS_NOW="`TZ=UTC date -u +%s`"
LOCAL_HOSTNAME="`hostname -f`" || LOCAL_HOSTNAME=""
if [ -z "$LOCAL_HOSTNAME" ] || [ "$LOCAL_HOSTNAME" = localhost ] ; then
	LOCAL_HOSTNAME="`hostname`" || LOCAL_HOSTNAME=""
fi
[ -z "$LOCAL_HOSTNAME" ] && LOCAL_HOSTNAME="`cat /etc/hostname`"

if [ -z "$LOCAL_HOSTNAME" ]; then
	echo "ERROR: can't guess hostname" >&2
	exit 1
fi

BIOS_USER="admin"

CERT_LOADABLE=no
if [ -f "${PEM_FINAL_CERT}" ] ; then
    # The command below can report errors if the file is empty or unreadable
    # so we do not test '-r' nor '-s' above explicitly.
    SSL_OUT="`openssl x509 -noout -dates -subject < "${PEM_FINAL_CERT}"`" && \
    [ -n "$SSL_OUT" ] && CERT_LOADABLE=yes
fi

if [ "$CERT_LOADABLE" = yes ]; then
    FROM="`echo "$SSL_OUT" | sed -n 's|notBefore=||p'`" && \
        [ -n "$FROM" ] && FROM="`TZ=UTC date -u -d "$FROM" +%s`" || \
        FROM=""
    TILL="`echo "$SSL_OUT" | sed -n 's|notAfter=||p'`" && \
        [ -n "$TILL" ] && TILL="`TZ=UTC date -u -d "$TILL" +%s`" && \
        [ "$TILL" -gt "$WARN_EXPIRE" ] && TILL="`expr $TILL - $WARN_EXPIRE`" || \
        TILL=""
    CN="`echo "$SSL_OUT" | sed -n 's|subject= /CN=||p'`" || \
        CN=""
fi

if [ ! -r "${PEM_FINAL_CERT}" ] || [ ! -s "${PEM_FINAL_CERT}" ] || \
   [ -z "$FROM" ] || [ -z "$TILL" ] || \
   [ "$FROM" -gt "${TS_NOW}" ] || [ "$TILL" -lt "${TS_NOW}" ] || \
   [ "$CN" != "${LOCAL_HOSTNAME}" ] \
; then
    # Not to overwrite CA-issued certificate
    if [ -s "${PEM_FINAL_CERT}" ] && [ -z "`grep "$SIG" "${PEM_FINAL_CERT}" 2>/dev/null`" ]; then
        chown "${BIOS_USER}" "${PEM_FINAL_CERT}"        # Just in case
        [ "$CERT_LOADABLE" = yes ]      # Error out if the cert file is invalid
                                        # (reported to stderr by openssl above)
        exit $?
    fi

    # "/run/tntnet-bios" should be provided by systemd-tmpfiles-setup, but on
    # development machines a common system location can be used to generate a
    # temporary openssl config for certificate generation and self-signing.
    for TEMP_DIR in "/run/tntnet-bios" "/dev/shm" "/tmp" "" ; do
        [ -n "$TEMP_DIR" ] || exit $? # errors reported earlier by this loop
        [ -d "$TEMP_DIR" ] && [ -w "$TEMP_DIR/" ] && break
        echo "WARNING: TEMP_DIR at '$TEMP_DIR' is not usable, trying another!" >&2
    done

    TEMP_SSLCONF="`mktemp "$TEMP_DIR/ssl.conf.XXXXXX"`" && [ -n "$TEMP_SSLCONF" ] || exit $?

    # certificate configuration (disable CA)
    cat > "$TEMP_SSLCONF" << EOF
[ req ]
distinguished_name=dn
[ dn ]
[ ext ]
basicConstraints=CA:FALSE
EOF
    RES=$?
    if [ $RES != 0 ] || [ ! -s "$TEMP_SSLCONF" ] ; then
        echo "FATAL: Failed to generate a temporary openssl config into '$TEMP_SSLCONF'" >&2
        rm -f "$TEMP_SSLCONF"
        [ "$RES" = 0 ] && RES=1
        exit $RES
    fi

    # Generate self-signed cert with a new key and other data
    openssl req -config "${TEMP_SSLCONF}" -x509 -sha256 -newkey rsa:2048 \
        -keyout "${PEM_KEY}" -out "${PEM_CERT}" \
        -days 9125 -nodes -subj "/CN=${LOCAL_HOSTNAME}" \
    || { RES=$? ; rm -f "${TEMP_SSLCONF}" ; exit $RES; }
    rm -f "${TEMP_SSLCONF}"

    rm -f "${PEM_FINAL_CERT}"
    echo "$SIG" | \
        cat - "${PEM_KEY}" "${PEM_CERT}" > "${PEM_FINAL_CERT}" \
    || exit $?

    RES=0
    chown "${BIOS_USER}" "${PEM_FINAL_CERT}" || RES=$?
    chown "${BIOS_USER}:www-data" "${PEM_KEY}" || RES=$?
    chmod 640 "${PEM_KEY}" || RES=$?
    chown "${BIOS_USER}:www-data" "${PEM_CERT}" || RES=$?
    chmod 644 "${PEM_CERT}" || RES=$?

    [ -s "$PEM_CERT" ] && [ -s "$PEM_KEY" ] && [ -s "$PEM_FINAL_CERT" ] || { RES=$? ; echo "FATAL: one or more PEM file is missing or empty" >&2; }
    exit $RES
fi

RES=0
[ -s "$PEM_CERT" ] && [ -s "$PEM_KEY" ] && [ -s "$PEM_FINAL_CERT" ] || { RES=$? ; echo "FATAL: one or more PEM file is missing or empty" >&2; }
exit $RES
