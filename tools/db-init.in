#!/bin/bash

# Copyright (C) 2014-2015 Eaton
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
#! \file   db-init(.in)
#  \brief  Inits the BIOS database schema on factory-default installations
#           or do an appropriate update of database schema after reboot
#  \author Karol Hrdina <KarolHrdina@Eaton.com>
#  \author Alena Chernikava <AlenaChernikava@Eaton.com>
#  \author Michal Hrusecky <MichalHrusecky@Eaton.com>
#  \author Jim Klimov <EvgenyKlimov@Eaton.com>
#  \details Caller may export BIOS_DB_INIT envvar set to 'initialize' or
#           'upgrade' to trigger the corresponding function and exit.
#

prefix="@prefix@"
DATABASE=box_utf8
# This is where we take current SQL files from updated OS images
INITSQL_DIR="@datarootdir@/@PACKAGE@/sql/mysql"
# This is where we save timestamped copies of applied SQL files that
# are in the database. Note/TODO: currently this may include schema/data
# files from a previous database lifetime, if it is re-initialized.
# Conversely, as part of /var namespace this is erased during factory-reset.
INSTSQL_DIR="/var/lib/@PACKAGE@/sql/mysql"
# This file is applied first; others (if exist in $INITSQL_DIR) will be applied
# in alphabetic order; all files in $INITSQL_DIR will be version-tested as well
INITSQL_FIRST="${INITSQL_DIR}/initdb.sql"

# TODO: While the script currently supports both initialization of database
# from several SQL files (first and others) and validation of schema versions
# present in the database, it does not support automated addition of new SQL
# files coming with e.g. additional software modules. That is, initialization
# is currently done all at once.

# This is needed for systemd integration which does not have HOME set
# The variable is needed not only for ourselves, but also for "mysql" client
[ -n "$HOME" ] || HOME="$(getent passwd "`id -un`" | awk -F: '{print $6}')"
[ $? = 0 ] && [ -n "$HOME" ] && [ -d "$HOME" ] || HOME="/root"
export HOME
MYCNF="$HOME/.my.cnf"

# MySQL-root password is empty by default, otherwise is cached in $MYCNF
# and so it is not needed to specify it explicitly either

# Flag used to set a password, empty if defaults suffice
MYSQL_ROOT_PASSWD_FLAG=''

# Legacy support
[ -s /etc/default/mysql-root-passwd ] && . /etc/default/mysql-root-passwd
# Can set MYSQL_ROOT_PASSWD value

# Currently one value is supported - the first line should be "not-required"
# or "skip" if the service may start in cases which otherwise require an
# upgrade of the database. The difference would be for "skip" to quit the
# routine immediately (even if upgrades are possible, TBD later) and for
# "not-required" to not fail if the upgrade is impossible.
# TODO: Other later upgrades of this mechanism may include processing of
# "sqlbasename: policy" lines to match specific files.
UPGRADE_POLICY_FILE="/etc/default/bios-db-upgradepolicy"
UPGRADE_POLICY="require"

do_mysql() {
	mysql -u root "$@"
}

exec_sql() {
	# NOTE: $1 must be the SQL request; any other params like
	# passwd can follow afterwards as $2 etc.
	# SQL commands should be separated by ';' chars, though last
	# (or single) command may omit it
	do_mysql -Ns -e "$@"
}

exec_sql_db() {
	do_mysql -Ns -D "${DATABASE}" -e "$@"
}

random_password() {
	# Generate a random ASCII string without "confusing" characters
	head -c 12 /dev/urandom | base64 | sed 's,[\+\=\/\ \t\n\r\%],_,g'
}

secure_database() {
	GOOD_BIOS_RW=no
	GOOD_BIOS_RO=no
	[ -s /etc/default/bios-db-rw ] && \
		( . /etc/default/bios-db-rw && mysql -u "${DB_USER}" --password="${DB_PASSWD}" -D "${DATABASE}" -e "select 'working';" | grep -w working >/dev/null ) && \
		GOOD_BIOS_RW=yes
	[ -s /etc/default/bios-db-ro ] && \
		( . /etc/default/bios-db-ro && mysql -u "${DB_USER}" --password="${DB_PASSWD}" -D "${DATABASE}" -e "select 'working';" | grep -w working >/dev/null ) && \
		GOOD_BIOS_RO=yes
	if [ "$GOOD_BIOS_RW" = no ] || [ "$GOOD_BIOS_RO" = no ]; then
		echo "Database for BIOS initialization - generating user passwords..."

		[ "$GOOD_BIOS_RW" = yes ] && \
			BIOS_RW="`(. /etc/default/bios-db-rw && echo "${DB_PASSWD}")`" && \
			[ -n "$BIOS_RW" ] || BIOS_RW="`random_password`"
		[ "$GOOD_BIOS_RO" = yes ] && \
			BIOS_RO="`(. /etc/default/bios-db-ro && echo "${DB_PASSWD}")`" && \
			[ -n "$BIOS_RO" ] || BIOS_RO="`random_password`"

		cat << EOF | do_mysql
GRANT DELETE,INSERT,SELECT,UPDATE ON ${DATABASE}.* TO 'bios-rw'@'localhost' IDENTIFIED BY '$BIOS_RW';
GRANT SELECT                      ON ${DATABASE}.* TO 'bios-ro'@'localhost' IDENTIFIED BY '$BIOS_RO';
FLUSH PRIVILEGES;
EOF
		[ "$GOOD_BIOS_RW" = yes ] || \
			printf 'DB_USER="%s"\nDB_PASSWD="%s"\n' "bios-rw" "${BIOS_RW}" > /etc/default/bios-db-rw
		[ "$GOOD_BIOS_RO" = yes ] || \
			printf 'DB_USER="%s"\nDB_PASSWD="%s"\n' "bios-ro" "${BIOS_RO}" > /etc/default/bios-db-ro
		chown bios /etc/default/bios-db-r[wo]
		chmod 600 /etc/default/bios-db-r[wo]
	else
		echo "Database for BIOS - all existing user passwords are good"
	fi
}

SQLINSTALL_TIMESTAMP="t=`date -u '+%Y%m%dT%H%M%SZ'`"

install_sql_file() {
	# Currently we allow to install all SQLs at once. But later we can add
	# a way to install additional schemas in standard manner - this is it.
	# $1 = SQL pathname
	# $2 = comment to echo
	local INITSQL="$1"
	local COMMENT="$2"

	case "$INSTSQL_DIR" in
		/*) [ -d "$INSTSQL_DIR" ] || { \
			echo "Creating INSTSQL_DIR='$INSTSQL_DIR' to save copies of applied SQL files..."; \
			mkdir -p "$INSTSQL_DIR"; }
		    [ ! -d "$INSTSQL_DIR" -o ! -w "$INSTSQL_DIR" ] && \
			echo "WARNING: Can not use INSTSQL_DIR='$INSTSQL_DIR', copies of applied SQL files will not be stashed" && \
			INSTSQL_DIR=""
		    ;;
		"") echo "WARNING: Empty INSTSQL_DIR provided, copies of applied SQL files will not be stashed" ;;
		*)  echo "ERROR: Non-absolute INSTSQL_DIR='$INSTSQL_DIR' provided, copies of applied SQL files will not be stashed"
		    INSTSQL_DIR=""
		    ;;
	esac

	if  [ -r "$INITSQL" ] && \
	    [ -s "$INITSQL" ] \
	; then
		echo "Database for BIOS initialization - importing $COMMENT `basename $INITSQL`..."
		do_mysql < "$INITSQL" || return 1
		SQLINSTALL_SCHEMA_VERSION="v=`grep_sql_version < "$INITSQL"`." || BIOS_SCHEMA_VERSION_SQL=""
		[ -n "$INSTSQL_DIR" ] && [ -d "$INSTSQL_DIR" ] && \
			gzip -c < "$INITSQL" > "$INSTSQL_DIR/`basename "$INITSQL"`.$SQLINSTALL_SCHEMA_VERSION$SQLINSTALL_TIMESTAMP.gz"
		return 0
	else
		echo "Error: Can't read '$INITSQL' !!!" >&2
		return 1
	fi
}

generate_database() {
	local INITSQL=""
	# Imports the BIOS database files, sets up and saves passwords
	install_sql_file "$INITSQL_FIRST" "base schema" || return $?

	secure_database

	for INITSQL in $(ls -1 "${INITSQL_DIR}"/*.sql | grep -v "`basename $INITSQL_FIRST`" | sort) ; do
		install_sql_file "$INITSQL" "extra schema" || return $?
	done

	echo "Database for BIOS initialization - completed the schema import and password generation"
	return 0
}

upgrade_database() {
    # Parameters: $1 refers to full filename of new SQL data file
	local SQL_FILE="$1"
    # If there is no parameter, use first initialization sql script
	[ -z "$SQL_FILE" ] && SQL_FILE="$INITSQL_FIRST"
    # Get file base name without the path
	local SQL_FILE_BASENAME="`basename "$SQL_FILE"`"
    # If we got only basename of the file, we will SUPPOSE that it is in the default directory
	[ x"$SQL_FILE" = x"$SQL_FILE_BASENAME" ] && SQL_FILE="$INITSQL_DIR/$SQL_FILE_BASENAME"

	if [ -s "${UPGRADE_POLICY_FILE}" ]; then
		# TODO: Maybe later parse per-schema "sqlbasename: policy"
		# lines vs. the default policy in first line
		UPGRADE_POLICY="`head -1 "${UPGRADE_POLICY_FILE}"`" || \
		UPGRADE_POLICY="required"
	fi

	if [ "${UPGRADE_POLICY}" = skip ] ; then
		echo "WARNING: Database upgrade is disabled since policy is '$UPGRADE_POLICY' and so we proceed..." >&2
		return 0
	fi

    # TODO The method may depend on "${UPGRADE_POLICY}" ...
    install_sql_file "$SQL_FILE" "applying patch '${SQL_FILE}'" || return $?

    # Currently we prohibit service startup with inconsistent database,
    # so exit at this point and force a human to take a look at it
	if [ "${UPGRADE_POLICY}" = not-required ]; then
		echo "WARNING: Database upgrade failed, but policy is '$UPGRADE_POLICY' and so we proceed..." >&2
		return 0
	fi

	return 0
}

grep_sql_version() {
	# Prints e.g. 20151015 from stddin that contains
    # ASSUMPTION: every sql file SHOULD contain the string according the following TEMPLATE
	# SET @bios_db_schema_version = '20151015' ;
	egrep -i '^[ \t]*set[ \t]+@bios_db_schema_version[ \t]*=' | head -1 | \
	sed -e 's,^.*[ \t]*=[ \t]*\(.*\)[ \t]*;$,\1,' \
		-e 's,^"\(.*\)"$,\1,' -e "s,^'\(.*\)'.*$,\1,"
}

ensure_root_password() {
	if [ -z "`echo "select 'working';" | do_mysql | grep working`" ]; then
		if [ -z "`echo "select 'working';" | do_mysql --password='' | grep working`" ]; then
			if [ -n "$MYSQL_ROOT_PASSWD" ] && [ -n "`echo "select 'working';" | do_mysql --password="$MYSQL_ROOT_PASSWD" | grep working`" ]; then
				rm -f "$MYCNF"  # Reset access rights, if unsecured earlier
				printf '[client]\nuser=root\npassword=%s\n' "${MYSQL_ROOT_PASSWD}" > "$MYCNF" && \
				rm -f /etc/default/mysql-root-passwd
				chmod 600 "$MYCNF"
			else
				echo "Error: Can't connect to database" >&2
				return 1
			fi
		else
			echo "Config files inconsistent: really MYSQL root password is empty (database recreated?)"
			MYSQL_ROOT_PASSWD_FLAG='--password='
		fi
	fi

	if [ ! -s "$MYCNF" ] || [ x"$MYSQL_ROOT_PASSWD_FLAG" = x"--password=" ]; then
		# ~/.my.cnf missing or empty, or password was detected as empty
		# Note this structure allows a .my.cnf to specify password=''
		echo "Database for BIOS - generating MySQL root password instead of corrupt/empty value..."
		# Just in case, avoid weird chars in the password
		ROOT_PW="`random_password`"
		cat << EOF | do_mysql $MYSQL_ROOT_PASSWD_FLAG
SET PASSWORD = PASSWORD('$ROOT_PW');
FLUSH PRIVILEGES;
EOF
		[ $? != 0 ] && echo "Error setting MySQL root password" >&2 && return 1

		rm -f "$MYCNF"  # Reset access rights, if unsecured earlier
		printf '[client]\nuser=root\npassword=%s\n' "${ROOT_PW}" > "$MYCNF"
		chmod 600 "$MYCNF"
	else
		echo "Database for BIOS - not touching MySQL root password - previous value remains in place..."
	fi
	return 0
}

verify_schema_version() {
	# For full filename path referenced by $1, checks presence and
	# consistency of versions set by the base filename (in DB) and
	# against the version specified in the SQL file itself
	# If "$1" is just a short name (e.g. coming from database) and is
	# missing in INITSQL_DIR we do not compare against in-file version.
	local SQL_FILE="$1"
	[ -z "$SQL_FILE" ] && SQL_FILE="$INITSQL_FIRST"
	local SQL_FILE_BASENAME="`basename "$SQL_FILE"`"
	[ x"$SQL_FILE" = x"$SQL_FILE_BASENAME" ] && SQL_FILE="$INITSQL_DIR/$SQL_FILE_BASENAME"

	# Verify that our SQL file has the information about it's version
    # So verify, if this file fulfills the ASSUMPTION
	local SCHEMA_VERSION_SQL=""
	if [ -r "$SQL_FILE" ] && [ -s "$SQL_FILE" ] \
	; then
		SCHEMA_VERSION_SQL="`grep_sql_version < "$SQL_FILE"`"
    fi
	if [ -z "$SCHEMA_VERSION_SQL" ]; then
		echo "ERROR: File '$SQL_FILE' is in the inconsistent state, because it doesn't contain the string 'SET @bios_db_schema_version = 'YYYYMMDD' '" >&2
        # this error should not appear on the customer side, unless someone touch sql files
        # abort immidiately
        exit 2
    fi

    # Select import tags from database
	local SCHEMA_VERSION_DB_1=$(exec_sql_db "SELECT version FROM t_bios_schema_version WHERE tag='begin-import' AND filename='$SQL_FILE_BASENAME' ORDER BY id DESC LIMIT 1;") || \
		SCHEMA_VERSION_DB_1="begin-NA"
	local SCHEMA_VERSION_DB_2=$(exec_sql_db "SELECT version FROM t_bios_schema_version WHERE tag='finish-import' AND filename='$SQL_FILE_BASENAME' ORDER BY id DESC LIMIT 1;") || \
		SCHEMA_VERSION_DB_2="finish-NA"

    # Verify if this database and version information are available
	if [ x"$SCHEMA_VERSION_DB_1" = x"begin-NA" ] || \
	   [ x"$SCHEMA_VERSION_DB_2" = x"finish-NA" ] \
	; then
		echo "ERROR: 1. Mysql is not running or 2. There are problems with t_bios_schema_version table. Fix them manually" >&2
		return 2
    fi

    # Verify if this particular file wasn't imported yet at all
	if [ -z "$SCHEMA_VERSION_DB_1" ] && \
	   [ -z "$SCHEMA_VERSION_DB_2" ] \
	; then
		echo "File '$SQL_FILE' wasn't imported yet, import it now"
		upgrade_database "$SQL_FILE"
		return $?
    fi

	# Verify that begin-import and finish-import version tags are the same
    if [ x"$SCHEMA_VERSION_DB_1" != x"$SCHEMA_VERSION_DB_2" ] || \
       [ -z "$SCHEMA_VERSION_DB_1" ] || [ -z "$SCHEMA_VERSION_DB_2" ] \
    ; then
        echo "Error: Schema version for '$SQL_FILE' is not consistent in the database ('$SCHEMA_VERSION_DB_1' vs '$SCHEMA_VERSION_DB_2'). Investigate and fix it manually" >&2
        # abort immidiately
        exit 2
	fi

    # Verify if version of the file is the same as version of the file in the database
	if [ x"$SCHEMA_VERSION_DB_2" != x"$SCHEMA_VERSION_SQL" ]; then
		echo "Error: Schema version for '$SQL_FILE' in the database is not the same as in current SQL schema file ('$SCHEMA_VERSION_DB_2' vs '$SCHEMA_VERSION_SQL')" >&2
        echo "NOT IMPLEMENTED"
        # abort immidiately
        exit 2
	fi

	echo "Schema component '$SQL_FILE' version '$SCHEMA_VERSION_DB_2' is up-to-date"
    return 0
}

ensure_root_password || exit $?
case "${BIOS_DB_INIT-}" in
	generate|initialize|flush|init) generate_database; exit $? ;;
	upgrade|update) upgrade_database; exit $? ;;
esac

# From here on, the mysql client should rely on ~/.my.cnf
# so no extra password params are needed
if [ -z "`exec_sql 'show databases;' | egrep '^'"${DATABASE}"'$'`" ]; then
	generate_database
	exit $?         # Success or failure - we exit here anyway
else
	# Just make sure user passwords are okay
	secure_database
fi

# If there are any consistency checks to run on the database -
# e.g. to detect botched imports, need of upgrades, etc. - do it here
# Here we pick basenames from foth INITSQL_DIR and database, and also
# make sure to verify INITSQL_FIRST (whether the file exists or not)
for F in "$INITSQL_FIRST" `{ ls -1 "${INITSQL_DIR}"/*.sql | sed 's,^.*/\([^\/]*$\),\1,'; exec_sql_db 'SELECT DISTINCT filename FROM t_bios_schema_version;' ; }  | sort | uniq | grep -v "$(basename $INITSQL_FIRST)"` ; do
	verify_schema_version "$F" || exit $?
done

echo "Database for BIOS - found and deemed sufficient"
exit 0
