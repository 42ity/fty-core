/* json_schemas.h: json validation helpers generator
 
Copyright (C) 2014 Eaton
 
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or
(at your option) any later version.
 
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
 
You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

/*
Author(s): Karol Hrdina <karolhrdina@eaton.com>
 
Description: generator of automated json validator using libvirt
References: BIOS-347, BIOS-377
*/

#ifndef utils_messages_json_schemas_H__
#define utils_messages_json_schemas_H__

#include <string>
#include <map>

#include <Variant/Variant.h>
#include <Variant/Schema.h>

namespace utils {
	namespace json {

inline const std::string& IncompleteStringMessage() {
  static std::string ret = {
  0x7b, 0x0a, 0x22, 0x24, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x22, 0x20,
  0x3a, 0x20, 0x22, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x6a, 0x73,
  0x6f, 0x6e, 0x2d, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x2e, 0x6f, 0x72,
  0x67, 0x2f, 0x64, 0x72, 0x61, 0x66, 0x74, 0x2d, 0x30, 0x34, 0x2f, 0x73,
  0x63, 0x68, 0x65, 0x6d, 0x61, 0x23, 0x22, 0x2c, 0x0a, 0x22, 0x74, 0x79,
  0x70, 0x65, 0x22, 0x20, 0x3a, 0x20, 0x22, 0x6f, 0x62, 0x6a, 0x65, 0x63,
  0x74, 0x22, 0x2c, 0x0a, 0x22, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74,
  0x69, 0x65, 0x73, 0x22, 0x20, 0x3a, 0x20, 0x7b, 0x0a, 0x20, 0x20, 0x20,
  0x20, 0x22, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x22, 0x20, 0x3a, 0x20,
  0x7b, 0x20, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x20, 0x3a, 0x20, 0x22,
  0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x22, 0x2c, 0x20, 0x22, 0x6d, 0x75,
  0x6c, 0x74, 0x69, 0x70, 0x6c, 0x65, 0x4f, 0x66, 0x22, 0x20, 0x3a, 0x20,
  0x31, 0x2e, 0x30, 0x2c, 0x20, 0x22, 0x6d, 0x69, 0x6e, 0x75, 0x6d, 0x75,
  0x6d, 0x22, 0x20, 0x3a, 0x20, 0x31, 0x2c, 0x20, 0x22, 0x65, 0x6e, 0x75,
  0x6d, 0x22, 0x20, 0x3a, 0x20, 0x5b, 0x20, 0x31, 0x20, 0x5d, 0x20, 0x7d,
  0x2c, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6e,
  0x67, 0x22, 0x20, 0x3a, 0x20, 0x7b, 0x20, 0x22, 0x74, 0x79, 0x70, 0x65,
  0x22, 0x20, 0x3a, 0x20, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22,
  0x20, 0x7d, 0x0a, 0x7d, 0x0a, 0x7d, 0x0a
  };
  return ret; 
}

inline const std::string& NaturalNumMessage() {
  static std::string ret = {
  0x7b, 0x0a, 0x22, 0x24, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x22, 0x20,
  0x3a, 0x20, 0x22, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x6a, 0x73,
  0x6f, 0x6e, 0x2d, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x2e, 0x6f, 0x72,
  0x67, 0x2f, 0x64, 0x72, 0x61, 0x66, 0x74, 0x2d, 0x30, 0x34, 0x2f, 0x73,
  0x63, 0x68, 0x65, 0x6d, 0x61, 0x23, 0x22, 0x2c, 0x0a, 0x22, 0x74, 0x79,
  0x70, 0x65, 0x22, 0x20, 0x3a, 0x20, 0x22, 0x6f, 0x62, 0x6a, 0x65, 0x63,
  0x74, 0x22, 0x2c, 0x0a, 0x22, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74,
  0x69, 0x65, 0x73, 0x22, 0x20, 0x3a, 0x20, 0x7b, 0x0a, 0x20, 0x20, 0x20,
  0x20, 0x22, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x22, 0x20, 0x3a, 0x20,
  0x7b, 0x20, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x20, 0x3a, 0x20, 0x22,
  0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x22, 0x2c, 0x20, 0x22, 0x6d, 0x75,
  0x6c, 0x74, 0x69, 0x70, 0x6c, 0x65, 0x4f, 0x66, 0x22, 0x20, 0x3a, 0x20,
  0x31, 0x2e, 0x30, 0x2c, 0x20, 0x22, 0x6d, 0x69, 0x6e, 0x75, 0x6d, 0x75,
  0x6d, 0x22, 0x20, 0x3a, 0x20, 0x31, 0x2c, 0x20, 0x22, 0x65, 0x6e, 0x75,
  0x6d, 0x22, 0x20, 0x3a, 0x20, 0x5b, 0x20, 0x32, 0x20, 0x5d, 0x20, 0x7d,
  0x2c, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x22, 0x6e, 0x61, 0x74, 0x75, 0x72,
  0x61, 0x6c, 0x22, 0x20, 0x3a, 0x20, 0x7b, 0x20, 0x22, 0x74, 0x79, 0x70,
  0x65, 0x22, 0x20, 0x3a, 0x20, 0x22, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72,
  0x22, 0x2c, 0x20, 0x22, 0x6d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x65,
  0x4f, 0x66, 0x22, 0x20, 0x3a, 0x20, 0x31, 0x2e, 0x30, 0x2c, 0x20, 0x22,
  0x6d, 0x69, 0x6e, 0x69, 0x6d, 0x75, 0x6d, 0x22, 0x20, 0x3a, 0x20, 0x30,
  0x20, 0x7d, 0x0a, 0x7d, 0x2c, 0x0a, 0x22, 0x72, 0x65, 0x71, 0x75, 0x69,
  0x72, 0x65, 0x64, 0x22, 0x20, 0x3a, 0x20, 0x5b, 0x20, 0x22, 0x73, 0x63,
  0x68, 0x65, 0x6d, 0x61, 0x22, 0x2c, 0x20, 0x22, 0x6e, 0x61, 0x74, 0x75,
  0x72, 0x61, 0x6c, 0x22, 0x20, 0x5d, 0x2c, 0x0a, 0x22, 0x61, 0x64, 0x64,
  0x69, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x50, 0x72, 0x6f, 0x70, 0x65,
  0x72, 0x74, 0x69, 0x65, 0x73, 0x22, 0x20, 0x3a, 0x20, 0x66, 0x61, 0x6c,
  0x73, 0x65, 0x0a, 0x7d, 0x0a
  };
  return ret; 
}

inline const std::string& NetworkListMessage() {
  static std::string ret = {
  0x7b, 0x0a, 0x22, 0x24, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x22, 0x20,
  0x3a, 0x20, 0x22, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x6a, 0x73,
  0x6f, 0x6e, 0x2d, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x2e, 0x6f, 0x72,
  0x67, 0x2f, 0x64, 0x72, 0x61, 0x66, 0x74, 0x2d, 0x30, 0x34, 0x2f, 0x73,
  0x63, 0x68, 0x65, 0x6d, 0x61, 0x23, 0x22, 0x2c, 0x0a, 0x22, 0x74, 0x79,
  0x70, 0x65, 0x22, 0x20, 0x3a, 0x20, 0x22, 0x6f, 0x62, 0x6a, 0x65, 0x63,
  0x74, 0x22, 0x2c, 0x0a, 0x22, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74,
  0x69, 0x65, 0x73, 0x22, 0x20, 0x3a, 0x20, 0x7b, 0x0a, 0x20, 0x20, 0x22,
  0x73, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x22, 0x20, 0x3a, 0x20, 0x7b, 0x20,
  0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x20, 0x3a, 0x20, 0x22, 0x6e, 0x75,
  0x6d, 0x62, 0x65, 0x72, 0x22, 0x2c, 0x20, 0x22, 0x6d, 0x75, 0x6c, 0x74,
  0x69, 0x70, 0x6c, 0x65, 0x4f, 0x66, 0x22, 0x20, 0x3a, 0x20, 0x31, 0x2e,
  0x30, 0x2c, 0x20, 0x22, 0x6d, 0x69, 0x6e, 0x75, 0x6d, 0x75, 0x6d, 0x22,
  0x20, 0x3a, 0x20, 0x31, 0x2c, 0x20, 0x22, 0x65, 0x6e, 0x75, 0x6d, 0x22,
  0x20, 0x3a, 0x20, 0x5b, 0x20, 0x33, 0x20, 0x5d, 0x20, 0x7d, 0x2c, 0x0a,
  0x20, 0x20, 0x22, 0x72, 0x63, 0x2d, 0x69, 0x64, 0x22, 0x20, 0x3a, 0x20,
  0x7b, 0x20, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x20, 0x3a, 0x20, 0x22,
  0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x22, 0x2c, 0x20, 0x22, 0x6d, 0x75,
  0x6c, 0x74, 0x69, 0x70, 0x6c, 0x65, 0x4f, 0x66, 0x22, 0x20, 0x3a, 0x20,
  0x31, 0x2e, 0x30, 0x20, 0x7d, 0x2c, 0x0a, 0x20, 0x20, 0x22, 0x6e, 0x65,
  0x74, 0x77, 0x6f, 0x72, 0x6b, 0x73, 0x22, 0x20, 0x3a, 0x20, 0x7b, 0x0a,
  0x20, 0x20, 0x20, 0x20, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x20, 0x3a,
  0x20, 0x22, 0x61, 0x72, 0x72, 0x61, 0x79, 0x22, 0x2c, 0x0a, 0x20, 0x20,
  0x20, 0x20, 0x22, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x22, 0x20, 0x3a, 0x20,
  0x7b, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x22, 0x74, 0x79, 0x70,
  0x65, 0x22, 0x20, 0x3a, 0x20, 0x22, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74,
  0x22, 0x2c, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x22, 0x70, 0x72,
  0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x22, 0x20, 0x3a, 0x20,
  0x7b, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x22, 0x74,
  0x79, 0x70, 0x65, 0x22, 0x20, 0x3a, 0x20, 0x7b, 0x20, 0x22, 0x74, 0x79,
  0x70, 0x65, 0x22, 0x20, 0x3a, 0x20, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6e,
  0x67, 0x22, 0x2c, 0x20, 0x22, 0x65, 0x6e, 0x75, 0x6d, 0x22, 0x20, 0x3a,
  0x20, 0x5b, 0x20, 0x22, 0x61, 0x75, 0x74, 0x6f, 0x6d, 0x61, 0x74, 0x69,
  0x63, 0x22, 0x2c, 0x20, 0x22, 0x64, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x64,
  0x22, 0x2c, 0x20, 0x22, 0x6d, 0x61, 0x6e, 0x75, 0x61, 0x6c, 0x22, 0x5d,
  0x20, 0x7d, 0x2c, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x22, 0x6e, 0x61, 0x6d, 0x65, 0x22, 0x20, 0x3a, 0x20, 0x7b, 0x20, 0x22,
  0x74, 0x79, 0x70, 0x65, 0x22, 0x20, 0x3a, 0x20, 0x22, 0x73, 0x74, 0x72,
  0x69, 0x6e, 0x67, 0x22, 0x20, 0x7d, 0x2c, 0x0a, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x22, 0x69, 0x70, 0x76, 0x65, 0x72, 0x22, 0x20,
  0x3a, 0x20, 0x7b, 0x20, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x20, 0x3a,
  0x20, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x2c, 0x20, 0x22,
  0x65, 0x6e, 0x75, 0x6d, 0x22, 0x20, 0x3a, 0x20, 0x5b, 0x20, 0x22, 0x69,
  0x70, 0x76, 0x34, 0x22, 0x2c, 0x20, 0x22, 0x69, 0x70, 0x76, 0x36, 0x22,
  0x20, 0x5d, 0x20, 0x7d, 0x2c, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x22, 0x69, 0x70, 0x61, 0x64, 0x64, 0x72, 0x22, 0x20, 0x3a,
  0x20, 0x7b, 0x20, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x20, 0x3a, 0x20,
  0x22, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x20, 0x7d, 0x2c, 0x0a,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x22, 0x70, 0x72, 0x65,
  0x66, 0x69, 0x78, 0x6c, 0x65, 0x6e, 0x22, 0x20, 0x3a, 0x20, 0x7b, 0x20,
  0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x20, 0x3a, 0x20, 0x22, 0x6e, 0x75,
  0x6d, 0x62, 0x65, 0x72, 0x22, 0x2c, 0x20, 0x22, 0x6d, 0x75, 0x6c, 0x74,
  0x69, 0x70, 0x6c, 0x65, 0x4f, 0x66, 0x22, 0x20, 0x3a, 0x20, 0x31, 0x2e,
  0x30, 0x2c, 0x20, 0x22, 0x6d, 0x69, 0x6e, 0x69, 0x6d, 0x75, 0x6d, 0x22,
  0x20, 0x3a, 0x20, 0x30, 0x2c, 0x20, 0x22, 0x6d, 0x61, 0x78, 0x69, 0x6d,
  0x75, 0x6d, 0x22, 0x20, 0x3a, 0x20, 0x31, 0x32, 0x38, 0x2c, 0x22, 0x65,
  0x78, 0x63, 0x6c, 0x75, 0x73, 0x69, 0x76, 0x65, 0x4d, 0x69, 0x6e, 0x69,
  0x6d, 0x75, 0x6d, 0x22, 0x20, 0x3a, 0x20, 0x74, 0x72, 0x75, 0x65, 0x2c,
  0x20, 0x22, 0x65, 0x78, 0x63, 0x6c, 0x75, 0x73, 0x69, 0x76, 0x65, 0x4d,
  0x61, 0x78, 0x69, 0x6d, 0x75, 0x6d, 0x22, 0x20, 0x3a, 0x20, 0x66, 0x61,
  0x6c, 0x73, 0x65, 0x20, 0x20, 0x7d, 0x2c, 0x0a, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x22, 0x6d, 0x61, 0x63, 0x22, 0x20, 0x3a, 0x20,
  0x7b, 0x20, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x20, 0x3a, 0x20, 0x22,
  0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x2c, 0x20, 0x22, 0x70, 0x61,
  0x74, 0x74, 0x65, 0x72, 0x6e, 0x22, 0x20, 0x3a, 0x20, 0x22, 0x5e, 0x28,
  0x5b, 0x30, 0x2d, 0x39, 0x41, 0x2d, 0x46, 0x61, 0x2d, 0x66, 0x5d, 0x7b,
  0x32, 0x7d, 0x5b, 0x3a, 0x2d, 0x5d, 0x29, 0x7b, 0x35, 0x7d, 0x28, 0x5b,
  0x30, 0x2d, 0x39, 0x41, 0x2d, 0x46, 0x61, 0x2d, 0x66, 0x5d, 0x7b, 0x32,
  0x7d, 0x29, 0x24, 0x22, 0x20, 0x7d, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x7d, 0x2c, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x22, 0x72,
  0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x22, 0x20, 0x3a, 0x20, 0x5b,
  0x20, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x2c, 0x20, 0x22, 0x69, 0x70,
  0x76, 0x65, 0x72, 0x22, 0x2c, 0x20, 0x22, 0x69, 0x70, 0x61, 0x64, 0x64,
  0x72, 0x22, 0x2c, 0x20, 0x22, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x6c,
  0x65, 0x6e, 0x22, 0x20, 0x5d, 0x2c, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x22, 0x61, 0x64, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c,
  0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x22, 0x20,
  0x3a, 0x20, 0x66, 0x61, 0x6c, 0x73, 0x65, 0x0a, 0x20, 0x20, 0x20, 0x20,
  0x7d, 0x0a, 0x20, 0x20, 0x7d, 0x0a, 0x7d, 0x2c, 0x0a, 0x22, 0x72, 0x65,
  0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x22, 0x20, 0x3a, 0x20, 0x5b, 0x20,
  0x22, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x22, 0x2c, 0x20, 0x22, 0x72,
  0x63, 0x2d, 0x69, 0x64, 0x22, 0x2c, 0x20, 0x22, 0x6e, 0x65, 0x74, 0x77,
  0x6f, 0x72, 0x6b, 0x73, 0x22, 0x5d, 0x2c, 0x0a, 0x22, 0x61, 0x64, 0x64,
  0x69, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x50, 0x72, 0x6f, 0x70, 0x65,
  0x72, 0x74, 0x69, 0x65, 0x73, 0x22, 0x20, 0x3a, 0x20, 0x66, 0x61, 0x6c,
  0x73, 0x65, 0x0a, 0x7d, 0x0a
  };
  return ret; 
}

inline const std::string& StringMessage() {
  static std::string ret = {
  0x7b, 0x0a, 0x22, 0x24, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x22, 0x20,
  0x3a, 0x20, 0x22, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x6a, 0x73,
  0x6f, 0x6e, 0x2d, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x2e, 0x6f, 0x72,
  0x67, 0x2f, 0x64, 0x72, 0x61, 0x66, 0x74, 0x2d, 0x30, 0x34, 0x2f, 0x73,
  0x63, 0x68, 0x65, 0x6d, 0x61, 0x23, 0x22, 0x2c, 0x0a, 0x22, 0x74, 0x79,
  0x70, 0x65, 0x22, 0x20, 0x3a, 0x20, 0x22, 0x6f, 0x62, 0x6a, 0x65, 0x63,
  0x74, 0x22, 0x2c, 0x0a, 0x22, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74,
  0x69, 0x65, 0x73, 0x22, 0x20, 0x3a, 0x20, 0x7b, 0x0a, 0x20, 0x20, 0x20,
  0x20, 0x22, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x22, 0x20, 0x3a, 0x20,
  0x7b, 0x20, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x20, 0x3a, 0x20, 0x22,
  0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x22, 0x2c, 0x20, 0x22, 0x6d, 0x75,
  0x6c, 0x74, 0x69, 0x70, 0x6c, 0x65, 0x4f, 0x66, 0x22, 0x20, 0x3a, 0x20,
  0x31, 0x2e, 0x30, 0x2c, 0x20, 0x22, 0x6d, 0x69, 0x6e, 0x75, 0x6d, 0x75,
  0x6d, 0x22, 0x20, 0x3a, 0x20, 0x31, 0x2c, 0x20, 0x22, 0x65, 0x6e, 0x75,
  0x6d, 0x22, 0x20, 0x3a, 0x20, 0x5b, 0x20, 0x34, 0x20, 0x5d, 0x20, 0x7d,
  0x2c, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6e,
  0x67, 0x22, 0x20, 0x3a, 0x20, 0x7b, 0x20, 0x22, 0x74, 0x79, 0x70, 0x65,
  0x22, 0x20, 0x3a, 0x20, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22,
  0x20, 0x7d, 0x0a, 0x7d, 0x2c, 0x0a, 0x22, 0x72, 0x65, 0x71, 0x75, 0x69,
  0x72, 0x65, 0x64, 0x22, 0x20, 0x3a, 0x20, 0x5b, 0x20, 0x22, 0x73, 0x63,
  0x68, 0x65, 0x6d, 0x61, 0x22, 0x2c, 0x20, 0x22, 0x73, 0x74, 0x72, 0x69,
  0x6e, 0x67, 0x22, 0x20, 0x5d, 0x2c, 0x0a, 0x22, 0x61, 0x64, 0x64, 0x69,
  0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72,
  0x74, 0x69, 0x65, 0x73, 0x22, 0x20, 0x3a, 0x20, 0x66, 0x61, 0x6c, 0x73,
  0x65, 0x0a, 0x7d, 0x0a
  };
  return ret; 
}


enum class MessageTypesEnum {
	IncompleteString,
	NaturalNum,
	NetworkList,
	String,
UNKNOWN };

const std::map<int, libvariant::Variant>& get_map() {
	static std::map<int, libvariant::Variant> map = {

		std::pair<int, libvariant::Variant>(
			static_cast<int>(MessageTypesEnum::IncompleteString),
			libvariant::DeserializeJSON(utils::json::IncompleteStringMessage().c_str())
		),
		std::pair<int, libvariant::Variant>(
			static_cast<int>(MessageTypesEnum::NaturalNum),
			libvariant::DeserializeJSON(utils::json::NaturalNumMessage().c_str())
		),
		std::pair<int, libvariant::Variant>(
			static_cast<int>(MessageTypesEnum::NetworkList),
			libvariant::DeserializeJSON(utils::json::NetworkListMessage().c_str())
		),
		std::pair<int, libvariant::Variant>(
			static_cast<int>(MessageTypesEnum::String),
			libvariant::DeserializeJSON(utils::json::StringMessage().c_str())
		),

	};
	return map;
}

/*!
\brief 

Detailed description TODO

\param[in] code 
\return MessageTypesEnum 
\see
\author Karol Hrdina <karolhrdina@eaton.com>
*/

MessageTypesEnum codetable(unsigned int code) {
	switch(code) {

	case 1:
	{
		return MessageTypesEnum::IncompleteString;
		break;
	}
	case 2:
	{
		return MessageTypesEnum::NaturalNum;
		break;
	}
	case 3:
	{
		return MessageTypesEnum::NetworkList;
		break;
	}
	case 4:
	{
		return MessageTypesEnum::String;
		break;
	}
	default:
		return MessageTypesEnum::UNKNOWN;
		break;
	}
}

/*!
\brief

Detailed description TODO

\param[in] message_type 

\return MessageTypesEnum

\author Karol Hrdina <karolhrdina@eaton.com>
*/

unsigned int enumtable(MessageTypesEnum message_type) {
	switch(message_type) {

	case MessageTypesEnum::IncompleteString:
	{
		return 1;
		break;
	}
	case MessageTypesEnum::NaturalNum:
	{
		return 2;
		break;
	}
	case MessageTypesEnum::NetworkList:
	{
		return 3;
		break;
	}
	case MessageTypesEnum::String:
	{
		return 4;
		break;
	}
	default:
		return 0;
		break;
	}
}

enum class ValidateResultEnum {
	Valid,
	Invalid,
	SchemaError
};


/*!
\brief Perform validation of json string against a given "message type" (i.e.
given json schema) and deserialize the json string

\param[in]  json					 json string to be validated
\param[in]  message_type  message type to validate the json string against  
\param[out] root					 deserialized json string			 
\param[out] strerr				 error string

\return If successfull, return ValidateResultEnum::Valid and assign
deserialized json string into 'root' parameter.
Otherwise, return either ValidateResultEnum::Invalid (in case of input
json string being invalid) or ValidateResultEnum::SchemaError (in case
of syntax error in json schema of the given message type) and assign error string
to strerr parameter.

\author Karol Hrdina <karolhrdina@eaton.com>
*/

ValidateResultEnum
validate_parse(
const char *json,
MessageTypesEnum message_type,
libvariant::VariantRef root,
std::string& strerr) {
	if (json == NULL) {
		return ValidateResultEnum::Invalid;
	}
	root = libvariant::DeserializeJSON(json);
	libvariant::SchemaResult sr = SchemaValidate(
		utils::json::get_map().at(static_cast<int>(message_type)),
		root);
	if(sr.SchemaErrors()) {
		strerr.assign(sr.PrettyPrintMessage());
		return ValidateResultEnum::SchemaError;
	}
	if (sr.ValidationErrors()) {
		strerr.assign(sr.PrettyPrintMessage());
		return ValidateResultEnum::Invalid;
	}
	return ValidateResultEnum::Valid;
}


/*!
\brief Perform validation of json string against a given "message type" (i.e.
given json schema) and deserialize the json string

\param[in]  json					 json string to be validated
\param[in]  message_type  message type to validate the json string against  
\param[out] root					 deserialized json string			 

\return If successfull, return ValidateResultEnum::Valid and assign
deserialized json string into 'root' parameter.
Otherwise, return either ValidateResultEnum::Invalid (in case of input
json string being invalid) or ValidateResultEnum::SchemaError (in case
of syntax error in json schema of the given message type).

\author Karol Hrdina <karolhrdina@eaton.com>
*/

ValidateResultEnum
validate_parse(
const char *json,
MessageTypesEnum message_type,
libvariant::VariantRef root) {
	if (json == NULL) {
		return ValidateResultEnum::Invalid;
	}
	root = libvariant::DeserializeJSON(json);
	libvariant::SchemaResult sr = SchemaValidate(
		utils::json::get_map().at(static_cast<int>(message_type)),
		root);
	if(sr.SchemaErrors()) {
		return ValidateResultEnum::SchemaError;
	}
	if (sr.ValidationErrors()) {
		return ValidateResultEnum::Invalid;
	}
	return ValidateResultEnum::Valid;
}


/*!
\brief Perform validation of deserialized json against a given "message type" (i.e.
given json schema).

\param[in]  json					 json string to be validated
\param[in]  message_type  message type to validate the json string against  
\param[out] strerr				 error string

\return If successfull, return ValidateResultEnum::Valid.
Otherwise, return either ValidateResultEnum::Invalid (in case of input
json string being invalid) or ValidateResultEnum::SchemaError (in case
of syntax error in json schema of the given message type) and assign error string
to strerr parameter.

\author Karol Hrdina <karolhrdina@eaton.com>
*/

ValidateResultEnum
validate(
const char *json,
MessageTypesEnum message_type,
std::string& strerr) {
	if (json == NULL) {
		return ValidateResultEnum::Invalid;
	}
	libvariant::Variant temp = libvariant::DeserializeJSON(json);
	libvariant::SchemaResult sr = SchemaValidate(
		utils::json::get_map().at(static_cast<int>(message_type)),
		temp);
	if(sr.SchemaErrors()) {
		strerr.assign(sr.PrettyPrintMessage());
		return ValidateResultEnum::SchemaError;
	}
	if (sr.ValidationErrors()) {
		strerr.assign(sr.PrettyPrintMessage());
		return ValidateResultEnum::Invalid;
	}
	return ValidateResultEnum::Valid;
}


/*!
\brief Perform validation of json string against a given "message type" (i.e.
given json schema).

\param[in]  json					 json string to be validated
\param[in]  message_type  message type to validate the json string against
  
\return If successfull, return ValidateResultEnum::Valid.
Otherwise, return either ValidateResultEnum::Invalid (in case of input
json string being invalid) or ValidateResultEnum::SchemaError (in case
of syntax error in json schema of the given message type)

\author Karol Hrdina <karolhrdina@eaton.com>
*/

ValidateResultEnum
validate(
const char *json,
MessageTypesEnum message_type) {
	if (json == NULL) {
		return ValidateResultEnum::Invalid;
	}
	libvariant::Variant temp = libvariant::DeserializeJSON(json);
	libvariant::SchemaResult sr = SchemaValidate(
		utils::json::get_map().at(static_cast<int>(message_type)),
		temp);
	if(sr.SchemaErrors()) {
		return ValidateResultEnum::SchemaError;
	}
	if (sr.ValidationErrors()) {
		return ValidateResultEnum::Invalid;
	}
	return ValidateResultEnum::Valid;
}












	} // namespace json
} // namespace utils
#endif // utils_messages_json_schemas_H__

