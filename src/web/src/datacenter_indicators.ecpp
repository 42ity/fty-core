<%pre>
#include <czmq.h>
#include <cxxtools/split.h>
#include <stdexcept>

#include "asset_msg.h"
#include "assetcrud.h"
#include "data.h"
#include "calc_power.h"
#include "dbpath.h"
#include "cleanup.h"
#include "db/measurements.h"

static const std::map<const std::string, const std::string> PARAM_TO_SRC = {
    {"power", "realpower.default"},
    {"avg_power_last_day", "realpower.default_arithmetic_mean_24h"},
    {"avg_power_last_week", "<zero>"},
    {"avg_power_last_month", "<zero>"},

    {"min_power_last_day", "<zero>"},
    {"min_power_last_week", "<zero>"},
    {"min_power_last_month", "<zero>"},

    {"max_power_last_day", "<zero>"},
    {"max_power_last_week", "<zero>"},
    {"max_power_last_month", "<zero>"},

    {"trend_power_last_day", "realpower.default_arithmetic_mean_24h/realpower.default"},
    {"trend_power_last_week", "<zero>"},
    {"trend_power_last_month", "<zero>"},

    {"temperature", "temperature.TH%"},
    {"avg_temperature_last_day", "<zero>"},
    {"avg_temperature_last_week", "<zero>"},
    {"avg_temperature_last_month", "<zero>"},

    {"min_temperature_last_day", "<zero>"},
    {"min_temperature_last_week", "<zero>"},
    {"min_temperature_last_month", "<zero>"},

    {"max_temperature_last_day", "<zero>"},
    {"max_temperature_last_week", "<zero>"},
    {"max_temperature_last_month", "<zero>"},

    {"trend_temperature_last_day", "<zero>"},
    {"trend_temperature_last_week", "<zero>"},
    {"trend_temperature_last_month", "<zero>"},

    {"humidity", "humidity.TH%"},
    {"avg_humidity_last_day", "<zero>"},
    {"avg_humidity_last_week", "<zero>"},
    {"avg_humidity_last_month", "<zero>"},

    {"min_humidity_last_day", "<zero>"},
    {"min_humidity_last_week", "<zero>"},
    {"min_humidity_last_month", "<zero>"},

    {"max_humidity_last_day", "<zero>"},
    {"max_humidity_last_week", "<zero>"},
    {"max_humidity_last_month", "<zero>"},

    {"trend_humidity_last_day", "<zero>"},
    {"trend_humidity_last_week", "<zero>"},
    {"trend_humidity_last_month", "<zero>"}
};

float
get_dc_trend(
    tntdb::Connection& conn,
    const std::string& src,
    a_elmnt_id_t id)
{
    if (src == "<zero>")
        return 0.0f;

    std::vector<std::string> items;
    cxxtools::split('/', src, std::back_inserter(items));
    if( items.size() != 2 ) return 0.0f;

    m_msrmnt_value_t avg;
    m_msrmnt_scale_t avg_scale;
    m_msrmnt_value_t actual;
    m_msrmnt_scale_t actual_scale;
    auto reply_avg = persist::select_measurement_last_web_byElementId(conn, items.at(0), id, avg, avg_scale, 48*60);
    auto reply = persist::select_measurement_last_web_byElementId(conn, items.at(1), id, actual, actual_scale);

    if (reply.rv != 0 || reply_avg.rv != 0)
        return 0.0f;

    if( avg == 0 ) return 0.0f;
    // TODO: remove it afterdemo
    return   ( (int) ((actual * pow(10,actual_scale) - avg * pow(10,avg_scale) ) *1000 / ( avg * pow(10,avg_scale) ))) / 1000;
    // this is correct variant
    //return (actual * pow(10,actual_scale) - avg * pow(10,avg_scale) ) / ( avg * pow(10,avg_scale) );
}

float
get_dc_percentage(
    tntdb::Connection& conn,
    const std::string& src,
    a_elmnt_id_t id)
{
    reply_t reply;
    m_msrmnt_value_t value;
    m_msrmnt_scale_t scale;
    
    reply = persist::select_measurement_last_web_byTopic(conn, src, value, scale);
    if (reply.rv != 0)
        return 0.0f;
    return value * pow(10,scale);
}

float
get_dc_measurement(
    tntdb::Connection& conn,
    const std::string& src,
    a_elmnt_id_t id,
    int minutes_back)
{
    reply_t reply;
    m_msrmnt_value_t value;
    m_msrmnt_scale_t scale;
    
    reply = persist::select_measurement_last_web_byElementId(conn, src, id, value, scale, minutes_back);
    if (reply.rv != 0)
        return 0.0f;
    return value * pow(10,scale);
}


float
get_dc_indicator(
    tntdb::Connection& conn,
    const std::string& key,
    a_elmnt_id_t id)
{
    const std::string& src = PARAM_TO_SRC.at(key); //XXX: operator[] does not work here!
    if (src == "<zero>")
        return 0.0f;


    m_msrmnt_value_t value;
    m_msrmnt_scale_t scale;
    reply_t reply;
    if (key.substr(0,5) == "trend") return get_dc_trend(conn, src, id);
    if (src.find('%') != std::string::npos) return get_dc_percentage(conn, src, id);
    if (src.find("24h") != std::string::npos) return get_dc_measurement(conn, src, id, 24*60+5);
    return get_dc_measurement(conn, src, id, 10);
}

static bool
s_is_valid_param(const std::string& p)
{
    return PARAM_TO_SRC.count(p) != 0;
}


</%pre>
<%args>
std::string arg1;
std::string arg2;
</%args>
<%thread scope="global">
asset_manager asset_mgr;
</%thread>
<%cpp>
    // Check URL validity
    if( arg1 == "" || arg2 == "" ) {
</%cpp>
{ "error":"bad_input", "msg":"missing argument" }
<%cpp>
        return HTTP_BAD_REQUEST;
    }
    std::vector<std::string> DCs;
    std::vector<std::string> DCNames;
    std::vector<std::string> requestedParams;
    cxxtools::split(",", arg1, std::back_inserter(DCs));
    
    // check that DC exists
    auto allDcsShort= asset_mgr.get_items1("datacenter");
    if ( allDcsShort.status == 0 )
    {
        // TODO better error handling by types
</%cpp>
{ "error":"internal error", "msg":"while reading information about dcs"}
<%cpp>
        return HTTP_INTERNAL_SERVER_ERROR;   
    }
    for ( size_t i = 0; i < DCs.size() ; i++ )
    {
        // TODO add better converter
        uint32_t real_id = atoi(DCs[i].c_str());
        if ( real_id == 0 )
        {
</%cpp>
{ "error":"bad_input", "msg":"invalid dc id <$$ DCs[i]$> (can not convert)"}
<%cpp>
            return HTTP_BAD_REQUEST;
        }

        auto it = allDcsShort.item.find(real_id);
        if ( it != allDcsShort.item.end() )
        {
            DCNames.push_back(it->second);
        }
        else
        {
</%cpp>
{ "error":"bad_input", "msg":"invalid dc id <$$ DCs[i]$> (doesn't exist)"}
<%cpp>
            return HTTP_BAD_REQUEST;
        }
    }

    cxxtools::split(",", arg2, std::back_inserter(requestedParams));
    for(std::string &param: requestedParams) {
        if ( !s_is_valid_param(param) ) {
</%cpp>
{"error":"bad_input", "msg":"invalid parameter" }
<%cpp>
            return HTTP_BAD_REQUEST;
        }
    }

    std::stringstream json;
try {
    // TODO this can throw exceptions!!
    tntdb::Connection conn = tntdb::connectCached (url);
    json << "{\n\t\"datacenter_indicators\": [\n";
    for( size_t D = 0 ; D < DCs.size(); D++ ) {
        json << "\t\t{\n"
             << "\t\t\t\"id\": \"" << DCs[D] << "\",\n"
             << "\t\t\t\"name\": \"" << DCNames[D] << "\",\n";
        for(size_t P = 0; P < requestedParams.size(); P++ ) {
           const std::string& key = requestedParams[P];
           json  << "\t\t\t\"" << key << "\": "<< get_dc_indicator(conn, key, atoi( DCs[D].c_str() ) );
           json <<  ( ( P < requestedParams.size() - 1 ) ? "," : "" ) << "\n";
        }
        json << "\t\t}" << (  D < DCs.size() -1 ? ",\n" : "\n" );
    }
    json << "\t]\n}\n";
} catch ( const std::invalid_argument& e ) {
</%cpp>
    { "error" : "<$$ e.what()$>" }
<%cpp>
      return HTTP_BAD_REQUEST;
}
catch ( const std::exception& e ) {
</%cpp>
    <h1>internal server error</h1>
    <$ e.what() $>
<%cpp>      
      return HTTP_INTERNAL_SERVER_ERROR;   
}
</%cpp>
<$$ json.str() $>
