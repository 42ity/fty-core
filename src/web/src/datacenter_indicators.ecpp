<#
 #
 # Copyright (C) 2015 Eaton
 #
 # This program is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation; either version 2 of the License, or
 # (at your option) any later version.
 #
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License along
 # with this program; if not, write to the Free Software Foundation, Inc.,
 # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 #
 #><#
/*!
 * \file datacenter_indicators.ecpp
 * \author Tomas Halman <TomasHalman@Eaton.com>
 * \author Alena Chernikava <AlenaChernikava@Eaton.com>
 * \author Karol Hrdina <KarolHrdina@Eaton.com>
 * \author Michal Vyskocil <MichalVyskocil@Eaton.com>
 * \brief  returns Current values of some metrics for datacenters
 */
 #><%pre>
#include <sys/syscall.h>
#include <stdexcept>
#include <cxxtools/split.h>
#include <malamute.h>
#include <bios_proto.h>

#include <math.h>
#include "data.h"
#include "utils_web.h"
#include "log.h"
#include "helpers.h"

#include "utils++.h"

#define RT_PROVIDER_PEER "agent-rt"
#define RT_SUBJECT "latest-rt-data"
#define MLM_ENDPOINT "ipc://@/malamute"



// ATTENTION!!! for trends:
//  first one should be average, second one is raw measurement
static const std::map<std::string, const std::string> PARAM_TO_SRC {
    {"power", "realpower.default"},
    {"avg_power_last_day", "realpower.default_arithmetic_mean_24h"},
    {"avg_power_last_week", "realpower.default_arithmetic_mean_7d"},
    {"avg_power_last_month", "realpower.default_arithmetic_mean_30d"},

    {"min_power_last_day", "realpower.default_min_24h"},
    {"min_power_last_week", "realpower.default_min_7d"},
    {"min_power_last_month", "realpower.default_min_30d"},

    {"max_power_last_day", "realpower.default_max_24h"},
    {"max_power_last_week", "realpower.default_max_7d"},
    {"max_power_last_month", "realpower.default_max_30d"},

    {"trend_power_last_day", "realpower.default_arithmetic_mean_24h/realpower.default"},
    {"trend_power_last_week", "realpower.default_arithmetic_mean_7d/realpower.default"},
    {"trend_power_last_month", "realpower.default_arithmetic_mean_30d/realpower.default"},

    {"temperature", "average.temperature"},
    {"avg_temperature_last_day",  "average.temperature_arithmetic_mean_24h"},
    {"avg_temperature_last_week", "average.temperature_arithmetic_mean_7d"},
    {"avg_temperature_last_month", "average.temperature_arithmetic_mean_30d"},

    {"min_temperature_last_day",  "average.temperature_min_24h"},
    {"min_temperature_last_week", "average.temperature_min_7d"},
    {"min_temperature_last_month", "average.temperature_min_30d"},

    {"max_temperature_last_day",  "average.temperature_max_24h"},
    {"max_temperature_last_week", "average.temperature_max_7d"},
    {"max_temperature_last_month", "average.temperature_max_30d"},

    {"trend_temperature_last_day",  "average.temperature_arithmetic_mean_24h/average.temperature"},
    {"trend_temperature_last_week", "average.temperature_arithmetic_mean_7d/average.temperature"},
    {"trend_temperature_last_month", "average.temperature_arithmetic_mean_30d/average.temperature"},

    {"humidity", "average.humidity"},
    {"avg_humidity_last_day", "average.humidity_arithmetic_mean_24h"},
    {"avg_humidity_last_week", "average.humidity_arithmetic_mean_7d"},
    {"avg_humidity_last_month", "average.humidity_arithmetic_mean_30d"},

    {"min_humidity_last_day", "average.humidity_min_24h"},
    {"min_humidity_last_week", "average.humidity_min_7d"},
    {"min_humidity_last_month", "average.humidity_min_30d"},

    {"max_humidity_last_day", "average.humidity_max_24h"},
    {"max_humidity_last_week", "average.humidity_max_7d"},
    {"max_humidity_last_month", "average.humidity_max_30d"},

    {"trend_humidity_last_day", "average.humidity_arithmetic_mean_24h/average.humidity"},
    {"trend_humidity_last_week", "average.humidity_arithmetic_mean_7d/average.humidity"},
    {"trend_humidity_last_month", "average.humidity_arithmetic_mean_30d/average.humidity"},
};



const std::set<std::string> interesting_sources{
"realpower.default",
"realpower.default_arithmetic_mean_24h",
"realpower.default_arithmetic_mean_7d",
"realpower.default_arithmetic_mean_30d",
"realpower.default_min_24h",
"realpower.default_min_7d",
"realpower.default_min_30d",
"realpower.default_max_24h",
"realpower.default_max_7d",
"realpower.default_max_30d",
"realpower.default_arithmetic_mean_24h",
"realpower.default_arithmetic_mean_7d",
"realpower.default_arithmetic_mean_30d",
"average.temperature",
"average.temperature_arithmetic_mean_24h",
"average.temperature_arithmetic_mean_7d",
"average.temperature_arithmetic_mean_30d",
"average.temperature_min_24h",
"average.temperature_min_7d",
"average.temperature_min_30d",
"average.temperature_max_24h",
"average.temperature_max_7d",
"average.temperature_max_30d",
"average.temperature_arithmetic_mean_24h",
"average.temperature_arithmetic_mean_7d",
"average.temperature_arithmetic_mean_30d",
"average.humidity_arithmetic_mean_24h",
"average.humidity_arithmetic_mean_7d",
"average.humidity_arithmetic_mean_30d",
"average.humidity",
"average.humidity_min_24h",
"average.humidity_min_7d",
"average.humidity_min_30d",
"average.humidity_max_24h",
"average.humidity_max_7d",
"average.humidity_max_30d",
"average.humidity_arithmetic_mean_24h",
"average.humidity_arithmetic_mean_7d",
"average.humidity_arithmetic_mean_30d"};


static double
    get_trend_value (
        const std::map<std::string, std::string> &dataDc,
        const std::string &source
    )
{
    std::vector<std::string> items;
    cxxtools::split('/', PARAM_TO_SRC.at(source), std::back_inserter(items));
    if( items.size() != 2 ) {
        return 0.0f;
    }

    double value_actual = 0.0f;
    auto it = dataDc.find(items.at(1));
    if ( it != dataDc.cend() ) {
        value_actual = std::stod (it->second);
    }

    double value_average = 0.0f;
    it = dataDc.find(items.at(0));
    if ( it != dataDc.cend() ) {
        value_average = std::stod (it->second);
    }

    double val = 0.0f;
    if ( value_average != 0 ) {
        val = round( (value_actual - value_average ) / ( value_average ) * 1000.0f ) / 10.0f ;
    }
    return val;
}

static bool
s_is_valid_param(const std::string& p)
{
    return PARAM_TO_SRC.count(p) != 0;
}

static std::string
s_get_valid_param (void)
{
    return utils::join_keys_map (PARAM_TO_SRC, ", ");
}

static bool
    isTrend (const std::string &key)
{
    return ( key.substr(0,5) == "trend" );
}

// encode metric GET request
static zmsg_t*
s_rt_encode_GET (const char* name)
{
    static const char* method = "GET";

    zuuid_t *uuid = zuuid_new ();
    zmsg_t *msg = zmsg_new ();

    zmsg_pushmem (msg, zuuid_data (uuid), zuuid_size (uuid));
    zuuid_destroy (&uuid);
    zmsg_addstr (msg, method);
    zmsg_addstr (msg, name);
    return msg;
}

</%pre>
<%thread scope="global">
asset_manager asset_mgr;
</%thread>


<%cpp>
{
    // Input arguments checks
    // arg1, arg2 are both mandatory
    std::string checked_arg1;
    std::string checked_arg2;

    {
        // sanitize params
        std::string arg1 = qparam.param ("arg1");
        std::string arg2 = qparam.param ("arg2");

        if (arg1.empty ()) {
            http_die ("request-param-required", "arg1");
        }

        if (arg2.empty ()) {
            http_die ("request-param-required", "arg2");
        }

        check_regex_text_or_die ("arg1", arg1, checked_arg1, "^[,0-9]{1,255}$");
        check_regex_text_or_die ("arg2", arg2, checked_arg2, "^[_,a-z]{1,255}$");
        // sanitize params end
    }

    // arg2 is a single value OR a comma-separated list formed from a list of permissible values (PARAM_TO_SRC)
    std::vector<std::string> requestedParams;
    cxxtools::split(",", checked_arg2, std::back_inserter(requestedParams));

    for (const std::string& param: requestedParams) {
        if (!s_is_valid_param (param) ) {
            http_die ("request-param-bad", "arg2",
                      std::string ("value '").append (param).append ("'").c_str (),
                      std::string ("one of the following values: [").append (s_get_valid_param ()).append ("].").c_str ());
        }
    }

    // arg1 is a single value OR a comma-separated list of element identifiers
    std::vector<std::string> DCs;
    cxxtools::split(",", checked_arg1, std::back_inserter(DCs));

    // check that DC exists
    auto allDcsShort = asset_mgr.get_items1("datacenter", "");
    if (allDcsShort.status == 0) {
        http_die ("internal-error", "Error while retrieving information about datacenters.");
    }
    std::vector<std::string> DCNames;
    for (auto const& item : DCs) {
        http_errors_t errors;
        uint32_t real_id = 0;

        if (!check_element_identifier ("element_id", item, real_id, errors)) {
            http_die_error (errors);
        }

        auto it = allDcsShort.item.find (real_id);
        if (it == allDcsShort.item.end()) {
            http_die ("element-not-found", item.c_str ());
        }
        DCNames.push_back (it->second);
    }

    std::map<std::string, std::map<std::string, std::string>> dataDc{};

    // create mlm client
    mlm_client_t *client = mlm_client_new ();
    std::string agent_name("web.dc_indicators.");
    agent_name.append (std::to_string ( static_cast<int> (getpid ()) ))
              .append (".")
              .append (std::to_string ( syscall(SYS_gettid) ));

    int rv = mlm_client_connect (client, MLM_ENDPOINT, 1000, agent_name.c_str());
    if ( rv != 0 ) {
        log_error ("%s: Cannot connect to malamute", agent_name.c_str());
        mlm_client_destroy (&client);
        http_die ("internal-error", "Cannot connect to malamute");
    }
    // get current data for all DCs
    for ( const auto &aDc : DCNames ) {
        // fill the request message according the protocol
        zmsg_t *request = s_rt_encode_GET (aDc.c_str());

        // send message
        rv = mlm_client_sendto (client, RT_PROVIDER_PEER, RT_SUBJECT, NULL,  1000, &request);
        if ( rv != 0 ) {
            log_error ("Cannot send message to malamute");
            mlm_client_destroy (&client);
            http_die ("internal-error", "Cannot send message to malamute.");
        }

        // wait for the reply
        zpoller_t *poller = zpoller_new (mlm_client_msgpipe (client), NULL);
        if (!poller) {
            log_error ("zpoller_new() failed.");
            mlm_client_destroy (&client);
            http_die ("internal-error", "zpoller_new() failed.");
        }
        zmsg_t *mreply = NULL;
        while (true) {
            zsock_t *which = (zsock_t *) zpoller_wait (poller, 5000);
            if (which == mlm_client_msgpipe (client)) {
                mreply = mlm_client_recv (client);
                if (!mreply) {
                    log_error ("mlm_client_recv() failed.");
                    zpoller_destroy (&poller);
                    mlm_client_destroy (&client);
                    http_die ("internal-error", "mlm_client_recv() failed.");
                }
                // check if we receive the expected message
                if ( streq (mlm_client_sender (client), RT_PROVIDER_PEER)) {
                    // yes, this is our reply
                    break;
                }
                // no it is trash, wait a bit more
                log_error ("not expected sender!! going for loop");
                zmsg_destroy (&mreply);
            }
            // no message was received
            if ( zpoller_expired (poller) || zpoller_terminated (poller) ) {
                log_error ("zpoller_wait(timeout = 5000) timed out waiting for message.");
                zpoller_destroy (&poller);
                mlm_client_destroy (&client);
                http_die ("internal-error", "Timed out waiting for message.");
            }
        }
        zpoller_destroy (&poller);

        // filter dataDc
        char *uuid_new = zmsg_popstr (mreply);
        char *status = zmsg_popstr (mreply);
        if ( !streq (status, "OK") ) {
            // clean it up
            zstr_free (&status);
            zstr_free (&uuid_new);
            zmsg_destroy (&mreply);
            mlm_client_destroy (&client);
            http_die ("internal-error", "See log for more detail");
        }
        zstr_free (&status);
        zstr_free (&uuid_new);
        // here we are, if we got "OK" response
        // go through all messages and select quantities we are interested in
        char *element = zmsg_popstr (mreply);
        zstr_free (&element);
        dataDc.emplace (aDc, std::map<std::string,std::string>());
        while  ( zmsg_size (mreply) > 0 ) {
            zmsg_t *encoded_metric = zmsg_popmsg (mreply);
            bios_proto_t *metric = bios_proto_decode (&encoded_metric);
            if ( !metric || bios_proto_id (metric) != BIOS_PROTO_METRIC ) {
                log_error ("Cannot decode some part of the reply, skip it");
                zmsg_destroy (&mreply);
                continue;
            }
            if ( interesting_sources.count ( bios_proto_type (metric)) != 0 ) {
                dataDc.at(aDc).emplace (bios_proto_type (metric), bios_proto_value (metric) );
            }
            bios_proto_destroy (&metric);
        }

        for( size_t P = 0; P < requestedParams.size(); P++ ) {
            const std::string& key = requestedParams[P];
            // key:value
            if ( dataDc.at(aDc).count(PARAM_TO_SRC.at(key)) == 0 ) {
                if ( isTrend (key) ) {
                    double value = get_trend_value(dataDc.at(aDc), key);
                    dataDc.at(aDc).emplace (key, std::to_string (value));
                } else {
                    dataDc.at(aDc).emplace (key, "0");
                }
            }
            else {
                dataDc.at(aDc).emplace(key, dataDc.at(aDc).at(PARAM_TO_SRC.at(key)));
            }
        }
    }
            mlm_client_destroy (&client);

    // So we finally have all values in "dataDc"
    // no http_die is expected
    // lets just  print them
    std::string json;
    json += "{\"datacenter_indicators\": [";
    for( size_t D = 0 ; D < DCs.size(); D++ ) {
        json += "{";
        json += "\"id\": \"";
        json += DCs[D];
        json += "\",";
        json += "\"name\": \"";
        json += DCNames[D];
        json += "\",";
        for ( const auto &row : dataDc.at(DCNames[D]) ) {
            // data contains topics and it aliases, but we need to print only aliases
            if ( PARAM_TO_SRC.count(row.first) == 1 ) {
                // ACE: "nan" should never appear, but system doesn't agree with us
                // If double value is "nan" -> then actually we do not have value
                // JSON do not accept "nan", but "null"
                std::string data = row.second;
                std::transform(data.begin(), data.end(), data.begin(), ::tolower); // who know if it would be NaN or nan or ...
                json += "\"" + row.first + "\":" + ( data == "nan" ? "null" : row.second );
                json += ",";
            }
        }
        json.back() = ' ' ;
        json += "}"; // DC object is finished
        json += ( D < DCs.size() -1) ? "," : "";
    }
    json += "]}"; // close the main object
</%cpp>
<$$ json $>
<%cpp>
}
</%cpp>
