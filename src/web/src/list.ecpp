<%pre>
#include <czmq.h>

#include "asset_msg.h"
#include "data.h"
#include "assetmsgpersistence.h"
</%pre>
<%thread scope="global">
asset_manager asset_mgr;
</%thread>
<%cpp>
    // Check URL validity
    std::string id;

    // Get data
    asset_msg_t* dta = asset_mgr.get_items(request.getArg("type"));

    // Error handling
    if(dta == NULL) {
</%cpp>
{ "error":"item_not_found" }
<%cpp>
        return HTTP_NOT_FOUND;
    }


    if(asset_msg_id(dta) == ASSET_MSG_FAIL) {
        switch(asset_msg_error_id(dta)) {
            case DB_ERROR_NOTFOUND:
</%cpp>
{ "error":"item_not_found" }
<%cpp>
                return HTTP_NOT_FOUND;
            case DB_ERROR_BADINPUT:
</%cpp>
{ "error":"bad_input" }
<%cpp>
                return HTTP_BAD_REQUEST;
            default:
</%cpp>
{ "error":"internal_error" }
<%cpp>    
                return HTTP_INTERNAL_SERVER_ERROR;

        }
    }

    // Prepare the reply
</%cpp>
{
    "<$ request.getArg("type") $>s": [
<%cpp>
    zhash_t *ids = asset_msg_get_element_ids(dta);
    if(ids != NULL) {
        int count = zhash_size(ids);
        int i = 0;
        void *it = NULL;
        for(i = 1, it = zhash_first(ids); it != 0;
            i++,   it = zhash_next(ids) ) {
</%cpp>
        {
            "id":"<$ (char*)zhash_cursor(ids) $>",
            "name":"<$ (char*)it $>"
        }<? i != count ? "," ?>
%       }
    ]
%   }
}
%   asset_msg_destroy(&dta);
