<#
 #
 # Copyright (C) 2015 Eaton
 #
 # This program is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation; either version 2 of the License, or
 # (at your option) any later version.
 #
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License along
 # with this program; if not, write to the Free Software Foundation, Inc.,
 # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 #
 #><#
/*!
 * \file asset_GET.ecpp
 * \author Alena Chernikava <AlenaChernikava@Eaton.com>
 * \author Michal Hrusecky <MichalHrusecky@Eaton.com>
 * \author Karol Hrdina <KarolHrdina@Eaton.com>
 * \author Michal Vyskocil <MichalVyskocil@Eaton.com>
 * \brief Implementation of GET operation on any asset
 */
 #><%pre>
#include <cxxtools/regex.h>

#include "data.h"
#include "asset_types.h"
#include "defs.h"
#include "utils_web.h"
#include "asset_computed_impl.h"
#include "helpers.h"

    struct Outlet {
        std::string label;
        bool label_r;
        std::string type;
        bool type_r;
        std::string group;
        bool group_r;
    };

std::string getOutletNumber (const std::string &extAttributeName)
{
    auto dot1 = extAttributeName.find_first_of(".");
    std::string oNumber = extAttributeName.substr(dot1 + 1);
    auto dot2 = oNumber.find_first_of(".");
    oNumber = oNumber.substr(0, dot2);
    return oNumber;
}

</%pre>

<%thread scope="global">
asset_manager     asset_mgr;
measures_manager  measures_mgr;
</%thread>

<%cpp>
// Check URL validity
std::string typeNameArg = request.getArg("type");
std::string id = request.getArg("id");

if ( id.empty() ) {
    http_die("request-param-required", "id");
}
uint32_t real_id = 0;
http_errors_t errors;
if (!check_element_identifier ("id", id, real_id, errors)) {
    http_die_error (errors);
}

auto tmp = asset_mgr.get_item1(real_id);
if ( tmp.status == 0 )
{
    switch ( tmp.errsubtype )
    {
        case DB_ERROR_NOTFOUND:
            http_die("element-not-found", id.c_str());
        case DB_ERROR_BADINPUT:
        case DB_ERROR_INTERNAL:
        default:
            http_die("internal-error", "Internal database error");
    }
}
if ( !typeNameArg.empty() &&
    (tmp.item.basic.type_id != persist::type_to_typeid(typeNameArg) ) )
{
    http_die("request-param-bad", "type", typeNameArg.c_str(), tmp.item.basic.type_name.c_str());
}
// Prepare the reply
</%cpp>
{
    "id": "<$$ tmp.item.basic.id $>"
    , "name": "<$$ tmp.item.basic.name $>"
    , "status": "<$$ tmp.item.basic.status $>"
    , "priority": "P<$$ tmp.item.basic.priority $>"
    , "type": "<$$ tmp.item.basic.type_name $>"
<%cpp>
// if element is located, then show the location
if ( tmp.item.basic.parent_id != 0 ) {
</%cpp>
    , "location_uri":"<$$ "/api/v1/asset/" +
           persist::typeid_to_type(tmp.item.basic.parent_type_id) + "/" +
           std::to_string (tmp.item.basic.parent_id) $>"
    , "location_id":"<$$ tmp.item.basic.parent_id $>"
    , "location":"<$$ tmp.item.basic.parent_name $>"
<%cpp>
}
else {
</%cpp>
    , "location":""
<%cpp>
}
</%cpp>
, "groups": [
<%cpp>
// every element (except groups) can be placed in some group
if ( !tmp.item.groups.empty() )
{
    uint32_t group_count = tmp.item.groups.size();
    uint32_t i = 1;
    for ( auto &oneGroup : tmp.item.groups )
    {
</%cpp>
"/api/v1/asset/group/<$$ oneGroup $>"<? i != group_count ? "," ?>
<%cpp>
        i++;
    }
}
</%cpp>
]
<%cpp>
// Device is special element with more attributes
if ( tmp.item.basic.type_id == persist::asset_type::DEVICE )
{
    // from csv import ip.1, ip.2 ... can appear, but for now deal with one
    auto it = tmp.item.ext.find("ip.1");
    if ( it != tmp.item.ext.end() )
    {
</%cpp>
, "ip":"<$$ it->second.first $>"
<%cpp>
        tmp.item.ext.erase(it);
    }

    it = tmp.item.ext.find("hostname.1");
    if ( it != tmp.item.ext.end() )
    {
</%cpp>
, "hostname":"<$$ it->second.first $>"
<%cpp>
        tmp.item.ext.erase(it);
    }

    it = tmp.item.ext.find("fqdn.1");
    if ( it != tmp.item.ext.end() )
    {
</%cpp>
, "fqdn":"<$$ it->second.first $>"
<%cpp>
        tmp.item.ext.erase(it);
    }

    it = tmp.item.ext.find("mac.1");
    if ( it != tmp.item.ext.end() )
    {
</%cpp>
, "mac":"<$$ it->second.first $>"
<%cpp>
        tmp.item.ext.erase(it);
    }
</%cpp>
, "powers": [
<%cpp>
    if ( !tmp.item.powers.empty() )
    {
        uint32_t power_count = tmp.item.powers.size();
        uint32_t i = 1;
        for ( auto &oneLink : tmp.item.powers )
        {
</%cpp>
{"src_id":"<$$ oneLink.src_id $>",
 "src_name":"<$$ oneLink.src_name $>"
<%cpp>
            if ( !oneLink.src_socket.empty() )
            {
</%cpp>
,"src_socket":"<$$ oneLink.src_socket $>"
<%cpp>
            }
            if ( !oneLink.dest_socket.empty() )
            {
</%cpp>
,"dest_socket":"<$$ oneLink.dest_socket $>"
%                   }
}<? i != power_count ? "," ?>
<%cpp>
            i++;
        }
    }
</%cpp>
]
<%cpp>
}
// ACE: to be consistent with RFC-11 this was put here
if ( tmp.item.basic.type_id == persist::asset_type::GROUP )
{
    auto it = tmp.item.ext.find("type");
    if ( it != tmp.item.ext.end() )
    {
</%cpp>
, "sub_type":"<$$ it->second.first $>"
<%cpp>
        tmp.item.ext.erase(it);
    }
}
else {
</%cpp>
, "sub_type": "<$$ tmp.item.basic.subtype_name $>"
<%cpp>
}
</%cpp>
, "ext" : [
{"asset_tag": "<$$ tmp.item.basic.asset_tag $>", "read_only": true }
<%cpp>
std::map<std::string, Outlet> outlets;
if ( !tmp.item.ext.empty() )
{
    // TODO escape the DOT ????
    static cxxtools::Regex outlet_label("^outlet\.[0-9][0-9]*\.label$");
    static cxxtools::Regex outlet_group("^outlet\.[0-9][0-9]*\.group$");
    static cxxtools::Regex outlet_type("^outlet\.[0-9][0-9]*\.type$");
    for ( auto &oneExt : tmp.item.ext )
    {
        auto &attrName = oneExt.first;
        auto &attrValue = oneExt.second.first;
        auto isReadOnly= oneExt.second.second;
        if ( outlet_label.match(attrName) ) {
            auto oNumber = getOutletNumber(attrName);
            auto it = outlets.find(oNumber);
            if ( it == outlets.cend() ) {
                auto r = outlets.emplace(oNumber,Outlet());
                it = r.first;
            }
            it->second.label = attrValue;
            it->second.label_r = isReadOnly;
            continue;
        }
        else if ( outlet_group.match(attrName) ) {
            auto oNumber = getOutletNumber(attrName);
            auto it = outlets.find(oNumber);
            if ( it == outlets.cend() ) {
                auto r = outlets.emplace(oNumber,Outlet());
                it = r.first;
            }
            it->second.group = attrValue;
            it->second.group_r = isReadOnly;
            continue;
        }
        else if ( outlet_type.match(attrName) ) {
            auto oNumber = getOutletNumber(attrName);
            auto it = outlets.find(oNumber);
            if ( it == outlets.cend() ) {
                auto r = outlets.emplace(oNumber,Outlet());
                it = r.first;
            }
            it->second.type = attrValue;
            it->second.type_r = isReadOnly;
            continue;
        }
</%cpp>
,{"<$$ oneExt.first $>":"<$$ oneExt.second.first $>","read_only": <$$ oneExt.second.second? "true":"false" $> }
<%cpp>
    }

}
</%cpp>
]
%    if ( !outlets.empty() )// TODO print OUTLETS structure
%    {
,
    "outlets": {
%        int i = 1;
%        int max_size = outlets.size();
%        for ( auto &oneOutlet : outlets ) {
            "<$$ oneOutlet.first$>" : [
%           if ( !oneOutlet.second.label.empty() ) {
                {
                    "name":"label",
                    "value": "<$$ oneOutlet.second.label $>" ,
                    "read_only":<$$ oneOutlet.second.label_r ? "true":"false" $>
                }
%           }
%           if ( !oneOutlet.second.group.empty() ) {
%                if ( !oneOutlet.second.label.empty() ) {
                    ,
%                }
                {
                    "name":"group",
                    "value": "<$$ oneOutlet.second.group $>",
                    "read_only":<$$ oneOutlet.second.group_r ? "true":"false" $>
                }
%           }
%           if ( !oneOutlet.second.type.empty() ) {
%                if ( !oneOutlet.second.label.empty() || !oneOutlet.second.group.empty() ) {
                    ,
%                }
                {
                    "name":"type",
                    "value":"<$$ oneOutlet.second.type $>",
                    "read_only":<$$ oneOutlet.second.type_r ? "true":"false" $>
                }
%           }
            ]
            <$$ max_size == i ? "":"," $>
%           i++;
%        }
    }
%    }

, "computed" : {
%       if (persist::is_rack(tmp.item.basic.type_id)) {
%           int freeusize = free_u_size(tmp.item.basic.id);
%           m_msrmnt_value_t value = 0;
%           m_msrmnt_scale_t scale = 0;
%           int rv = measures_mgr.get_last_10minute_measurement
%               ("realpower.nominal", tmp.item.basic.name, value, scale);
    "freeusize" : <$ freeusize >= 0 ? std::to_string(freeusize) : "null" $>,
    "realpower.nominal" : <$ rv == 0 ? std::to_string(value * std::pow (10, scale)) : "null" $>,
    "outlet.available" : {
%           std::map<std::string, int> res;
%           rack_outlets_available(tmp.item.basic.id, res);
%           size_t i=1;
%           for (const auto &it : res) {
%               std::string val = it.second >= 0 ? std::to_string(it.second) : "null";
%               std::string comma = i == res.size() ? "" : ","; i++;
        "<$ it.first $>" : <$ val $><$ comma $>
%           } // for it : res
    }
%       }   // rack
}
}
