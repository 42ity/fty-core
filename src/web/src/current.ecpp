<#
 #
 # Copyright (C) 2015 Eaton
 #
 # This program is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation; either version 2 of the License, or
 # (at your option) any later version.
 #
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License along
 # with this program; if not, write to the Free Software Foundation, Inc.,
 # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 #
 #><#
/*!
 * \file current.ecpp
 * \author Michal Hrusecky <MichalHrusecky@Eaton.com>
 * \author Alena Chernikava <AlenaChernikava@Eaton.com>
 * \author Michal Vyskocil <MichalVyskocil@Eaton.com>
 * \author Tomas Halman <TomasHalman@Eaton.com>
 * \author Karol Hrdina <KarolHrdina@Eaton.com>
 * \author Jim Klimov <EvgenyKlimov@Eaton.com>
 * \brief Not yet documented file
 */
 #><%pre>
#include <cxxtools/split.h>
#include <stdlib.h>
#include <vector>
#include <string>

#include "upsstatus.h"
#include "data.h"
#include "db/measurements.h"
#include "log.h"
#include "dbpath.h" // temporary

// need this one, as cannot pass std::to_string (const std::string &)
std::string
    json_key_value(
        const std::string &key,
        const std::string &value)
{
    // make a string like this
    // "key":"value"
    std::string s = "\"" + key;
    s += "\":\"";
    s += value;
    s += "\"";
    return s;
}

template <class T>
std::string
   json_key_value(
        const std::string &key,
        const T &value)
{
    // make a string like this
    // "key":value
    std::string s = "\"" + key;
    s += "\":";
    s += std::to_string(value);
    return s;
}

</%pre>

<%args>
std::string dev;
</%args>

<%cpp>
{
    // check if method is allowed
    if ( !request.isMethodGET() )
    {
</%cpp>
<$$ create_error_json("Not implemented", 100) $>
<%cpp>
        return HTTP_NOT_IMPLEMENTED;
    }

    // Check URL validity
    if ( dev.empty() )
    {
</%cpp>
<$$ create_error_json("Invalid url (missing id parameter)", 56) $>
<%cpp>
        return HTTP_BAD_REQUEST;
    }
    std::vector<std::string> asset_ids;
    cxxtools::split(",", dev, std::back_inserter(asset_ids));

    // Go through all passed ids
    std::string big_json{};
    for ( auto asset_id : asset_ids)
    {
        // convert id from string to number
        a_elmnt_id_t id = 0;
        try{
            size_t pos = 0;
            id = std::stoul (asset_id, &pos);
            if ( pos != asset_id.size() )
            {
                // if at least one id is malformed then all request
                // would be rejected
</%cpp>
<$$ create_error_json("One id in the list is malformed", 200) $>
<%cpp>
                return HTTP_BAD_REQUEST;
            }
        }
        catch (...){
            return HTTP_INTERNAL_SERVER_ERROR;
        }
        // Temporary add connection here
        tntdb::Connection conn = tntdb::connectCached(url);

        // check if the element really exists, read its name
        auto ret = persist::select_asset_element_web_byId (conn, id);
        if ( ret.status == 0 )
        {
</%cpp>
<$$ create_error_json("One of ids doesn't exist", 202) $>
<%cpp>
            return HTTP_NOT_FOUND;
        }

        // definition of the function, that would process the
        // returned array of measurements
        std::map <std::string, double> measurements{};
        row_cb_f foo = \
                        [&measurements](const tntdb::Row& r)
                        {
                            std::string topic = "";
                            r["topic"].get(topic);

                            // real topic consists of two parts,
                            // but need to return only first
                            std::vector <std::string> topic_parts{};
                            cxxtools::split("@", topic,
                                    std::back_inserter(topic_parts));
                            if ( topic_parts.size() == 2 )
                            {
                                m_msrmnt_value_t value = 0;
                                r["value"].get(value);

                                m_msrmnt_scale_t scale = 0;
                                r["scale"].get(scale);
                                measurements.emplace
                                (
                                    topic_parts[0],
                                    value * std::pow (10, scale)
                                );
                                // TODO what if emplace return an error
                                /* std::tie (i, inserted) = samples.emplace
                                if (inserted) {
                                    log_info ("emplace () ok.");
                                }
                                else {
                                    // This should not happen since we are certain that item being emplaced is not there
                                    log_warning ("emplace () failed!");
                                }
                                */

                            }
                            else
                            {
                                // Don't know what is it, ignore it
                                log_warning (" topic = '%s' is malformed",
                                               topic.c_str());
                           }
                        };
        // selects measurements
        int rv = persist::select_current_measurement_by_element
                    (conn, id, foo);
        if ( rv != 0 )
        {
</%cpp>
<$$ create_error_json("Some problem during selecting measurements", 201) $>
<%cpp>
            return HTTP_INTERNAL_SERVER_ERROR;
        }

        // we are here -> everything is ok, need just to form
        // this is a small JSON for just ONE asset
        std::string json = "{";
        json += json_key_value("id", asset_id);
        json += ",";
        json += json_key_value("name", ret.item.name);
        json += ",";
        for ( const auto &one_measurement : measurements )
        {
            if( one_measurement.first == "status.ups" )
            {
                json +=  json_key_value(one_measurement.first, shared::upsstatus_to_string(one_measurement.second));
            }
            else
            {
                json +=  json_key_value(one_measurement.first, one_measurement.second);
            }
            json += ",";
        }
        // replace last "," by "}"
        json.back() = '}';
        big_json += json;
        big_json += ",";
    }
    // remove last ","
    big_json.pop_back();
</%cpp>
{
   "current":[
    <$$ big_json $>
   ]
}
%}
