<#
 #
 # Copyright (C) 2015 Eaton
 #
 # This program is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation; either version 2 of the License, or
 # (at your option) any later version.
 #
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License along
 # with this program; if not, write to the Free Software Foundation, Inc.,
 # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 #
 #><#
/*!
 * \file current.ecpp
 * \author Michal Hrusecky <MichalHrusecky@Eaton.com>
 * \author Alena Chernikava <AlenaChernikava@Eaton.com>
 * \author Michal Vyskocil <MichalVyskocil@Eaton.com>
 * \author Tomas Halman <TomasHalman@Eaton.com>
 * \author Karol Hrdina <KarolHrdina@Eaton.com>
 * \author Jim Klimov <EvgenyKlimov@Eaton.com>
 * \brief Implementation of REST API .../metric/current
 */
 #><%pre>
#include <cxxtools/split.h>
#include <cxxtools/regex.h>
#include <stdlib.h>
#include <vector>
#include <map>
#include <string>
#include <cmath>

#include <biosproto.h>

#include <sys/types.h>
#include <sys/syscall.h>

#include "upsstatus.h"
#include "data.h"
#include "log.h"
#include "dbpath.h" // temporary
#include "utils_web.h"
#include "asset_types.h"
#include "helpers.h"
#include "str_defs.h"

static std::string
s_os2string(
        double d) {
    // This is a hack for gdn project - if the key is operatingStatus, the value is
    // converted from number to string using this map
    static std::map<int, std::string> OS2STRING {
        {0, "Unknown"},
            {1, "None"},
            {2, "Servicing"},
            {3, "Starting"},
            {4, "Stopping"},
            {5, "Stopped"},
            {6, "Aborted"},
            {7, "Dormant"},
            {8, "Completed"},
            {9, "Migrating"},
            {10, "Immigrating"},
            {11, "Emigrating"},
            {12, "Snapshotting"},
            {13, "In_Test"},
            {14, "Transitioning"},
            {15, "In_Service"}
    };

    int os = (int) d; // measurements are received as double
    if (OS2STRING.count(os) == 0)
        os = 0;
    return OS2STRING.at(os);
}

struct OutletProperties {
    double realpower;
    double current;
    double voltage;
    std::string status;

    OutletProperties ():
        realpower (NAN),
        current (NAN),
        voltage (NAN),
        status {}
    {};

    void put (const std::string &key, double value) {
        if (key == "realpower")
            realpower = value;
        else
        if (key == "current")
            current = value;
        else
        if (key == "voltage")
            voltage = value;
        else
        if (key == "status")
            status = (value == 42) ? "on" : "off";
    }

    std::string toJson () const {
        std::string ret = "{";
        ret += utils::json::jsonify ("realpower", realpower);
        ret += ", ";
        ret += utils::json::jsonify ("current", current);
        ret += ", ";
        ret += utils::json::jsonify ("voltage", voltage);
        ret += ", \"status\" : ";
        if (status.empty ())
            ret += "null";
        else
            ret += "\"" + status + "\"";
        ret += "}";
        return ret;
    }

};

// encode metric GET request
static zmsg_t*
s_rt_encode_GET (const char* name)
{
    static const char* method = "GET";

    zuuid_t *uuid = zuuid_new ();
    zmsg_t *msg = zmsg_new ();

    zmsg_pushmem (msg, zuuid_data (uuid), zuuid_size (uuid));
    zuuid_destroy (&uuid);
    zmsg_addstr (msg, method);
    zmsg_addstr (msg, name);
    return msg;
}

</%pre>

<%args>
std::string dev;
</%args>

<%cpp>
{
    cxxtools::Regex outlet_properties_re {"(realpower|current|voltage|status).(outlet).([0-9]+)"};

    if (dev.empty()) {
        http_die("request-param-required", "dev");
    }

    std::vector<std::string> asset_ids;
    cxxtools::split(",", dev, std::back_inserter(asset_ids));

    if (asset_ids.empty()) {
        http_die("request-param-required", "dev");
    }

    // Temporary add connection here
    tntdb::Connection conn;
    try{
        conn = tntdb::connectCached(url);
    }
    catch (const std::exception &e)
    {
        LOG_END_ABNORMAL(e);
        http_die("internal-error", "Cannot connect to the database");
    }


    // connect to malamute
    // copy & paste from alert_ack.ecpp
    mlm_client_t *client = mlm_client_new ();
    if (!client) {
        log_critical ("mlm_client_new() failed.");
        http_die ("internal-error", "mlm_client_new() failed.");
    }

    std::string client_name ("web.metric_current.");
    client_name.append (std::to_string (getpid ())).append (".").append (std::to_string (syscall (SYS_gettid)));
    log_debug ("malamute client name = '%s'.", client_name.c_str ());

    int rv = mlm_client_connect (client, MLM_ENDPOINT, 1000, client_name.c_str ());
    if (rv == -1) {
        log_critical ("mlm_client_connect (endpoint = '%s', timeout = '%d', address = '%s') failed.",
                        MLM_ENDPOINT, 1000, client_name.c_str ());
        mlm_client_destroy (&client);
        http_die ("internal-error", "mlm_client_connect() failed.");
    }

    // Go through all passed ids
    std::string big_json{};
    for ( auto asset_id : asset_ids)
    {
        // convert id from string to number
        http_errors_t errors;
        a_elmnt_id_t id = 0;

        if (!check_element_identifier ("N/A", asset_id, id, errors)) {
            log_warning("non-numeric id '%s', skipping", asset_id.c_str());
            continue;
        }

        // check if the element really exists, read its name
        auto asset = persist::select_asset_element_web_byId (conn, id);
        if ( asset.status == 0 )
        {
            log_warning("Element id '%s' is not in DB, skipping", asset_id.c_str());
            continue;
        }

        std::map <std::string, double> measurements{};

        zmsg_t *request = s_rt_encode_GET (asset.item.name.c_str ());
        mlm_client_sendto (client, "agent-rt", "latest-rt-data", NULL, 1000, &request);

        //TODO: this intentionally wait forewer, to be fixed by proper client pool
        zmsg_t *msg = mlm_client_recv (client);
        if (!msg) {
            mlm_client_destroy (&client);
            http_die ("internal-error", "No reply from broker");
        }

        //TODO: check if we have right uuid, to be fixed by proper client pool
        char *uuid = zmsg_popstr (msg);
        zstr_free (&uuid);

        char *result = zmsg_popstr (msg);
        if (!streq (result, "OK")) {
            log_warning ("Error reply for device '%s', result=%s", asset.item.name.c_str (), result);
            zstr_free (&result);
            zmsg_destroy (&msg);
            continue;
        }

        char *element = zmsg_popstr (msg);
        if (!streq (element, asset.item.name.c_str ())) {
            log_warning ("element name (%s) from message differs from requested one (%s), ignoring", element, asset.item.name.c_str ());
            zstr_free (&element);
            zmsg_destroy (&msg);
            continue;
        }
        zstr_free (&element);

        zmsg_t *data = zmsg_popmsg (msg);
        while (data) {
            bios_proto_t *bmsg = bios_proto_decode (&data);
            if (!bmsg) {
                log_warning ("decoding bios_proto_t failed");
                continue;
            }

            // TODO: non double values are not (yet) supported
            measurements.emplace (std::make_pair (
                bios_proto_type (bmsg),
                std::stod (bios_proto_value (bmsg), NULL)));

            bios_proto_destroy (&bmsg);
            
            data = zmsg_popmsg (msg);
        }
        zmsg_destroy (&msg);

        // add mandatory keys if not in DB
        if ( persist::is_rack(asset.item.type_id) || persist::is_dc(asset.item.type_id) ) {
            for (const auto& key : {"realpower.default", "realpower.output.L1"}) {
                if (measurements.count(key) != 0)
                    continue;
                measurements.emplace(key, NAN);
            }
        } else if (persist::is_ups(asset.item.subtype_id)) {
            for (const auto& key : {"status.ups", "load.default", "realpower.default", "voltage.output.L1-N", "realpower.output.L1", "current.output.L1", "charge.battery", "runtime.battery"}) {
                if (measurements.count(key) != 0)
                    continue;
                measurements.emplace(key, NAN);
            }
        }
        else if (persist::is_pdu(asset.item.subtype_id) ||
                persist::is_epdu(asset.item.subtype_id)) {
            for (const auto& key : {"frequency.input", "load.input.L1", "voltage.input.L1-N", "current.input.L1", "realpower.default", "realpower.input.L1", "power.default", "power.input.L1"}) {
                if (measurements.count(key) != 0)
                    continue;
                measurements.emplace(key, NAN);
            }
        }

        if ( rv != 0 )
        {
            mlm_client_destroy (&client);
            http_die("internal-error");
        }

        // we are here -> everything is ok, need just to form
        // this is a small JSON for just ONE asset
        std::string json = "{";
        json += utils::json::jsonify ("id", asset_id);
        json += ",";
        json += utils::json::jsonify ("name", asset.item.name);
        json += ",";
        std::map <std::string, OutletProperties> outlet_properties;

        for ( const auto &one_measurement : measurements )
        {
            // BIOS-951 -- begin
            cxxtools::RegexSMatch s;
            if (persist::is_epdu (asset.item.subtype_id) &&
                outlet_properties_re.match (one_measurement.first, s)) {

                if (outlet_properties.count (s.get (3)) == 0)
                    outlet_properties [s.get (3)] = OutletProperties {};

                outlet_properties [s.get (3)].put (s.get (1), one_measurement.second);
                continue;
            }
            // BIOS-951 -- end

            if( one_measurement.first == "status.ups" )
            {
                json += utils::json::jsonify (one_measurement.first, shared::upsstatus_to_string(one_measurement.second));
            }
            else if (one_measurement.first == "operatingStatus" )
            {
                json += utils::json::jsonify (one_measurement.first, s_os2string(one_measurement.second));
            }
            else
            {
                json += utils::json::jsonify (one_measurement.first, one_measurement.second);
            }
            json += ",";
        }

        // BIOS-951 -- begin
        if (persist::is_epdu (asset.item.subtype_id)) {
            json += "\n    \"outlets\" : {";
            for (const auto &it : outlet_properties) {
                json += "\n        \"" + it.first + "\" : " + it.second.toJson () + ",";
            }

            if (json.back () == ',') {
                json.back () = '\n';
                json += "    }";
            }
            else
                json += '}';    // outlet_properties is empty

            json += "\n,";
        }
        // BIOS-951 -- end

        // replace last "," by "}"
        json.back() = '}';
        big_json += json;
        big_json += ",";
    }

    mlm_client_destroy (&client);

    // remove last ","
    if (!big_json.empty())
        big_json.pop_back();
</%cpp>
{
   "current":[
    <$$ big_json $>
   ]
}
%}
