<#
 #
 # Copyright (C) 2015 Eaton
 #
 # This program is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation; either version 2 of the License, or
 # (at your option) any later version.
 #
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License along
 # with this program; if not, write to the Free Software Foundation, Inc.,
 # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 #
 #><#
/*!
 * \file current.ecpp
 * \author Michal Hrusecky <MichalHrusecky@Eaton.com>
 * \author Alena Chernikava <AlenaChernikava@Eaton.com>
 * \author Michal Vyskocil <MichalVyskocil@Eaton.com>
 * \author Tomas Halman <TomasHalman@Eaton.com>
 * \author Karol Hrdina <KarolHrdina@Eaton.com>
 * \author Jim Klimov <EvgenyKlimov@Eaton.com>
 * \brief Implementation of REST API .../metric/current
 */
 #><%pre>
#include <cxxtools/split.h>
#include <stdlib.h>
#include <vector>
#include <string>
#include <cmath>

#include "upsstatus.h"
#include "data.h"
#include "db/measurements.h"
#include "log.h"
#include "dbpath.h" // temporary
#include "utils_web.h"
#include "asset_types.h"
#include "helpers.h"

static std::string
s_os2string(
        double d) {
    // This is a hack for gdn project - if the key is operatingStatus, the value is
    // converted from number to string using this map
    static std::map<int, std::string> OS2STRING {
        {0, "Unknown"},
            {1, "None"},
            {2, "Servicing"},
            {3, "Starting"},
            {4, "Stopping"},
            {5, "Stopped"},
            {6, "Aborted"},
            {7, "Dormant"},
            {8, "Completed"},
            {9, "Migrating"},
            {10, "Immigrating"},
            {11, "Emigrating"},
            {12, "Snapshotting"},
            {13, "In_Test"},
            {14, "Transitioning"},
            {15, "In_Service"}
    };

    int os = (int) d; // measurements are received as double
    if (OS2STRING.count(os) == 0)
        os = 0;
    return OS2STRING.at(os);
}
</%pre>

<%args>
std::string dev;
</%args>

<%cpp>
{
    if (dev.empty()) {
        http_die("request-param-required", "dev");
    }

    std::vector<std::string> asset_ids;
    cxxtools::split(",", dev, std::back_inserter(asset_ids));

    if (asset_ids.empty()) {
        http_die("request-param-required", "dev");
    }

    // Go through all passed ids
    std::string big_json{};
    for ( auto asset_id : asset_ids)
    {
        // convert id from string to number
        http_errors_t errors;
        a_elmnt_id_t id = 0;

        if (!check_element_identifier ("N/A", asset_id, id, errors)) {
            log_warning("non-numeric id '%s', skipping", asset_id.c_str());
            continue;
        }

        // Temporary add connection here
        tntdb::Connection conn;
        try{
            conn = tntdb::connectCached(url);
        }
        catch (const std::exception &e)
        {
            LOG_END_ABNORMAL(e);
            http_die("internal-error", "Cannot connect to the database");
        }

        // check if the element really exists, read its name
        auto asset = persist::select_asset_element_web_byId (conn, id);
        if ( asset.status == 0 )
        {
            log_warning("Element id '%s' is not in DB, skipping", asset_id.c_str());
            continue;
        }

        // definition of the function, that would process the
        // returned array of measurements
        std::map <std::string, double> measurements{};
        row_cb_f foo = \
                        [&measurements](const tntdb::Row& r)
                        {
                            std::string topic = "";
                            r["topic"].get(topic);

                            // real topic consists of two parts,
                            // but need to return only first
                            std::vector <std::string> topic_parts{};
                            cxxtools::split("@", topic,
                                    std::back_inserter(topic_parts));
                            if ( topic_parts.size() == 2 )
                            {
                                m_msrmnt_value_t value = 0;
                                r["value"].get(value);

                                m_msrmnt_scale_t scale = 0;
                                r["scale"].get(scale);
                                bool inserted;
                                std::map <std::string, double> ::iterator it;
                                std::tie (it, inserted) = measurements.emplace
                                (
                                    topic_parts[0],
                                    value * std::pow (10, scale)
                                );
                                if ( !inserted )
                                    log_error ("in the list of returned measurements at least two have the same measurement_source");
                            }
                            else
                            {
                                // Don't know what is it, ignore it
                                log_warning (" topic = '%s' is malformed",
                                               topic.c_str());
                           }
                        };
        // selects measurements
        int rv = persist::select_current_measurement_by_element
                    (conn, id, foo);

        // add mandatory keys if not in DB
        if (persist::is_rack(asset.item.type_id)) {
            for (const auto& key : {"realpower.default", "realpower.output.L1"}) {
                if (measurements.count(key) != 0)
                    continue;
                measurements.emplace(key, NAN);
            }
        } else if (persist::is_ups(asset.item.subtype_id)) {
            for (const auto& key : {"status.ups", "load.default", "realpower.default", "voltage.output.L1-N", "realpower.output.L1", "current.output.L1", "charge.battery", "runtime.battery"}) {
                if (measurements.count(key) != 0)
                    continue;
                measurements.emplace(key, NAN);
            }
        }
        else if (persist::is_pdu(asset.item.subtype_id) ||
                persist::is_epdu(asset.item.subtype_id)) {
            for (const auto& key : {"frequency.input", "load.input.L1", "voltage.output.L1-N", "current.input.L1", "realpower.default", "realpower.input.L1", "power.default", "power.input.L1"}) {
                if (measurements.count(key) != 0)
                    continue;
                measurements.emplace(key, NAN);
            }
        }

        if ( rv != 0 )
        {
            http_die("internal-error");
        }

        // we are here -> everything is ok, need just to form
        // this is a small JSON for just ONE asset
        std::string json = "{";
        json += utils::json::jsonify ("id", asset_id);
        json += ",";
        json += utils::json::jsonify ("name", asset.item.name);
        json += ",";
        for ( const auto &one_measurement : measurements )
        {
            if( one_measurement.first == "status.ups" )
            {
                json += utils::json::jsonify (one_measurement.first, shared::upsstatus_to_string(one_measurement.second));
            }
            else if (one_measurement.first == "operatingStatus" )
            {
                json += utils::json::jsonify (one_measurement.first, s_os2string(one_measurement.second));
            }
            else
            {
                json += utils::json::jsonify (one_measurement.first, one_measurement.second);
            }
            json += ",";
        }
        // replace last "," by "}"
        json.back() = '}';
        big_json += json;
        big_json += ",";
    }
    // remove last ","
    if (!big_json.empty())
        big_json.pop_back();
</%cpp>
{
   "current":[
    <$$ big_json $>
   ]
}
%}
