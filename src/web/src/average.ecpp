<#
 #
 # Copyright (C) 2015 Eaton
 #
 # This program is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation; either version 2 of the License, or
 # (at your option) any later version.
 #
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License along
 # with this program; if not, write to the Free Software Foundation, Inc.,
 # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 #
 #><#
/*!
 * \file average.ecpp
 * \author Karol Hrdina <KarolHrdina@Eaton.com>
 * \author Michal Hrusecky <MichalHrusecky@Eaton.com>
 * \author Jim Klimov <EvgenyKlimov@Eaton.com>
 * \brief  Implementation of REST API call average/min/max
 */
 #><%pre>
#include <iostream>
#include <sstream>
#include <string>
#include <vector>
#include <stdexcept>
#include <cstdlib>
#include <algorithm>
#include <ctime>
#include <cxxtools/split.h>
#include <sys/types.h>
#include <sys/syscall.h>

#include "utils.h"
#include "utils++.h"
#include "log.h"
#include "str_defs.h"
#include "utils_ymsg.h"
#include "cleanup.h"
#include "utils_web.h"
#include "helpers.h"
#include <tntdb.h>
#include "dbpath.h"
#include "assets.h"

// Check if value of parameter 'relative' is supported:
//  * No - return false, value of unixtime is not changed
//  * Yes - return true; value of unixtime contains now - (relative expressed in seconds)
//
// Currently supported values of relative: 24h, 7d, 30d
// Expects string relative converted to lowercase.

bool relative_to_unixtime (const std::string& relative, int64_t now, int64_t& unixtime) {
    if (relative.compare ("24h") == 0) {
        unixtime = now - 86400;
        return true;
    }
    else if (relative.compare ("7d") == 0) {
        unixtime = now - 604800;
        return true;
    }
    else if (relative.compare ("30d") == 0) {
        unixtime = now - 2592000;
        return true;
    }
    return false;
}


</%pre>
<%args>
    std::string start_ts;
    std::string end_ts;
    std::string type;
    std::string step;
    std::string source;
    std::string element_id;
    std::string relative;
</%args>
<%cpp>
    // Input arguments checking

    int64_t st = -1, end = -1;
    if (relative.empty ()) {
        // check both start_ts and end_ts
        if (start_ts.empty ()) {
            http_die ("request-param-required", "start_ts");
        }
        st = datetime_to_calendar (start_ts.c_str ());
        if (st == -1) {
            http_die ("request-param-bad", "start_ts", std::string ("'").append (start_ts).append ("'").c_str (), "format 'YYYYMMDDhhmmssZ");
        }
        if (end_ts.empty ()) {
            http_die ("request-param-required", "end_ts");
        }
        end = datetime_to_calendar (end_ts.c_str ());
        if (end == -1) {
            http_die ("request-param-bad", "end_ts", std::string ("'").append (end_ts).append ("'").c_str (), "format 'YYYYMMDDhhmmssZ");
        }

        // check that start_ts < end_ts
        if (end <= st) {
            http_die ("parameter-conflict",
                std::string ("Start timestamp '").append (start_ts).append ("' is greater than end timestamp '").append (end_ts).append ("'.").c_str ());
        }
    }
    else {
        // check value of relative parameter
        std::transform (relative.begin(), relative.end(), relative.begin(), ::tolower);
        int64_t now = (int64_t) time (NULL);
        if (!relative_to_unixtime (relative, now, st)) {
            http_die ("request-param-bad", "relative", std::string ("'").append (relative).append ("'").c_str (),
                      "one of the following values: '24h', '7d', '30d'.");
        }
        end = (int64_t) time (NULL);
    }

    log_debug ("st = '%" PRIi64"', end = '%" PRIi64"'", st, end);

    // type is optional, default type is arithmetic average
    if (type.empty ()) {
        type.assign (AVG_TYPES[0]);
    }
    else if (!is_average_type_supported (type.c_str ())) {
        http_die ("request-param-bad", "type",
            std::string ("'").append (type).append ("'").c_str (),
            std::string ("one of the following values: [").append (utils::join (AVG_TYPES, AVG_TYPES_SIZE, ", ")).append("].").c_str ());
    }

    // step
    if (step.empty ()) {
        http_die ("request-param-required", "step");
    }
    if (!is_average_step_supported (step.c_str ())) {
        http_die ("request-param-bad", "step",
            std::string ("'").append (step).append ("'").c_str (),
            std::string ("one of the following values: [").append (utils::join (AVG_STEPS, AVG_STEPS_SIZE, ", ")).append("].").c_str ());
    }

    // source
    if (source.empty()) {
        http_die ("request-param-required", "source");
    }

    // element_id
    http_errors_t errors;
    uint32_t eid = 0;

    if (!check_element_identifier ("element_id", element_id, eid, errors)) {
        http_die_error (errors);
    }
    std::string element_name;
    try{
        tntdb::Connection conn = tntdb::connectCached(url);

        auto basic_ret = persist::select_asset_element_web_byId(conn, eid);
        if ( basic_ret.status == 0 ) {
            http_die ("element-not-found");
        }
        element_name = basic_ret.item.name;
    }
    catch (const  std::exception &e ) {
        http_die ("internal-error", e.what());
    }
    std::string agent_name ("web.average.");
    agent_name.append (std::to_string (static_cast<int> (getpid ()))).append (".").append (std::to_string ( syscall(SYS_gettid) ));

    mlm_client_t *client = mlm_client_new();
    int rv = mlm_client_connect (client, MLM_ENDPOINT, 1000, agent_name.c_str());
    if ( rv == -1 ) {
        mlm_client_destroy (&client);
        http_die ("internal-error", "Cannot connect to malamute");
    }


    zmsg_t *msg = zmsg_new();
    zmsg_addstr (msg, "GET");
    zmsg_addstr (msg, element_name.c_str());
    zmsg_addstr (msg, source.c_str());
    zmsg_addstr (msg, step.c_str());
    zmsg_addstr (msg, type.c_str());
    zmsg_addstr (msg, std::to_string(st).c_str());
    zmsg_addstr (msg, std::to_string(end).c_str());

    mlm_client_sendto (client, "agent-ms", "aggregated data", NULL, 1000, &msg);

    // wait for the right message or time-out
    zmsg_t *recv_msg = NULL;
    zpoller_t *poller = zpoller_new (mlm_client_msgpipe (client), NULL);
    if (!poller) {
        log_critical ("zpoller_new() failed.");
        mlm_client_destroy (&client);
        http_die ("internal-error", "zpoller_new() failed.");
    }

    zsock_t *which = (zsock_t *) zpoller_wait (poller, 10000);
    if (which != NULL) {
        recv_msg = mlm_client_recv (client);
    }
    if (!recv_msg) {
        if (zpoller_expired (poller) || zpoller_terminated (poller)) {
            log_error ("zpoller_wait(timeout = 5000) timed out waiting for message.");
            zpoller_destroy (&poller);
            mlm_client_destroy (&client);
            http_die ("internal-error", "Timed out waiting for message.");
        }
        log_error ("mlm_client_recv() failed.");
        zpoller_destroy (&poller);
        mlm_client_destroy (&client);
        http_die ("internal-error", "mlm_client_recv() failed.");
    }
    zpoller_destroy (&poller);

    char *frame = zmsg_popstr (recv_msg);
    if ( streq(frame, "ERROR") ) {
        zstr_free (&frame);
        frame = zmsg_popstr(recv_msg); // not it is reason
        // TODO memory leak in reason, HOW to fix????
        zmsg_destroy (&recv_msg);
        mlm_client_destroy (&client);
        http_die ("internal-error", frame);
    }
    if ( streq(frame, "OK") ) {
        // now we are going to set up the head of the response
        char *element_rep = zmsg_popstr (recv_msg);
        char *source_rep = zmsg_popstr (recv_msg);
        char *step_rep = zmsg_popstr (recv_msg);
        char *type_rep = zmsg_popstr (recv_msg);
        char *start_date_rep = zmsg_popstr (recv_msg);
        char *end_date_rep = zmsg_popstr (recv_msg);
        char *units_rep = zmsg_popstr (recv_msg);
</%cpp>
{
        <$$ utils::json::jsonify ("units", units_rep) $>,
        <$$ utils::json::jsonify ("source", source_rep) $>,
        <$$ utils::json::jsonify ("step", step_rep) $>,
        <$$ utils::json::jsonify ("type", type_rep) $>,
        <$$ utils::json::jsonify ("element_id", eid) $>,
        <$$ utils::json::jsonify ("start_ts", start_date_rep) $>,
        <$$ utils::json::jsonify ("end_ts", end_date_rep) $>,
        "data":[
<%cpp>
        // first of all, need to clean up
        zstr_free (&element_rep);
        zstr_free (&source_rep);
        zstr_free (&step_rep);
        zstr_free (&type_rep);
        zstr_free (&start_date_rep);
        zstr_free (&units_rep);
        // now we are going to fill in data
        while  ( zmsg_size (recv_msg) >= 2 ) {
            char *timestamp = zmsg_popstr (recv_msg);
            char *value = zmsg_popstr (recv_msg);
            </%cpp>
{
    "value": <$$ value $>,
    "timestamp": <$$ timestamp $>,
    "scale": 0
} <$$ zmsg_size (recv_msg) != 0 ? "," : "" $>
            <%cpp>
            zstr_free (&value);
            zstr_free (&timestamp);
        }
</%cpp>
        ]
}
<%cpp>
    }
    zmsg_destroy (&recv_msg);
    mlm_client_destroy (&client);
</%cpp>
