<%pre>
#include <iostream>
#include <sstream>
#include <string>
#include <vector>
#include <stdexcept>
#include <cstdlib>
#include <ctime>
#include <cxxtools/split.h>

#include "persistence.h"
#include "utils.h"
#include "bios_agent.h"
#include "agents.h"
#include "ymsg.h"
#include "str_defs.h"

#define DATETIME_FORMAT "%Y%m%d%H%M%SZ"

</%pre>
<%args>
    std::string start_ts;
    std::string end_ts;
    std::string type;
    std::string step;
    std::string source;
    std::string element_id;
</%args>
<%cpp>
    int64_t st;
    int64_t end;
    uint64_t eid;
    try {
        // check both start_ts and end_ts
        if (start_ts.size() != 15 || end_ts.size() != 15) {
            throw std::invalid_argument ("Format for start_ts and end_ts is 'YYYYMMDDhhmmssZ' where Z stands for UTC time zone.");
        }
        struct tm tm;
        if (strptime (start_ts.c_str(), DATETIME_FORMAT, &tm) == NULL) {
            throw std::invalid_argument ("Format for start_ts is 'YYYYMMDDhhmmssZ' where Z stands for UTC time zone.");
        }
        st = mktime(&tm);
        if (strptime (end_ts.c_str(), DATETIME_FORMAT, &tm) == NULL) {
            throw std::invalid_argument ("Format for end_ts is 'YYYYMMDDhhmmssZ' where Z stands for UTC time zone.");
        }
        end = mktime(&tm);
        // check that start_ts < end_ts
        if (end >= st) {
            throw std::invalid_argument ("start_ts must be <= end_ts");
        }

        // type is optional, default type is arithmetic average
        if (type.empty ()) {
            type.assign (AVG_TYPES[0]);
        }
        else if (!is_average_type_supported (type.c_str ())) {
            throw std::invalid_argument ("Average type <$ type $> not recognized.");
        }

        if (step.empty ()) {
            throw std::invalid_argument ("Field 'step' is empty.");
        }
        if (!is_average_step_supported (step.c_str ())) {
            throw std::invalid_argument ("Average step <$ step $> not supported.");
        }

        if (source.empty()) {
            throw std::invalid_argument ("Key 'sources' is empty.");
        }
        if (element_id.empty()) {
            throw std::invalid_argument ("Mandatory argument 'element_id' not specified.");
        }
        eid = std::stoul(element_id);
    }
    catch (const std::logic_error& e) { // invalid_argument, length_error, out_of_range
</%cpp>
        {
            "msg" : "<$ e.what () $>"
        }
<%cpp>
        return HTTP_BAD_REQUEST;
    }
    catch (const std::exception& e) {
</%cpp>
        {
            "msg" : "<$ e.what () $>"
        }
<%cpp>
        return HTTP_INTERNAL_SERVER_ERROR;
    }
    catch (...) {
</%cpp>
        {
            "msg" : "Unknown internal error."
        }
<%cpp>
        return HTTP_INTERNAL_SERVER_ERROR;
    }

    char a_name[64];
    sprintf(a_name, "rest.%d", getpid());
    bios_agent_t* agent = bios_agent_new("ipc://malamute", a_name);
    ymsg_t *msg = bios_web_average_request_encode(st, end, type.c_str(),
                                            step.c_str(), eid, source.c_str());
    bios_agent_sendto(agent, "computation", "average", &msg);
    msg = bios_agent_recv(agent);
    char *json = NULL;
    if(msg == NULL || bios_web_average_reply_decode(&msg, &json)) {
</%cpp>
        {
            "msg" : "Got incorect reply from computation module."
        }
<%cpp>
        return HTTP_INTERNAL_SERVER_ERROR;
    }
</%cpp>
<$$ json $>
