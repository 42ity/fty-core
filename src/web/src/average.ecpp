<#
 #
 # Copyright (C) 2015 Eaton
 #
 # This program is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation; either version 2 of the License, or
 # (at your option) any later version.
 #
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License along
 # with this program; if not, write to the Free Software Foundation, Inc.,
 # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 #
 #><#
/*!
 * \file average.ecpp
 * \author Karol Hrdina <KarolHrdina@Eaton.com>
 * \author Michal Hrusecky <MichalHrusecky@Eaton.com>
 * \author Jim Klimov <EvgenyKlimov@Eaton.com>
 * \brief  Implementation of REST API call average/min/max
 */
 #><%pre>
#include <iostream>
#include <sstream>
#include <string>
#include <vector>
#include <stdexcept>
#include <cstdlib>
#include <ctime>
#include <cxxtools/split.h>
#include <sys/types.h>
#include <sys/syscall.h>

#include "utils.h"
#include "utils++.h"
#include "bios_agent.h"
#include "agents.h"
#include "ymsg.h"
#include "log.h"
#include "str_defs.h"
#include "utils_ymsg.h"
#include "cleanup.h"
#include "utils_web.h"

</%pre>
<%args>
    std::string start_ts;
    std::string end_ts;
    std::string type;
    std::string step;
    std::string source;
    std::string element_id;
</%args>
<%cpp>
    // Input arguments checking

    // check both start_ts and end_ts
    if (start_ts.empty ()) {
        http_die ("request-param-required", "start_ts");
    }
    int64_t st = datetime_to_calendar (start_ts.c_str ());
    if (st == -1) {
        http_die ("request-param-bad", "start_ts", std::string ("'").append (start_ts).append ("'").c_str (), "format 'YYYYMMDDhhmmssZ");
    }
    if (end_ts.empty ()) {
        http_die ("request-param-required", "end_ts");
    }
    int64_t end = datetime_to_calendar (end_ts.c_str ());
    if (end == -1) {
        http_die ("request-param-bad", "end_ts", std::string ("'").append (end_ts).append ("'").c_str (), "format 'YYYYMMDDThhmmssZ");
    }
   
    // check that start_ts < end_ts
    if (end <= st) {
        http_die ("start-gt-end-timestamp", start_ts.c_str(), end_ts.c_str ());
    }

    // type is optional, default type is arithmetic average
    if (type.empty ()) {
        type.assign (AVG_TYPES[0]);
    }
    else if (!is_average_type_supported (type.c_str ())) {
        http_die ("request-param-bad", "type",
            std::string ("'").append (type).append ("'").c_str (),
            std::string ("one of the following values: [").append (utils::join (AVG_TYPES, AVG_TYPES_SIZE, ", ")).append("].").c_str ());
    }

    // step 
    if (step.empty ()) {
        http_die ("request-param-required", "step");
    } 
    if (!is_average_step_supported (step.c_str ())) {
        http_die ("request-param-bad", "step",
            std::string ("'").append (step).append ("'").c_str (),
            std::string ("one of the following values: [").append (utils::join (AVG_STEPS, AVG_STEPS_SIZE, ", ")).append("].").c_str ());
    }

    // source
    if (source.empty()) {
        http_die ("request-param-required", "source");
    }

    // element_id
    if (element_id.empty()) {
        http_die ("request-param-required", "element_id");
    }

    uint32_t eid;
    try {
        eid = utils::string_to_element_id (element_id);
    }
    catch (const std::invalid_argument& e) {
        http_die ("request-param-bad", "element_id",
            std::string ("value '").append (element_id).append ("'").append (" is not an element identifier").c_str (),
            std::string ("an unsigned integer in range 1 to ").append (std::to_string (UINT_MAX)).append (".").c_str ());
    }
    catch (const std::out_of_range& e) {
        http_die ("request-param-bad", "element_id",
            std::string ("value '").append (element_id).append ("'").append (" is out of range").c_str (),
            std::string ("value in range 1 to ").append (std::to_string (UINT_MAX)).append (".").c_str ());
    }
    catch (const std::exception& e) {
        log_error ("std::exception caught: %s", e.what ());
        http_die ("internal-error");
    }

    std::string agent_name (BIOS_AGENT_PREFIX_REST);
    agent_name.append (std::to_string (static_cast<int> (getpid ()))).append (".").append (std::to_string ( syscall(SYS_gettid) ));

    _scoped_bios_agent_t *agent = bios_agent_new (MLM_ENDPOINT, agent_name.c_str ());
    if (agent == NULL) {
        http_die ("internal-error", "bios_agent_new () failed.");
    }

    _scoped_ymsg_t *msg = bios_web_average_request_encode (st, end, type.c_str(), step.c_str(), eid, source.c_str ());
    if (msg == NULL) {
        bios_agent_destroy (&agent);
        http_die ("internal-error", "bios_web_average_request_encode() failed.");
    }

    int rv = bios_agent_sendto (agent, BIOS_AGENT_NAME_COMPUTATION, "metric/computed/average", &msg);
    if (rv != 0) {
        bios_agent_destroy (&agent);
        http_die ("internal-error", "bios_web_average_send_to() failed.");
    }

    msg = bios_agent_recv (agent);
    if (msg == NULL) {
        bios_agent_destroy (&agent);
        http_die ("internal-error", "Computation module didn't reply.");
    }

    if (!ymsg_is_ok (msg)) {
        ymsg_destroy (&msg);
        bios_agent_destroy (&agent);
        http_die ("internal-error", ymsg_errmsg (msg) ? ymsg_errmsg (msg) : "Error requesting average data." );
    }

    _scoped_char *json = NULL;
    rv = bios_web_average_reply_extract (msg, &json);
    ymsg_destroy (&msg);
    if (rv != 0) {
        bios_agent_destroy (&agent);
        http_die ("internal-error", "Reply from computation module incorrect.");
        return HTTP_INTERNAL_SERVER_ERROR;
    }
    bios_agent_destroy (&agent);
</%cpp>
<$$ json $>
