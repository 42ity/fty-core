<#
 #
 # Copyright (C) 2015 Eaton
 #
 # This program is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation; either version 2 of the License, or
 # (at your option) any later version.
 #
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License along
 # with this program; if not, write to the Free Software Foundation, Inc.,
 # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 #
 #><#
/*!
 * \file auth.ecpp
 * \author Jim Klimov <EvgenyKlimov@Eaton.com>
 * \author Michal Hrusecky <MichalHrusecky@Eaton.com>
 * \brief Not yet documented file
 */
 #><%pre>
#include "sasl.h"
#include "tokens.h"
#include "log.h"
#include "utils_web.h"
#include <string>
#include <iostream>
#include <cxxtools/regex.h>
#include <tnt/httpmessage.h>
#include <tnt/httpheader.h>
#include <cxxtools/jsondeserializer.h>
#include <stdio.h>

#ifndef VALID_FOR
#define VALID_FOR 3600
#endif //VALID_FOR

</%pre>
<%args>
std::string grant_type;
std::string username;
std::string password;
std::string token;
</%args>
<%cpp>
{
    std::string method = request.getMethod();
    // Check if it is a revoke
    static cxxtools::Regex rex_rev("^.*/revoke$");
    if ( rex_rev.match(request.getUrl()) ) {
        // it is a revoke
        if ( method != "POST" ) {
            http_die ("method-not-allowed");
        }
        if(token.empty()) {
            http_die("request-param-required", "'token'");
        }
        tokens::get_instance()->revoke(token);
</%cpp>
{ "success": "Everything went well" }
<%cpp>
        return HTTP_OK;
    }

    // it is a request for token
    if ( method == "GET" ) {
        log_warning ("Unsecured version authorization is used (through the GET method with encoded parameters) ");
    } else if ( method == "POST" ) {
        // read json a deserialize it
        cxxtools::SerializationInfo si;
        try {
            std::stringstream input (request.getBody (), std::ios_base::in);
            cxxtools::JsonDeserializer deserializer (input);
            deserializer.deserialize (si);
        }
        catch (const std::exception& e) {
            LOG_END_ABNORMAL(e);
            http_die("bad-request-document", e.what());
        }
        auto grant_type_si = si.findMember("grant_type");
        if ( !grant_type_si ) {
            http_die ("request-param-required", "grant_type");
        }
        auto username_si = si.findMember("username");
        if ( !username_si ) {
            http_die ("request-param-required", "user_name");
        }
        auto password_si = si.findMember("password");
        if ( !password_si ) {
            http_die ("request-param-required", "password");
        }
        *grant_type_si >>= grant_type;
        *username_si >>= username;
        *password_si >>= password;
    } else {
        http_die ("method-not-allowed");
    }

    int valid = VALID_FOR;


    // with grant_type argument client wants to get new oauth2 token
    if ( grant_type != "password" ) {
        http_die ("request-param-bad", "grant_type", grant_type.c_str(), "password");
    }
    log_info ("request POST oauth2: username %s, grant_type %s", username.c_str (), grant_type.c_str ());

    if ( !authenticate(username.c_str(), password.c_str()) ) {
        log_error ("request POST oauth2: username %s, grant_type %s authentication FAILED", username.c_str (), grant_type.c_str ());
        http_die ("request-param-bad", "(user|passwd)", "<invalid user or password>", "<valid user and password>");
    }
</%cpp>
{
    "access_token":"<$$ tokens::get_instance()->gen_token(valid, username.c_str()) $>",
    "token_type":"bearer",
    "expires_in":<$ valid $>
}
%}
