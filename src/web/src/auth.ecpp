<#
 #
 # Copyright (C) 2015 Eaton
 #
 # This program is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation; either version 2 of the License, or
 # (at your option) any later version.
 #
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License along
 # with this program; if not, write to the Free Software Foundation, Inc.,
 # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 #
 #><#
/*!
 * \file auth.ecpp
 * \author Jim Klimov <EvgenyKlimov@Eaton.com>
 * \author Michal Hrusecky <MichalHrusecky@Eaton.com>
 * \brief Not yet documented file
 */
 #><%pre>
#include "sasl.h"
#include "tokens.h"
#include "log.h"
#include "utils_web.h"
#include "helpers.h"
#include <string>
#include <iostream>
#include <cxxtools/regex.h>
#include <tnt/httpmessage.h>
#include <tnt/httpheader.h>
#include <cxxtools/jsondeserializer.h>
#include <stdio.h>

#ifndef VALID_FOR
#define VALID_FOR 3600
#endif //VALID_FOR

</%pre>
<%args>
std::string grant_type;
std::string username;
std::string password;
std::string token;
</%args>
<%cpp>
std::string checked_grant_type;
std::string checked_username;
std::string checked_password;
std::string checked_token;
{
    // sanitize check token
    http_errors_t errors;
    if (check_regex_text ("token", token, "^[-/._~+/a-z0-9]{0,255}={0,10}$", errors)) {
        checked_token = token;
    } else {
        http_die_error (errors);
    }
    // sanitize check token end
}
#define token TAINTED

  {
    std::string method = request.getMethod();
    // Check if it is a revoke
    static cxxtools::Regex rex_rev("^.*/revoke$");
    if ( rex_rev.match(request.getUrl()) ) {
        // it is a revoke
        if ( method != "POST" ) {
            http_die ("method-not-allowed");
        }
        http_errors_t errors;
        if(checked_token.empty()) {
            http_die("request-param-required", "'token'");
        }
        tokens::get_instance()->revoke(checked_token);
</%cpp>
{ "success": "Everything went well" }
<%cpp>
        return HTTP_OK;
    }

    // it is a request for token
    if ( method == "GET" ) {
        log_warning ("Unsecured version authorization is used (through the GET method with encoded parameters) ");
    } else if ( method == "POST" ) {
        // read json a deserialize it
        cxxtools::SerializationInfo si;
        try {
            std::stringstream input (request.getBody (), std::ios_base::in);
            cxxtools::JsonDeserializer deserializer (input);
            deserializer.deserialize (si);
        }
        catch (const std::exception& e) {
            LOG_END_ABNORMAL(e);
            http_die("bad-request-document", e.what());
        }
        auto grant_type_si = si.findMember("grant_type");
        if ( !grant_type_si ) {
            http_die ("request-param-required", "grant_type");
        }
        auto username_si = si.findMember("username");
        if ( !username_si ) {
            http_die ("request-param-required", "user_name");
        }
        auto password_si = si.findMember("password");
        if ( !password_si ) {
            http_die ("request-param-required", "password");
        }
        *grant_type_si >>= grant_type;
        *username_si >>= username;
        *password_si >>= password;
    } else {
        http_die ("method-not-allowed");
    }

{
    // sanitize other params
    http_errors_t errors;
    if (check_regex_text ("username", username, "^[-_.a-z0-9]{0,50}$", errors)) {
        checked_username = username;
    } else {
        http_die_error (errors);
    }
    if (check_regex_text ("username", password, "^.{0,150}$", errors)) {
        checked_password = password;
    } else {
        http_die_error (errors);
    }
    if (check_regex_text ("grant_type", grant_type, "^(password|)$", errors)) {
        checked_grant_type = grant_type;
    } else {
        http_die_error (errors);
    }
    // sanitize other params end
}
#define username TAINTED
#define password TAINTED
#define grant_type TAINTED
  

    int valid = VALID_FOR;


    // with grant_type argument client wants to get new oauth2 token
    if ( checked_grant_type != "password" ) {
        http_die ("request-param-bad", "grant_type", checked_grant_type.c_str(), "password");
    }
    log_info ("request POST oauth2: username %s, grant_type %s", checked_username.c_str (), checked_grant_type.c_str ());

    if ( !authenticate(checked_username.c_str(), checked_password.c_str()) ) {
        log_error ("request POST oauth2: username %s, grant_type %s authentication FAILED", checked_username.c_str (), checked_grant_type.c_str ());
        http_die ("request-param-bad", "(user|passwd)", "<invalid user or password>", "<valid user and password>");
    }
</%cpp>
{
    "access_token":"<$$ tokens::get_instance()->gen_token(valid, checked_username.c_str()) $>",
    "token_type":"bearer",
    "expires_in":<$ valid $>
}
%}
