<#
 #
 # Copyright (C) 2015-2016 Eaton
 #
 # This program is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation; either version 2 of the License, or
 # (at your option) any later version.
 #
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License along
 # with this program; if not, write to the Free Software Foundation, Inc.,
 # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 #
 #><#
/*!
 * \file systemctl.ecpp
 * \author Karol Hrdina <KarolHrdina@Eaton.com>
 * \author Jim Klimov <EvgenyKlimov@Eaton.com>
 * \brief  Provide Users ability to manipulate with some specified services
 */
 #><%pre>
#include <cxxtools/serializationinfo.h>
#include <cxxtools/jsondeserializer.h>
#include <cxxtools/split.h>

#include <stdexcept>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>

#include "subprocess.h"
#include "helpers.h"

#define LoadState       "LoadState"     // loaded/
#define ActiveState     "ActiveState"   // active/
#define UnitFileState   "UnitFileState" // enabled/disabled
#define SubState        "SubState"      // running/

// List of hardcoded services that we allow to be manipulated through REST API
// TODO: Match this up with tools/systemctl and maybe the Makefile variables
static const char *list[] =
{
// SYSTEM services as named in Debian 8:
    "networking", "mysql", "ntp", "saslauthd", "malamute",
// SYSTEM services as named in some non-Debian OSes:
    "network", "mysqld", "mariadb", "ntpd", "ntpdate", "sntp",
// BIOS services
    "bios-networking",
    "bios-reset-button", "tntnet@bios", "bios-agent-smtp",
    "bios-agent-alert-generator", "agent-alerts-list",
    "bios-agent-autoconfig", "bios-agent-cm",
    "bios-agent-inventory", "bios-agent-nut",
//TODO: legacy-metrics to be removed
    "bios-agent-asset", "bios-agent-legacy-metrics", "kpi-uptime",
    "agent-th", "bios-agent-tpower", "bios-db-init",
    "dc_th", "bios-agent-rt", "bios-agent-ms",
    "biostimer-warranty-metric",
// TODO: Wildcard services, e.g. instances defined at run-time
// NUT services
    "nut-driver", "nut-monitor", "nut-server",
    NULL
};

static std::set<std::string> get_operations {"list", "status"};
static std::set<std::string> post_operations {"start", "stop", "restart", "enable", "disable"};

bool service_name_valid (const char *service_name) {
    int i = 0;
    while (list[i] != NULL) {
        if (strcmp (list[i], service_name) == 0)
            return true;
        i++;
    }
    return false;
}

bool
parse_systemctl_status
(const std::string& in, std::string& active_state, std::string& sub_state, std::string& load_state, std::string& unit_file_state) {
    // Expected `systemctl show` format is:
    //      key=value
    //      ...
    //      key=value
    if (in.empty ())
        return false;

    std::vector<std::string> tokens;
    cxxtools::split("\n", in, std::back_inserter(tokens));
    for (auto&& i : tokens) {
        if (i.empty ()) {
            continue;
        }
        std::size_t found = i.find ("=");
        if (found == std::string::npos) {
            return false;
        }
        std::string key = i.substr (0, found);
        std::string value  = i.substr (found+1, std::string::npos);

        if (key.compare (LoadState) == 0) {
            load_state = value;
        }
        else if (key.compare (ActiveState) == 0) {
            active_state = value;
        }
        else if (key.compare (UnitFileState) == 0) {
            unit_file_state = value;
        }
        else if (key.compare (SubState) == 0) {
            sub_state = value;
        }
    }
    return true;
}

unsigned int process_get_list (
        tnt::HttpReply& reply)
{
    std::string message;

    message.assign (
"{\n"
"\t\"systemctl_services\" : [\n");
    bool last = false;
    int i = 0;
    while (list[i] != NULL) {
        if (list [i+1] == NULL)
            last = true;
        message.append ("\t\t\"").append (list[i]).append (last ? "\"\n" : "\",\n");
        i++;
    }
    message.append (
"\t]\n"
"}");
    reply.out() << message;
    return HTTP_OK;
}

unsigned int process_get_status (
        tnt::HttpReply& reply,
        const std::string& service_name)
{
    // ASSUMPTION: service name is valid
    std::string message;

    shared::Argv proc_cmd {"sudo", "systemctl", "show", service_name};
    std::string proc_out, proc_err;
    int proc_rv = shared::output (proc_cmd, proc_out, proc_err);

    if ( proc_rv != 0 ) {
        message = "shared::output (command = 'sudo systemctl show " + service_name +
            "') failed. Return value = '" + std::to_string (proc_rv) + "', stderr = '" + proc_err + "'.";
        log_error (message.c_str ());
        http_die("internal-error", "Executing systemctl failed. Please check logs for more details.");
    }

    std::string active_state, sub_state, load_state, unit_file_state;
    if ( !parse_systemctl_status (proc_out, active_state, sub_state, load_state, unit_file_state) ) {
        log_error ("Could not parse output of `systemctl show` due to different expected output format.");
        http_die("internal-error", "Executing systemctl failed. Please check logs for more details.");
    }

    message.assign (
            "{\n"
            "\t\"" + service_name + "\" : {\n" +
            "\t\t\"ActiveState\"\t:\t\"" + active_state  + "\",\n"
            "\t\t\"SubState\"\t:\t\"" + sub_state + "\",\n"
            "\t\t\"LoadState\"\t:\t\"" + load_state + "\",\n"
            "\t\t\"UnitFileState\"\t:\t\"" + unit_file_state + "\"\n"
            "\t}\n"
            "}");
    reply.out() << message;
    return HTTP_OK;
}

unsigned int process_post (
        tnt::HttpReply& reply,
        const std::string& operation,
        const std::string& service_name)
{
    std::string message;

    // as for some services, we can do the real operation with another name
    std::string service_name_op = service_name;
    // networking is different animal, treat differently
    if (service_name == "networking") {
        if (operation != "restart" && operation != "show") {
            http_die("request-param-bad",
                    "operation",
                    operation.c_str(),
                    "'show' or 'restart'");
        }
        // restart is done using special script
        if (operation == "restart") {
            service_name_op = "bios-networking";
        }
    }
    // TODO: The hardcoded check below should call
    // "sudo systemctl list-requires tntnet@bios.service"
    // and inspect that run-time list of services
    if ( (operation == "restart" || operation == "stop" || operation == "disable" ) &&
       (service_name == "bios" || service_name == "bios.target" ||
        service_name == "bios.service" ||
        service_name == "mysql" || service_name == "mysql.service" ||
        service_name == "bios-db-init" || service_name == "bios-db-init.service" ||
        service_name == "malamute" || service_name == "malamute.service" ||
        service_name == "saslauthd" || service_name == "saslauthd.service" ||
        service_name == "tntnet@bios" || service_name == "tntnet@bios.service" )
    ) {
        message = "'sudo systemctl " + operation + " " + service_name_op + "' can impact the web-server unit 'tntnet@bios.service'";
        log_warning (message.c_str ());
        // TODO: call systemctl --no-block in these cases
    }
    shared::Argv proc_cmd {"sudo", "systemctl", operation, service_name_op};

    std::string proc_out, proc_err;
    int proc_rv = shared::output (proc_cmd, proc_out, proc_err);
    if (proc_rv != 0) {
        message = "shared::output (command = 'sudo systemctl " + operation + " " + service_name_op + "') failed. Return value = '"
            + std::to_string (proc_rv) + "', stderr = '" + proc_err + "'.";
        log_error (message.c_str ());
        http_die("internal-error", "Executing systemctl failed. Please check logs for more details.");
    }

    shared::Argv proc_cmd2 {"sudo", "systemctl", "show", service_name};

    proc_rv = shared::output (proc_cmd2, proc_out, proc_err);
    if (proc_rv != 0) {
        message = "shared::output (command = 'sudo systemctl show " + service_name + "') failed. Return value = '"
            + std::to_string (proc_rv) + "', stderr = '" + proc_err + "'.";
        log_error (message.c_str ());
        http_die("internal-error", "Executing systemctl failed. Please check logs for more details.");
    }

    std::string active_state, sub_state, load_state, unit_file_state;
    if (!parse_systemctl_status (proc_out, active_state, sub_state, load_state, unit_file_state)) {
        log_error ("Could not parse output of `systemctl show` due to different expected output format.");
        http_die("internal-error", "Executing systemctl failed. Please check logs for more details.");
    }
    message.assign (
"{\n"
"\t\"" + service_name + "\" : {\n" +
"\t\t\"ActiveState\"\t:\t\"" + active_state  + "\",\n"
"\t\t\"SubState\"\t:\t\"" + sub_state + "\",\n"
"\t\t\"LoadState\"\t:\t\"" + load_state + "\",\n"
"\t\t\"UnitFileState\"\t:\t\"" + unit_file_state + "\"\n"
"\t}\n"
"}");
    reply.out() << message;
    return HTTP_OK;
}

</%pre>
<%request scope="global">
UserInfo user;
</%request>
<%cpp>
{
    // check user permissions
    static const std::map <BiosProfile, std::string> PERMISSIONS = {
            {BiosProfile::Dashboard, "R"},
            {BiosProfile::Admin,     "RE"}
            };
    CHECK_USER_PERMISSIONS_OR_DIE (PERMISSIONS);

    std::string checked_operation;
    std::string checked_service_name;
    // sanity checks
    {
        // get user-input
        std::string operation = request.getArg("operation");
        // convert to lower case; 'admin/systemctl/list' request is equivalent to 'admin/systemctl/LIST' request
        std::transform (operation.begin(), operation.end(), operation.begin(), ::tolower);
        if ( get_operations.count(operation) == 0 && post_operations.count(operation) == 0 ) {
            http_die ("request-param-bad", "operation", operation.c_str(), "status/list/enable/disable/start/stop/restart");
        }
        log_debug ("%zu", get_operations.count (checked_operation) );
        if ( request.getMethod() == "GET"  && ( get_operations.count (operation) == 0 ) )  {
            http_die ("request-param-bad", "operation", operation.c_str(), "operation allowed for GET method");
        }
        if ( request.getMethod() == "POST" && ( post_operations.count (operation) == 0 ) ) {
            http_die ("request-param-bad", "operation", operation.c_str(), "operation allowed for POST method");
        }
        checked_operation = std::move (operation);

        // get user-input
        std::string service_name;
        if ( request.getMethod() == "POST" ) {
            if ( request.getBody().empty() ) {
                http_die("bad-request-document", "Expected json document  { \"service_name\" : \"<service_name>\" }. Received empty request document.");
            }

            try {
                std::stringstream input (request.getBody(), std::ios_base::in);
                cxxtools::JsonDeserializer deserializer (input);
                cxxtools::SerializationInfo si;
                deserializer.deserialize (si);
                if ( si.category () != cxxtools::SerializationInfo::Object ) {
                    throw cxxtools::SerializationError ("Received document's root is not json object.");
                }
                si.getMember("service_name") >>= service_name;
            }
            catch (const cxxtools::SerializationError& e) {
                std::string message;
                message.assign("Expected json document { \"service_name\" : \"<service_name>\" }. ").append (e.what ());
                http_die( "bad-request-document", message.c_str() );
            }
            catch (const std::exception& e) {
                std::string message;
                message.assign ("Exception caught: ").append (e.what ());
                log_error (message.c_str ());
                http_die( "internal-error", "Exception caught. Please check logs for more details.");
            }
        } else {
            service_name = request.getArg("service_name");
        }
        std::transform (service_name.begin(), service_name.end(), service_name.begin(), ::tolower);
        if ( ( checked_operation != "list" ) && !service_name_valid (service_name.c_str ()) ) {
            http_die ("request-param-bad", "service_name", service_name.c_str(), "one of service names that can be obtained through systemctl/list call");
        }
        checked_service_name = std::move (service_name);
    }
    log_info ("service_name: %s", checked_service_name.c_str());

    if ( request.getMethod() == "GET" ) {
        if ( checked_operation == "list" ) {
            return process_get_list (reply);
        }
        else if ( checked_operation == "status" ) {
            return process_get_status (reply, checked_service_name);
        }
    }
    if ( request.getMethod() == "POST" ) {
        return process_post (reply, checked_operation, checked_service_name);
    }
}
</%cpp>
