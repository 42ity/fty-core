<#
 #
 # Copyright (C) 2015-2016 Eaton
 #
 # This program is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation; either version 2 of the License, or
 # (at your option) any later version.
 #
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License along
 # with this program; if not, write to the Free Software Foundation, Inc.,
 # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 #
 #><#
/*!
 * \file systemctl.ecpp
 * \author Karol Hrdina <KarolHrdina@Eaton.com>
 * \author Jim Klimov <EvgenyKlimov@Eaton.com>
 * \brief  Provide Users ability to manipulate with some specified services
 */
 #><%pre>
#include <cxxtools/serializationinfo.h>
#include <cxxtools/jsondeserializer.h>
#include <cxxtools/split.h>

#include <stdexcept>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>

#include "subprocess.h"
#include "helpers.h"

struct SystemdUnitState {
    std::string LoadState;     // loaded/
    std::string ActiveState;   // active/
    std::string UnitFileState; // enabled/disabled
    std::string SubState;      // running/
};

/* List of services and other systemd units that we know at runtime as allowed
 * to be manipulated through REST API (as deemed by systemctl wrapper script)
 * and their current states.
 */
std::map<std::string, struct SystemdUnitState> allowed_unit_list{};

// List of allowed REST API operations for services and other supported units.
static std::set<std::string> get_operations {"list", "status"};
static std::set<std::string> post_operations {"start", "stop", "restart", "enable", "disable"};

int call_systemctl(shared::Argv proc_cmd_systemctl_args, std::string &proc_out, std::string &proc_err, std::map<std::string, struct SystemdUnitState> &discovered_unit_list) {
    /* This routine finds unit names or further details according to
     * passed argument list and saves into the map provided by caller */
    return -1;
}


int learn_allowed_units(const char *service_name) {
    /* If the provided service_name is NULL, list details for all known BIOS
     * services; otherwise list the service name only.
     */
    /* TODO REVIEW: Is this code shared in threads? Should changes be mutexed?
     * Then - How? :)
     */
    if (allowed_unit_list.size() != 0)
        allowed_unit_list.clear();

    shared::Argv proc_cmd {"sudo", "systemctl", "list-ipm-units", "--detailed"};
    if (service_name != NULL) {
        proc_cmd.push_back(service_name);
    }

    std::string proc_out, proc_err;
    int proc_rv = shared::output (proc_cmd, proc_out, proc_err);

    if ( proc_rv != 0 ) {
        std::string message =
            "shared::output (command = 'sudo systemctl list-ipm-units --detailed') failed. "
            "Return value = '" + std::to_string (proc_rv) + "', stderr = '" + proc_err + "'.";
        log_error (message.c_str ());
        return -1; // http_die() needs the reply object, so caller would die instead
    }

    if (proc_out.empty ()) {
        log_error ("shared::output (command = 'sudo systemctl list-ipm-units --detailed') succeeded, "
            "but returned empty output. Is host OS misconfigured (lack of registered units)?" );
        return 0;
    }

    /* An example of `systemctl list-ipm-units --detailed` format is:
     *   malamute.service	L:loaded	A:inactive	U:disabled	S:dead
     * TAB-separated sequence of "<Id>\tL:<LoadState>\tA:<ActiveState>\tU:<UnitFileState>\tS:<SubState>\n"
     * The unit Id is not-empty; any state can be empty or single-word token.
     * This command returns only the installed units that pass the filter
     * defined in systemctl wrapper script as the components of our project,
     * so unrelated services can not be manipulated by end-user over REST API
     * (nor CLI sudo).
     */

    std::vector<std::string> line_tokens;
    cxxtools::split("\n", proc_out, std::back_inserter(line_tokens));
    for (auto&& i : line_tokens) {
        if (i.empty ()) {
            continue;
        }

        std::string unit_name;
        SystemdUnitState sus; // std::strings inside are initialized to empty

        std::vector<std::string> sub_tokens;
        cxxtools::split("\t", i, std::back_inserter(sub_tokens));
        for (auto&& j : sub_tokens) {
            if (j.empty ()) {
                continue;
            }

            if (unit_name.empty ()) {
                unit_name = j;  /* The first sub-token in the string */
            } else {
                std::string key = j.substr (0, 2);
                if (j.size() > 2) { /* else keep the original empty value */
                    std::string value = j.substr (2, std::string::npos);
                    if (key.compare("L:") == 0) {
                        sus.LoadState = value;
                    } else if (key.compare("A:") == 0) {
                        sus.ActiveState = value;
                    } else if (key.compare("U:") == 0) {
                        sus.UnitFileState = value;
                    } else if (key.compare("S:") == 0) {
                        sus.SubState = value;
                    }
                }
            }
        }

        if (unit_name.empty()) {
            log_error ("Could not parse output of `sudo systemctl list-ipm-units --detailed` due to different expected output format.");
            return -2;
        } else {
            allowed_unit_list[unit_name] = sus;
        }
    }

    if (allowed_unit_list.size() == 0) {
        log_error ("Could not parse output of `sudo systemctl list-ipm-units --detailed` due to different expected output format or lack of registered units.");
    }

    return allowed_unit_list.size();
}

bool service_name_valid (std::string &service_name) {
    /* NOTE: The service_name reference is intentionally not const,
     * this routine can change it (e.g. convert a short-name unit
     * into a full-name one as locally detected at run-time. */
    if (allowed_unit_list.size() == 0)
        return false;

    std::map<std::string, SystemdUnitState>::iterator it;

    it = allowed_unit_list.find(service_name);
    if (it != allowed_unit_list.end())
        return true;

    /* TODO: Refactor the supported extension parsing into a loop with one piece of code */
    it = allowed_unit_list.find(service_name + ".service");
    if (it != allowed_unit_list.end()) {
        service_name += ".service";
        return true;
    }

    it = allowed_unit_list.find(service_name + ".target");
    if (it != allowed_unit_list.end()) {
        service_name += ".target";
        return true;
    }

    it = allowed_unit_list.find(service_name + ".timer");
    if (it != allowed_unit_list.end()) {
        service_name += ".timer";
        return true;
    }

    return false;
}

unsigned int process_get_list (
        tnt::HttpReply& reply)
{
    std::string message;

    message.assign (
"{\n"
"\t\"systemctl_services\" : [\n");
    bool first = true;
    for (auto& element : allowed_unit_list) {
        if (element.first.empty())
            continue;

        message.append (first ? "\t\t\"" : ",\t\t\"").
                append (element.first).
                append ("\"\n");

        if (first)
            first = false;
    }

    message.append (
"\t]\n"
"}");
    reply.out() << message;
    return HTTP_OK;
}

unsigned int process_get_status (
        tnt::HttpReply& reply,
        const std::string& service_name)
{
    std::string message;
    std::map<std::string, SystemdUnitState>::iterator it = allowed_unit_list.find(service_name);
    if ( it == allowed_unit_list.end()) {
        message = "Denying request for systemd unit not among those allowed by filter: '" + service_name +"'.";
        log_error (message.c_str ());
        http_die ("request-param-bad", "service_name", service_name.c_str(), "one of service names that can be obtained through systemctl/list call");
    }

    /* TODO: Maybe use `systemctl list-json` for flexibility with supported attributes etc. instead? */
    message.assign (
            "{\n"
            "\t\"" + it->first + "\" : {\n" +
            "\t\t\"ActiveState\"\t:\t\"" + it->second.ActiveState + "\",\n"
            "\t\t\"SubState\"\t:\t\"" + it->second.SubState + "\",\n"
            "\t\t\"LoadState\"\t:\t\"" + it->second.LoadState + "\",\n"
            "\t\t\"UnitFileState\"\t:\t\"" + it->second.UnitFileState + "\"\n"
            "\t}\n"
            "}");
    reply.out() << message;
    return HTTP_OK;
}

unsigned int process_post (
        tnt::HttpReply& reply,
        const std::string& operation,
        const std::string& service_name)
{
    std::string message;

    // for some services, we can do the real operation with another name
    std::string service_name_op = service_name;

    // networking is different animal, treat differently
    // FIXME: There is no "show" operation in our allowed list... typo "stop"?
    if (service_name == "networking") {
        if (operation != "restart" && operation != "show") {
            http_die("request-param-bad",
                    "operation",
                    operation.c_str(),
                    "'show' or 'restart'");
        }
        // restart is done using special script
        if (operation == "restart") {
            service_name_op = "bios-networking";
        }
    }

    // TODO: The hardcoded check below should call
    // "sudo systemctl list-requires tntnet@bios.service"
    // and inspect that run-time list of services
    if ( (operation == "restart" || operation == "stop" || operation == "disable" ) &&
       (service_name == "bios" || service_name == "bios.target" ||
        service_name == "bios.service" ||
        service_name == "mysql" || service_name == "mysql.service" ||
        service_name == "bios-db-init" || service_name == "bios-db-init.service" ||
        service_name == "malamute" || service_name == "malamute.service" ||
        service_name == "saslauthd" || service_name == "saslauthd.service" ||
        service_name == "tntnet@bios" || service_name == "tntnet@bios.service" )
    ) {
        message = "'sudo systemctl " + operation + " " + service_name_op + "' can impact the web-server unit 'tntnet@bios.service'";
        log_warning (message.c_str ());
        // TODO: call systemctl --no-block in these cases
    }
    shared::Argv proc_cmd {"sudo", "systemctl", operation, service_name_op};

    std::string proc_out, proc_err;
    int proc_rv = shared::output (proc_cmd, proc_out, proc_err);
    if (proc_rv != 0) {
        message = "shared::output (command = 'sudo systemctl " + operation + " " + service_name_op + "') failed. Return value = '"
            + std::to_string (proc_rv) + "', stderr = '" + proc_err + "'.";
        log_error (message.c_str ());
        http_die("internal-error", "Executing systemctl failed. Please check logs for more details.");
    }

    shared::Argv proc_cmd2 {"sudo", "systemctl", "show", service_name};

    proc_rv = shared::output (proc_cmd2, proc_out, proc_err);
    if (proc_rv != 0) {
        message = "shared::output (command = 'sudo systemctl show " + service_name + "') failed. Return value = '"
            + std::to_string (proc_rv) + "', stderr = '" + proc_err + "'.";
        log_error (message.c_str ());
        http_die("internal-error", "Executing systemctl failed. Please check logs for more details.");
    }

    std::string active_state, sub_state, load_state, unit_file_state;
/*
    if (!parse_systemctl_status (proc_out, active_state, sub_state, load_state, unit_file_state)) {
        log_error ("Could not parse output of `systemctl show` due to different expected output format.");
        http_die("internal-error", "Executing systemctl failed. Please check logs for more details.");
    }
*/

    message.assign (
"{\n"
"\t\"" + service_name + "\" : {\n" +
"\t\t\"ActiveState\"\t:\t\"" + active_state  + "\",\n"
"\t\t\"SubState\"\t:\t\"" + sub_state + "\",\n"
"\t\t\"LoadState\"\t:\t\"" + load_state + "\",\n"
"\t\t\"UnitFileState\"\t:\t\"" + unit_file_state + "\"\n"
"\t}\n"
"}");
    reply.out() << message;
    return HTTP_OK;
}

</%pre>
<%request scope="global">
UserInfo user;
</%request>
<%cpp>
{
    // check user permissions
    static const std::map <BiosProfile, std::string> PERMISSIONS = {
            {BiosProfile::Dashboard, "R"},
            {BiosProfile::Admin,     "RE"}
            };
    CHECK_USER_PERMISSIONS_OR_DIE (PERMISSIONS);

    std::string checked_operation;
    std::string checked_service_name;
    // sanity checks
    {
        // get user-input
        std::string operation = request.getArg("operation");
        // convert to lower case; 'admin/systemctl/list' request is equivalent to 'admin/systemctl/LIST' request
        std::transform (operation.begin(), operation.end(), operation.begin(), ::tolower);
        if ( get_operations.count(operation) == 0 && post_operations.count(operation) == 0 ) {
            http_die ("request-param-bad", "operation", operation.c_str(), "status/list/enable/disable/start/stop/restart");
        }
        log_debug ("%zu", get_operations.count (checked_operation) );
        if ( request.getMethod() == "GET"  && ( get_operations.count (operation) == 0 ) )  {
            http_die ("request-param-bad", "operation", operation.c_str(), "operation allowed for GET method");
        }
        if ( request.getMethod() == "POST" && ( post_operations.count (operation) == 0 ) ) {
            http_die ("request-param-bad", "operation", operation.c_str(), "operation allowed for POST method");
        }
        checked_operation = std::move (operation);

        // get user-input
        std::string service_name;
        if ( request.getMethod() == "POST" ) {
            if ( request.getBody().empty() ) {
                http_die("bad-request-document", "Expected json document  { \"service_name\" : \"<service_name>\" }. Received empty request document.");
            }

            try {
                std::stringstream input (request.getBody(), std::ios_base::in);
                cxxtools::JsonDeserializer deserializer (input);
                cxxtools::SerializationInfo si;
                deserializer.deserialize (si);
                if ( si.category () != cxxtools::SerializationInfo::Object ) {
                    throw cxxtools::SerializationError ("Received document's root is not json object.");
                }
                si.getMember("service_name") >>= service_name;
            }
            catch (const cxxtools::SerializationError& e) {
                std::string message;
                message.assign("Expected json document { \"service_name\" : \"<service_name>\" }. ").append (e.what ());
                http_die( "bad-request-document", message.c_str() );
            }
            catch (const std::exception& e) {
                std::string message;
                message.assign ("Exception caught: ").append (e.what ());
                log_error (message.c_str ());
                http_die( "internal-error", "Exception caught. Please check logs for more details.");
            }
        } else {
            service_name = request.getArg("service_name");
        }

        if ( checked_operation == "list" ) {
            if ( learn_allowed_units(NULL) <= 0 ) {
                /* The error is logged in detail by the function */
                http_die("internal-error", "Executing systemctl failed. Please check logs for more details.");
            }
        } else {
            if ( (learn_allowed_units(service_name.c_str()) <= 0 ) ||
                 (!service_name_valid (service_name) )
            ) { /* In case of wildcards or short names, the service_name
                 * value can get changed by the call above; e.g. a
                 * "tntnet@bios" would become "tntnet@bios.service" */
                http_die ("request-param-bad", "service_name", service_name.c_str(), "one of service names that can be obtained through systemctl/list call (case-sensitive!)");
            }
        }

        checked_service_name = std::move (service_name);
    }
    log_info ("service_name: %s", checked_service_name.c_str());

    if ( request.getMethod() == "GET" ) {
        if ( checked_operation == "list" ) {
            return process_get_list (reply);
        }
        else if ( checked_operation == "status" ) {
            return process_get_status (reply, checked_service_name);
        }
    }

    if ( request.getMethod() == "POST" ) {
        return process_post (reply, checked_operation, checked_service_name);
    }
}
</%cpp>
