<#
 #
 # Copyright (C) 2015 Eaton
 #
 # This program is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation; either version 2 of the License, or
 # (at your option) any later version.
 #
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License along
 # with this program; if not, write to the Free Software Foundation, Inc.,
 # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 #
 #><#
/*!
 * \file systemctl.ecpp
 * \author Karol Hrdina <KarolHrdina@Eaton.com>
 * \brief Not yet documented file
 */
 #><%pre>
#include <cxxtools/serializationinfo.h>
#include <cxxtools/jsondeserializer.h>
#include <cxxtools/split.h>

#include <stdexcept>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>

#include "auth_levels.h"
#include "subprocess.h"
#include "utils_web.h"

#define LoadState       "LoadState"     // loaded/
#define ActiveState     "ActiveState"   // active/
#define UnitFileState   "UnitFileState" // enabled/disabled
#define SubState        "SubState"      // running/

// List of hardcoded services that we allow to be manipulated through REST API
// TODO: Match this up with tools/systemctl and maybe the Makefile variables
static const char *list[] =
{
// SYSTEM services
    "networking", "mysql", "ntp", "saslauthd", "malamute",
// BIOS services
    "bios-reset-button", "bios-ssh-last-resort", "tntnet@bios", "bios-agent-smtp", "bios-agent-alert", "bios-agent-autoconfig",
    "bios-agent-cm", "bios-agent-dbstore", "bios-agent-inventory", "bios-agent-nut", "agent-th", "bios-agent-tpower", "bios-db-init",
    "bios-server-agent",
// NUT services
    "nut-driver", "nut-monitor", "nut-server",
    NULL
};

bool service_name_valid (const char *service_name) {
    int i = 0;
    while (list[i] != NULL) {
        if (strcmp (list[i], service_name) == 0)
            return true;
        i++;
    }
    return false;
}

bool
parse_systemctl_status
(const std::string& in, std::string& active_state, std::string& sub_state, std::string& load_state, std::string& unit_file_state) {
    // Expected `systemctl show` format is:
    //      key=value
    //      ...
    //      key=value
    if (in.empty ())
        return false;

    std::vector<std::string> tokens;
    cxxtools::split("\n", in, std::back_inserter(tokens));
    for (auto&& i : tokens) {
        if (i.empty ()) {
            continue;
        }
        std::size_t found = i.find ("=");
        if (found == std::string::npos) {
            return false;
        }
        std::string key = i.substr (0, found);
        std::string value  = i.substr (found+1, std::string::npos);

        if (key.compare (LoadState) == 0) {
            load_state = value;
        }
        else if (key.compare (ActiveState) == 0) {
            active_state = value;
        }
        else if (key.compare (UnitFileState) == 0) {
            unit_file_state = value;
        }
        else if (key.compare (SubState) == 0) {
            sub_state = value;
        }
    }
    return true;
}

unsigned int process_get (
        tnt::HttpReply& reply,
        const std::string& operation,
        const std::string& service_name)
{
    std::string message;

    ////////////////
    //    LIST    //
    ////////////////
    if (operation.compare ("list") == 0) {
        message.assign (
"{\n"
"\t\"systemctl_services\" : [\n");
        bool last = false;
        int i = 0;
        while (list[i] != NULL) {
            if (list [i+1] == NULL)
                last = true;
            message.append ("\t\t\"").append (list[i]).append (last ? "\"\n" : "\",\n");
            i++;
        }
        message.append (
"\t]\n"
"}");
        reply.out() << message;
        return HTTP_OK;
    }

    //////////////////////
    //      STATUS      //
    //////////////////////
    if (operation.compare ("status") == 0) {
        if (service_name_valid (service_name.c_str ())) {
            shared::Argv proc_cmd {"sudo", "systemctl", "show", service_name};
            std::string proc_out, proc_err;
            int proc_rv = shared::output (proc_cmd, proc_out, proc_err);

            if (proc_rv != 0) {
                message.assign ("TODO executing `systemctl show` failed: " + std::to_string (proc_rv)); // TODO change error message
                http_die("internal-error", message.c_str() );
            }

            std::string active_state, sub_state, load_state, unit_file_state;
            if (!parse_systemctl_status (proc_out, active_state, sub_state, load_state, unit_file_state)) {
                http_die("internal-error", "TODO Expected different format of systemctl show"); // TODO: change error message
            }

            message.assign (
"{\n"
"\t\"" + service_name + "\" : {\n" +
"\t\t\"ActiveState\"\t:\t\"" + active_state  + "\",\n"
"\t\t\"SubState\"\t:\t\"" + sub_state + "\",\n"
"\t\t\"LoadState\"\t:\t\"" + load_state + "\",\n"
"\t\t\"UnitFileState\"\t:\t\"" + unit_file_state + "\"\n"
"\t}\n"
"}");
            reply.out() << message;
            return HTTP_OK;
        }
        http_die( "element-not-found", service_name.c_str() );
    }

    //////////////////////////////////
    //      BAD: empty / unknown    //
    //////////////////////////////////
    http_die("request-param-required", "operation");
}

unsigned int process_post (
        tnt::HttpReply& reply,
        const std::string& operation,
        const std::string& body)
{
    std::string message;
    if (operation.compare ("start") != 0 &&
        operation.compare ("stop") != 0 &&
        operation.compare ("restart") != 0 &&
        operation.compare ("enable") != 0 &&
        operation.compare ("disable") != 0) {
        http_die("request-param-bad",
                 "operation",
                 operation.c_str(),
                 "'start', 'stop', 'restart', 'enable' or 'disable'");
    }

    if (body.empty ()) {
        http_die("bad-request-document", "{ \"service_name\" : \"<service_name>\" }");
    }

    try {
        std::stringstream input (body, std::ios_base::in);
        cxxtools::JsonDeserializer deserializer (input);
        cxxtools::SerializationInfo si;
        deserializer.deserialize (si);
        if (si.category () != cxxtools::SerializationInfo::Object) {
            throw cxxtools::SerializationError ("TODO Root object TODO"); // TODO change error message
        }
        std::string service_name;
        si.getMember("service_name") >>= service_name;
        if (! service_name_valid (service_name.c_str ())) {
            throw cxxtools::SerializationError ("TODO service_name empty or invalid"); // TODO change error message
        }

        // networking is different animal, threat differently
        if (service_name == "networking") {
            if (operation != "restart" && operation != "show") {
                http_die("request-param-bad",
                         "operation",
                         operation.c_str(),
                         "'show' or 'restart'");
            }
            // restart is done using special script
            if (operation == "restart") {
                service_name = "bios-networking";
            }
        }

        shared::Argv proc_cmd {"sudo", "systemctl", operation, service_name};

        std::string proc_out, proc_err;
        int proc_rv = shared::output (proc_cmd, proc_out, proc_err);
        if (proc_rv != 0) {
            message.assign ("executing systemctl failed: ").append (proc_err);
            http_die("internal-error", message.c_str() );
        }

        // but we want to pretend we have used networking service ...
        if (service_name == "bios-networking") {
            service_name = "networking";
        }
        shared::Argv proc_cmd2 {"sudo", "systemctl", "show", service_name};

        proc_rv = shared::output (proc_cmd2, proc_out, proc_err);
        if (proc_rv != 0) {
            message.assign ("executing `systemctl show` failed: " + std::to_string (proc_rv));
            http_die("internal-error", message.c_str() );
        }

        std::string active_state, sub_state, load_state, unit_file_state;
        if (!parse_systemctl_status (proc_out, active_state, sub_state, load_state, unit_file_state)) {
            message.assign ("cant parse systemctl show output");
            http_die("internal-error", message.c_str() );
        }
        message.assign (
"{\n"
"\t\"" + service_name + "\" : {\n" +
"\t\t\"ActiveState\"\t:\t\"" + active_state  + "\",\n"
"\t\t\"SubState\"\t:\t\"" + sub_state + "\",\n"
"\t\t\"LoadState\"\t:\t\"" + load_state + "\",\n"
"\t\t\"UnitFileState\"\t:\t\"" + unit_file_state + "\"\n"
"\t}\n"
"}");
        reply.out() << message;
        return HTTP_OK;
    }
    catch (const cxxtools::SerializationError& e) {
        message.assign("Expected: { \"service_name\" : \"<service_name>\" }").append (e.what ());
        http_die( "bad-request-document", message.c_str() );
    }
    catch (const std::exception& e) {
        message.assign ("Exception caught: '").append(e.what ()).append("'.");
        http_die( "internal-error", message.c_str() );
    }
}

</%pre>
<%cpp>

std::string operation = request.getArg("operation");
std::string service_name = request.getArg("service_name");

// convert to lower case; 'admin/systemctl/list' request is equivalent to 'admin/systemctl/LIST' request
std::transform (operation.begin(), operation.end(), operation.begin(), ::tolower);
std::transform (service_name.begin(), service_name.end(), service_name.begin(), ::tolower);

if (request.getMethod() == "GET") {
    return process_get (reply, operation, service_name);
}
if (request.getMethod() == "POST") {
    return process_post (reply, operation, request.getBody() );
}
http_die("method-not-allowed", request.getMethod().c_str() );

</%cpp>


