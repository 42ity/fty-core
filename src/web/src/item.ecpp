<%pre>
#include <czmq.h>
#include <cxxtools/split.h>

#include "asset_msg.h"
#include "common_msg.h"
#include "data.h"
#include "assetmsg.h"
</%pre>
<%thread scope="global">
asset_manager asset_mgr;
</%thread>
<%cpp>
    // Check URL validity
    std::string id;
    if((id = request.getArg("id")).empty()) {
</%cpp>
{ "error":"invalid_url" }
<%cpp>
        return HTTP_BAD_REQUEST;
    }
    // Get data
    zmsg_t *tmp = asset_mgr.get_item(request.getArg("type"), id);
    asset_msg_t *dta = NULL;
    asset_msg_t *device = NULL;
    if ( tmp != NULL ) 
    {
        if ( is_asset_msg (tmp) )
        {
            asset_msg_t* element = asset_msg_decode (&tmp);
            if ( asset_msg_id (element) == ASSET_MSG_DEVICE ) 
            {
                device = element;
                zmsg_t *tmp_msg = asset_msg_get_msg (element);
                dta = asset_msg_decode (&tmp_msg);
            } else if (asset_msg_id (element) == ASSET_MSG_ELEMENT ) {
                dta = element;
            }
            else
            {
                asset_msg_destroy (&element);
                dta = NULL;
                // TODO proper error handling
            }
        }
        else if( is_common_msg (tmp) )
        {
            common_msg_t* commonmsg = common_msg_decode (&tmp);
            if ( common_msg_id (commonmsg) == COMMON_MSG_FAIL )
            {
                switch ( common_msg_errorno (commonmsg) ) {
                    case DB_ERROR_NOTFOUND:
</%cpp>
{ "error":"item_not_found" }
<%cpp>
                        common_msg_destroy (&commonmsg);
                        return HTTP_NOT_FOUND;
                    case DB_ERROR_BADINPUT:
</%cpp>
{ "error":"bad_input" }
<%cpp>
                        common_msg_destroy (&commonmsg);
                        return HTTP_BAD_REQUEST;
                    default:
</%cpp>
{ "error":"internal_error" }
<%cpp>
                        common_msg_destroy (&commonmsg);
                        return HTTP_INTERNAL_SERVER_ERROR;
                }
            }
            else
            {
                common_msg_destroy (&commonmsg);
                dta = NULL;
                //TODO proper error handling
            }
        }
        else {
            zmsg_destroy (&tmp);
            dta = NULL;
        }
    }
    if ( dta == NULL ) {
</%cpp>
{ "error":"internal_error" }
<%cpp>
        return HTTP_INTERNAL_SERVER_ERROR;
    }

    // Prepare the reply
    char buff[16];
</%cpp>
{
      "id": "<$ id $>"
    , "name": "<$ asset_msg_name(dta) $>"
<%cpp>
    zhash_t *ext = asset_msg_get_ext(dta);
    assert (ext);
    int ext_count = 0;
    if ( ext != NULL ) {
        ext_count = zhash_size (ext);
    }
    int i = 0;
    void *it;

    sprintf(buff, "%d", asset_msg_location (dta));
    if ( ( asset_msg_location (dta) != 0 ) && 
         ( asset_msg_location_type (dta) != asset_type::UNKNOWN ) ) {
</%cpp>
    , "location_uri":"<$ "/api/v1/asset/" +
                   asset_mgr.byte_to_type(asset_msg_location_type (dta)) + "/" +
                   buff $>"
<%cpp>
    }
    // Device is special element with more attributes
    byte type_byte = asset_mgr.type_to_byte (request.getArg("type") );
    if ( type_byte == asset_type::DEVICE ) {
        std::string temp_string;
</%cpp>
%       if ( !( temp_string = asset_msg_device_type(device)).empty() ) {
    , "type": "<$ temp_string $>"
%       }
%       if(!(temp_string = asset_msg_ip(device)).empty()) {
    , "ip": "<$ temp_string $>"
%       }
%       if(!(temp_string = asset_msg_hostname(device)).empty()) {
    , "hostname": "<$ temp_string $>"
%       }
%       if(!(temp_string = asset_msg_fqdn(device)).empty()) {
    , "fqdn": "<$ temp_string $>"
%       }
%       if(!(temp_string = asset_msg_mac(device)).empty()) {
    , "mac": "<$ temp_string $>"
%       }
<%cpp>
        zlist_t *groups = asset_msg_get_groups (device);
        if ( groups != NULL ) {
            void* last = zlist_last(groups);
</%cpp>
    , "groups": [
%           for(it = zlist_first(groups); it != 0;
%               it = zlist_next(groups) ) {
          "/api/v1/asset/group/<$ (char*)it $>"<? it != last ? "," ?>
%           }
       ]
<%cpp>
        }
        zlist_destroy (&groups);
        zlist_t *power = asset_msg_get_powers(device);

        if ( power != NULL ) {
            void* last = zlist_last(power);
</%cpp>
    , "powers": [
<%cpp>
            for(it = zlist_first(power); it != 0;
                it = zlist_next(power) ) {
                std::vector<std::string> tokens;
                cxxtools::split(':', std::string((char*)it), std::back_inserter(tokens));

                if(tokens.size() != 4) continue;
</%cpp>
        {
%               if (!tokens[0].empty() && tokens[0] != "999") {
            "src_socket":"<$ tokens[0] $>",
%               }
            "src_uri":"/api/v1/asset/device/<$ tokens[1] $>"
%               if (!tokens[2].empty() && tokens[2] != "999") {
            ,"dst_socket":"<$ tokens[2] $>"
%               }
        }<? it != last ? "," ?>
%           }
        ]
<%cpp>
        }
        zlist_destroy (&power);
    } else if ( type_byte == asset_type::GROUP ) {

        char *type = NULL;
        if ( ext_count > 0 ) {
            type = (char*) zhash_lookup(ext, "type");
        }
        if ( type == NULL ) {
            type = (char*) "";
        }
</%cpp>
    "type":"<$ (char*) type $>"
<%cpp>
    }

    if ( ext_count > 0 ) {
</%cpp>
    , "ext" : {
<%cpp>
        for ( i = 1, it = zhash_first(ext); it != 0;
                    i++,   it = zhash_next(ext) ) {
            if ( type_byte == asset_type::GROUP && !strcmp((char*) zhash_cursor (ext), "type") ) {
                continue;
            }
</%cpp>
        "<$ (char*) zhash_cursor (ext) $>":"<$ (char*)it $>"<? i != ext_count ? "," ?>
%       }
    }
%   }
}
<%cpp>
    zhash_destroy (&ext);
    asset_msg_destroy (&dta);
    asset_msg_destroy (&device);
</%cpp>
