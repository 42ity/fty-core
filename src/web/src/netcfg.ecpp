<#
 #
 # Copyright (C) 2015 Eaton
 #
 # This program is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation; either version 2 of the License, or
 # (at your option) any later version.
 #
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License along
 # with this program; if not, write to the Free Software Foundation, Inc.,
 # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 #
 #><#
/*!
 * \file netcfg.ecpp
 * \author Michal Hrusecky <MichalHrusecky@Eaton.com>
 * \author Tomas Halman <TomasHalman@Eaton.com>
 * \author Karol Hrdina <KarolHrdina@Eaton.com>
 * \brief Not yet documented file
 */
 #><%pre>
#include <cxxtools/split.h>
#include <cxxtools/jsondeserializer.h>
#include <cxxtools/regex.h>
#include <vector>
#include <string>
#include <string.h>

#include "subprocess.h"
#include "augtool.h"
#include "cidr.h"

using namespace shared;

</%pre>
<%cpp>
augtool* augeas = augtool::get_instance();
std::string command;
std::string nil;

// Make sure we have data that works
nil = augeas->get_cmd_out("ls /augeas/files/etc/network/interfaces/error");
if(!nil.empty()) {
</%cpp>
{ "error": "Syntax error in /etc/network/interfaces config file" }
<%cpp>
    return HTTP_INTERNAL_SERVER_ERROR;
}
nil = augeas->get_cmd_out("ls /augeas/files/etc/resolv.conf/error");
if(!nil.empty()) {
</%cpp>
{ "error": "Syntax error in /etc/resolv.conf config file" }
<%cpp>
    return HTTP_INTERNAL_SERVER_ERROR;
}

// Are we asked to just list possible configurations?
static cxxtools::Regex rex_ncfg("^.*/netcfgs$");
if(rex_ncfg.match(request.getUrl())) {
    std::string in;
    in = augeas->get_cmd_out("match /files/etc/network/interfaces/iface[*]",
							 true, "\", \"",
							 [](const std::string iface) -> bool {
							 	return iface == "lo";
							 }
							);
    if(in.empty()) {
</%cpp>
{ "error": "No configurable interfaces found" }
<%cpp>
        return HTTP_NOT_FOUND;
    }
</%cpp>
{ "netcfgs": [ "<$$ in $>" ] }
<%cpp>
    return HTTP_OK;
}

// We are discussing interface configuration, are we asked about real interface?
std::string iface = request.getArg("iface");
static cxxtools::Regex rex_anum("^[a-z0-9]+$");
if(!rex_anum.match(iface)) {
</%cpp>
{ "error": "Wrong interface name" }
<%cpp>
    return HTTP_BAD_REQUEST;
}

// Where is the tree reflecting the interface?
std::string address = augeas->get_cmd_out(
                      "match /files/etc/network/interfaces/iface[*] " + iface,
					  false);
if(address.empty()) {
</%cpp>
{ "error": "No configuration for interface <$ iface $> found" }
<%cpp>
    return HTTP_NOT_FOUND;
}

#define AUG_GET(NAME, VAL) \
    VAL = augeas->get_cmd_out("get " + address + "/" NAME);

std::string method;
AUG_GET("method", method);

// Modifications requested?
if(request.getMethod() == "PUT") {
    std::stringstream input(request.getBody(), std::ios_base::in);
    cxxtools::SerializationInfo si;
    cxxtools::SerializationInfo rsi;
    cxxtools::JsonDeserializer deserializer(input);
    std::string val;
    try {
        deserializer.deserialize(si);
    } catch(const std::exception& e) {
</%cpp>
{ "error": "Wrong json on input - <$ e.what() $>" }
<%cpp>
        return HTTP_BAD_REQUEST;
    }
    try {
        rsi = si.getMember(iface);
    } catch(const std::exception& e) {
</%cpp>
{ "error": "No configuration for interface <$ iface $> provided" }
<%cpp>
        return HTTP_BAD_REQUEST;
    }


// Gets configuration from json and sets it in config while verifying it matches regexp
#define AUG_SET(NAME, CHECK)         \
    if(it.name() == NAME) { \
        it.getValue(val); \
        if(! CHECK ) { \
            reply.out() << std::string("{ \"error\": \"Wrong value for '" NAME \
                                       "' setting or setting '" NAME "' not " \
                                       " expected for method ") + method + ".\" }"; \
            return HTTP_BAD_REQUEST; \
        } \
        augeas->run_cmd("set " + address + "/" NAME " " + val); \
        handled = true; \
    }

    // All the things we need to set
    for(auto it : rsi) {
        bool handled = false;
        static cxxtools::Regex rex_mtd("^(dhcp|static|none|manual)$");
        AUG_SET("method",  rex_mtd.match(method));
        AUG_GET("method",  method);
        AUG_SET("address", (CIDRAddress(val).valid()     && method == "static"));
        AUG_SET("netmask", (CIDRAddress(val).isNetmask() && method == "static"));
        AUG_SET("gateway", (CIDRAddress(val).valid()     && method == "static"));

        if(method != "static") {
            augeas->run_cmd("rm " + address + "/address");
            augeas->run_cmd("rm " + address + "/netmask");
            augeas->run_cmd("rm " + address + "/gateway");;
        }

        //DNS is array, handle differently
        if(it.name() == "nameservers") {
            if(it.category() != cxxtools::SerializationInfo::Category::Array) {
</%cpp>
{ "error": "Wrong value for DNS setting - array expected" }
<%cpp>
                return HTTP_BAD_REQUEST;
            }
            augeas->run_cmd("rm /files/etc/resolv.conf/nameserver");
            for(auto i : it) {
                i.getValue(val);
                if(!CIDRAddress(val).valid()) {
</%cpp>
{ "error": "Wrong value for DNS setting - array of IPs expected" }
<%cpp>
                    return HTTP_BAD_REQUEST;
                }
                augeas->run_cmd("set /files/etc/resolv.conf/nameserver[0] " + val);
            }
            handled = true;
        }
        if(!handled) {
</%cpp>
{ "error": "Invalid option '<$ it.name() $>'" }
<%cpp>
            return HTTP_BAD_REQUEST;
        }
    }

    // Commit everything
	augeas->save();

    // Make sure we have data that works
	nil = augeas->get_cmd_out("ls /augeas/files/etc/network/interfaces/error");
    if(!nil.empty()) {
</%cpp>
{ "error": "Syntax error in /etc/network/interfaces config file" }
<%cpp>
        return HTTP_INTERNAL_SERVER_ERROR;
    }
	nil = augeas->get_cmd_out("ls /augeas/files/etc/resolv.conf/error");
    if(!nil.empty()) {
</%cpp>
{ "error": "Syntax error in /etc/resolv.conf config file" }
<%cpp>
        return HTTP_INTERNAL_SERVER_ERROR;
    }

}

std::string ip, netmask, gateway, dns;
AUG_GET("method", method);
AUG_GET("address", ip);
AUG_GET("netmask", netmask);
AUG_GET("gateway", gateway);
dns = augeas->get_cmd_out("match /files/etc/resolv.conf/nameserver", true, "\", \"");

</%cpp>
{ "<$ iface $>":
    {
        "method": "<$ method $>"
% if(!ip.empty()) {
      , "address": "<$ ip $>"
% }
% if(!netmask.empty()) {
      , "netmask": "<$ netmask $>"
% }
% if(!gateway.empty()) {
      , "gateway": "<$ gateway $>"
% }
% if(!dns.empty()) {
      , "nameservers": [ "<$$ dns $>" ]
% }
    }
}
