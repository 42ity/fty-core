<#
 #
 # Copyright (C) 2015 Eaton
 #
 # This program is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation; either version 2 of the License, or
 # (at your option) any later version.
 #
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License along
 # with this program; if not, write to the Free Software Foundation, Inc.,
 # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 #
 #><#
/*!
 * \file iface.ecpp
 * \author Karol Hrdina <KarolHrdina@Eaton.com>
 * \author Michal Hrusecky <MichalHrusecky@Eaton.com>
 * \brief Not yet documented file
 */
 #><%pre>
#include <stdexcept>
#include <stdio.h>
#include <stdbool.h>
#include <ifaddrs.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <net/if.h>
#include <sys/ioctl.h>
#include <netinet/in.h>
#include <linux/ethtool.h>
#include <linux/sockios.h>
#include <map>
#include <set>
#include <vector>
#include <string>
#include <string.h>
#include <unistd.h>
#include <fstream>
#include <sstream>
#include <cxxtools/regex.h>

#include "log.h"
#include "utils_web.h"
#include "helpers.h"

struct iface {
   std::vector<std::string> ip;
   std::vector<std::string> netmask;
   std::string state;
   std::string gateway;
   std::string cable;
   std::string mac;
};

std::set<std::string> get_ifaces() {
   std::set<std::string> ret;
   struct ifaddrs* start = NULL;
   if(getifaddrs(&start) != 0)
      return ret;
   struct ifaddrs* it = start;
   while(it != NULL) {
      ret.insert(it->ifa_name);
      it = it->ifa_next;
   }
   return ret;
}

iface get_iface(std::string iface) {
   struct iface ret;
   struct ifaddrs* start = NULL;
   if(getifaddrs(&start) != 0)
      return ret;
   struct ifaddrs* it = start;
   while(it != NULL) {
      if(it->ifa_name != iface) {
         it = it->ifa_next;
         continue;
      }
      ret.state = (it->ifa_flags & IFF_UP) ? "up" : "down";
      struct ifreq ifr;
      struct ethtool_value edata;

      memset(&ifr, 0, sizeof(ifr));
      strncpy(ifr.ifr_name, it->ifa_name, sizeof(ifr.ifr_name)-1);

      edata.cmd = ETHTOOL_GLINK;

      int fd = socket(PF_INET, SOCK_DGRAM, 0);
      if(ret.mac.empty() && ioctl(fd, SIOCGIFHWADDR, &ifr) != -1) {
         char buff[3];
         memset(buff, 0, sizeof buff);
         for(int i = 0; i < 6; ++i) {
            if(!ret.mac.empty()) {
               ret.mac += ":";
            }
            sprintf(buff, "%02x", (unsigned char) ifr.ifr_addr.sa_data[i]);
            ret.mac += buff;
         }
      }

      ifr.ifr_flags = it->ifa_flags | IFF_UP;
      if((it->ifa_flags & IFF_UP) || (ioctl(fd, SIOCSIFFLAGS, &ifr) != -1)) {
         // To detect link interface has to be up for some time
         if((it->ifa_flags & IFF_UP) == 0)
            sleep(5);
         ifr.ifr_data = (caddr_t) &edata;
         if(ioctl(fd, SIOCETHTOOL, &ifr) != -1) {
            ret.cable = edata.data ? "yes" : "no";
         }
         if((it->ifa_flags & IFF_UP) == 0) {
            ifr.ifr_data = NULL;
            ifr.ifr_flags = it->ifa_flags;
            ioctl(fd, SIOCSIFFLAGS, &ifr);
         }
      } else {
         ret.cable = "unknown";
      }
      close(fd);

      if(it->ifa_addr->sa_family == AF_INET) {
         ret.ip.push_back(inet_ntoa(((struct sockaddr_in*)(it->ifa_addr))->sin_addr));
         ret.netmask.push_back(inet_ntoa(((struct sockaddr_in*)(it->ifa_netmask))->sin_addr));
      }
      it = it->ifa_next;
   }
   freeifaddrs(start);
   return ret;
}
</%pre>
<%request scope="global">
UserInfo user;
</%request>
<%cpp>
    // check user permissions
    static const std::map <BiosProfile, std::string> PERMISSIONS = {
            {BiosProfile::Admin,     "E"}
            };
    CHECK_USER_PERMISSIONS_OR_DIE (PERMISSIONS);

// Are we asked to just list possible configurations?
cxxtools::Regex rex("^.*/ifaces$");
if(rex.match(request.getUrl())) {
    bool first = true;
</%cpp>
{ "ifaces": [
%   for(auto i: get_ifaces()) {
    <$ first ? "  " : ", " $>"<$ i $>"
%       first = false;
%   }
] }
<%cpp>
    return HTTP_OK;
}

std::string checked_iface;

{
    std::string iface = request.getArg("iface");
    if (iface.empty ()) {
        http_die ("request-param-required", "iface");
    }
    check_regex_text_or_die ("iface", iface, checked_iface, "^[a-z][a-z0-9]{0,14}$");
}

auto dta = get_iface(checked_iface);
if(dta.mac.empty()) {
    http_die ("request-param-bad", "iface_name",
        std::string ("value that does not exist '").append (checked_iface).append ("'").c_str (),
        "one of valid interface names that can be obtained using GET 'admin/ifaces'.");
}

if (dta.ip.size () != dta.netmask.size ()) {
    http_die ("internal-error",
        std::string ("Number of ip addresses '").append (std::to_string (dta.ip.size ())).append ("' do not match number of netmasks '").
        append (std::to_string (dta.netmask.size ())).append ("'.").c_str ());
}

bool first = true;
std::string nameservers, gateway, ipaddrs;
// IP addresses
ipaddrs.assign ("[");
for (std::vector<std::string>::size_type i = 0; i < dta.ip.size (); ++i) {
    ipaddrs.append (first ? " " : ", ").append ("{ \"address\" : \"").append (dta.ip.at (i)).
            append ("\", \"netmask\" : \"").append (dta.netmask.at (i)).append ("\" }");
    first = false;
}
ipaddrs.append (" ]");

try {
    // Nameservers
    cxxtools::RegexSMatch smatch;
    cxxtools::Regex rex2("^\\s*nameserver\\s+(\\S+).*$");

    std::ifstream infile("/etc/resolv.conf");
    std::string fline;
    first = true;
    nameservers.assign ("[");
    while (std::getline(infile, fline))
    {
        if (rex2.match (fline, smatch)) {
            nameservers.append (first ? " " : ", ").append ("\"").append (smatch.get (1)).append ("\"");
            first = false;
        }
    }
    nameservers.append (" ]");
    // No need to close ifstream.

    // Gateway
    FILE* pipe = popen ("ip route show", "r");
    if (!pipe) {
        throw std::runtime_error ("popen ('ip route show', 'r') failed.");
    }
    char buffer[256];
    std::string result;

    while (!feof (pipe)) {
        if (fgets (buffer, 256, pipe) != NULL)
            result += buffer;
    }
    pclose(pipe);
    cxxtools::Regex rex3("default\\s+via\\s+(\\S+)");
    if (rex3.match (result, smatch)) {
        gateway.assign (smatch.get (1));
    }
    else {
        throw std::runtime_error ("Could not match default gateway from `ip route show`.");
    }
} catch (const std::exception& e) {
    log_error ("Exception caught: %s", e.what ());
    http_die ("internal-error", "Exception caught." );
}

// Print out the result
</%cpp>
{
    "<$ checked_iface $>": {
        "state": "<$ dta.state $>",
        "ip": <$$ ipaddrs $>,
        "gateway": "<$ gateway $>",
        "link": "<$ dta.cable $>",
        "mac" : "<$ dta.mac $>",
        "nameservers" : <$$ nameservers $>
    }
}

