<#
 #
 # Copyright (C) 2015 Eaton
 #
 # This program is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation; either version 2 of the License, or
 # (at your option) any later version.
 #
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License along
 # with this program; if not, write to the Free Software Foundation, Inc.,
 # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 #
 #><#
/*!
 * \file uptime.ecpp
 * \author Alena Chernikava <AlenaChernikava@Eaton.com>
 * \brief Not yet documented file
 */
 #><%pre>

#include <cxxtools/split.h>
#include <tntdb/error.h>
#include "data.h"
#include "dbpath.h"
#include "db/calculation.h"
#include "utils_web.h"
#include "log.h"

</%pre>

<%args>
std::string arg1;
</%args>

<%thread scope="global">
asset_manager asset_mgr;
</%thread>

<%cpp>
    // Input arguments checks

    // arg1 is mandatory
    if (arg1.empty ()) {
        http_die ("request-param-required", "arg1");
    }

    std::vector<std::string> DCs;
    std::vector<std::string> DCNames;
    cxxtools::split(",", arg1, std::back_inserter(DCs));

    // check that DC exists
    auto allDcsShort = asset_mgr.get_items1 ("datacenter", "");
    if (allDcsShort.status == 0) {
        http_die ("internal-error", "Error while retrieving information about datacenters.");
    }

    for (auto const& item : DCs) {
        // id_asset_element is defined as 'INT UNSIGNED' in tools/initdb.sql
        uint32_t real_id = 0;
        try {
            real_id = utils::string_to_element_id (item);
        }
        catch (const std::invalid_argument& e) {
            http_die ("request-param-bad", "element_id",
                std::string ("value '").append (item).append ("'").append (" is not an element identifier").c_str (),
                std::string ("an unsigned integer in range 1 to ").append (std::to_string (UINT_MAX)).append (".").c_str ());
        }
        catch (const std::out_of_range& e) {
            http_die ("request-param-bad", "element_id",
                std::string ("value '").append (item).append ("'").append (" is out of range").c_str (),
                std::string ("value in range 1 to ").append (std::to_string (UINT_MAX)).append (".").c_str ());
        }
        catch (const std::exception& e) {
            log_error ("std::exception caught: %s", e.what ());
            http_die ("internal-error");
        }

        auto it = allDcsShort.item.find(real_id);
        if (it == allDcsShort.item.end()) {
            http_die ("element-not-found", item.c_str ());
        }
        DCNames.push_back(it->second);
    }

    std::stringstream json;
    try {
        tntdb::Connection conn = tntdb::connectCached (url);

        json << "{\n\t\"outage\": [\n";

        for ( size_t D = 0 ; D < DCs.size(); D++ ) 
        {

            int64_t uptime = 0;
            int64_t total = 0 ;
            int rv = persist::calculate_uptime_total_byDcId
                (conn, atoi(DCs[D].c_str()), uptime, total);

            json << "\t\t{\n"
                 << "\t\t\t\"id\": \""   << DCs[D]           << "\",\n"
                 << "\t\t\t\"name\": \"" << DCNames[D]       << "\",\n"
                 << "\t\t\t\"outage\" : "<<  total - uptime  <<   ",\n"
                 << "\t\t\t\"total\" : " <<  total           <<    "\n";
            json << "\t\t}" << (  D < DCs.size() -1 ? ",\n" : "\n" );
        }
        json << "\t]\n}\n";
    }
    catch (const tntdb::Error& e) {
        log_error ("%s", e.what ());
        http_die ("internal-error", "Database related error.");
    }
    catch (const std::exception& e) {
        log_error ("%s", e.what ());
        http_die ("internal-error");
    }
</%cpp>
<$$ json.str() $>
