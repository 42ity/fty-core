<#
 #
 # Copyright (C) 2015 Eaton
 #
 # This program is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation; either version 2 of the License, or
 # (at your option) any later version.
 #
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License along
 # with this program; if not, write to the Free Software Foundation, Inc.,
 # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 #
 #><#
/*!
 * \file topology_location_to.ecpp
 * \author Karol Hrdina <KarolHrdina@Eaton.com>
 * \author Michal Hrusecky <MichalHrusecky@Eaton.com>
 * \author Alena Chernikava <AlenaChernikava@Eaton.com>
 * \brief process location topology requests (to)
 */
 #><%pre>
#include <string>
#include <exception>
#include <stack>
#include <czmq.h>

#include "log.h"
#include "defs.h"
#include "dbpath.h"
#include "data.h"
#include "location_helpers.h"
#include "asset_types.h"
#include "assettopology.h"
#include "utils_web.h"
#include "cleanup.h"
#include "helpers.h"
</%pre>
<%request scope="global">
UserInfo user;
</%request>
<%cpp>
{
    // check user permissions
    static const std::map <BiosProfile, std::string> PERMISSIONS = {
            {BiosProfile::Dashboard, "R"},
            {BiosProfile::Admin,     "R"}
            };
    CHECK_USER_PERMISSIONS_OR_DIE (PERMISSIONS);

    // checked parameters
    a_elmnt_id_t checked_to = 0;

    // ##################################################
    // BLOCK 1
    // Sanity parameter check
    {
        std::string to = qparam.param("to");
        std::string recursive = qparam.param("recursive");
        std::string filter = qparam.param("filter");
        std::string feed_by = qparam.param("feed_by");

        if ( to.empty() ) {
            // At least one parametr should be specified
            http_die("request-param-required", "from/to");
        }

        // 1. 'recursive' cannot be specified with 'to'
        if ( !recursive.empty() ) {
            http_die("parameter-conflict", "Parameter 'recursive' can not be specified with parameter 'to'.");
        }
        // 2. 'filter' cannot be specified with 'to'
        if ( !filter.empty() ) {
            http_die("parameter-conflict", "Parameter 'filter' can not be specified with parameter 'to'.");
        }
        // 3. 'feed_by' cannot be specified with 'to'
        if ( !feed_by.empty() ) {
            http_die("parameter-conflict", "Parameter 'feed_by' can not be specified with parameter 'to'.");
        }

        // Try to convert string to number
        http_errors_t errors;
        if (!check_element_identifier ("to", to, checked_to, errors)) {
            http_die_error (errors);
        }
    }
    // Sanity check end

    // ##################################################
    // BLOCK 2
    // Call persistence layer
    _scoped_asset_msg_t *input_msg = asset_msg_new (ASSET_MSG_GET_LOCATION_TO);
    assert (input_msg);
    asset_msg_set_element_id (input_msg, checked_to);

    _scoped_zmsg_t *return_msg = process_assettopology (url.c_str(), &input_msg);
    if (return_msg == NULL) {
        log_error ("Function process_assettopology() returned a null pointer");
        LOG_END;
        http_die("internal-error");
    }
    assert (input_msg == NULL); // This is not testing czmq. It tests whether our code correctly nullifies a reference

    if (is_common_msg (return_msg)) {
        _scoped_common_msg_t *common_msg = common_msg_decode (&return_msg);
        if (common_msg == NULL) {
            if (return_msg != NULL) {
                zmsg_destroy (&return_msg);
            }
            log_error ("common_msg_decode() failed");
            LOG_END;
            http_die("internal-error");
        }

        if (common_msg_id (common_msg) == COMMON_MSG_FAIL) {
            log_error ("common_msg is COMMON_MSG_FAIL");
            LOG_END;
            switch(common_msg_errorno(common_msg)) {
                case(DB_ERROR_NOTFOUND):
                    http_die("element-not-found", std::to_string(checked_to).c_str());
                case(DB_ERROR_BADINPUT):
                default:
                    http_die("internal-error");
            }
        }
        else {
            log_error ("Unexpected common_msg received. ID = %" PRIu32 , common_msg_id (common_msg));
            LOG_END;
            http_die("internal-error", "");
        }
    }
    else if (is_asset_msg (return_msg)) {
        _scoped_asset_msg_t *asset_msg = asset_msg_decode (&return_msg);
        if (asset_msg == NULL) {
            if (return_msg != NULL) {
                zmsg_destroy (&return_msg);
            }
            log_error ("asset_msg_decode() failed");
            LOG_END;
            http_die("internal-error");
        }

        // <checked_to, type, contains, name, type_name>
        std::stack<std::tuple <int, int, std::string, std::string, std::string>> stack;
        std::string contains;

        if (asset_msg_id (asset_msg) == ASSET_MSG_RETURN_LOCATION_TO) {
            bool go = true;
            do {
                checked_to = asset_msg_element_id (asset_msg);
                int type_id = asset_msg_type (asset_msg);
                std::string name = asset_msg_name (asset_msg);
                std::string type_name = asset_msg_type_name (asset_msg);
                stack.push (make_tuple(checked_to, type_id, contains, name, type_name));
                // I deliberately didn't want to use asset manager (unknown / ""; suffix s)
                // TODO use special function
                switch (type_id) {
                    case persist::asset_type::DATACENTER:
                    {
                        contains = "datacenters";
                        break;
                    }
                    case persist::asset_type::ROOM:
                    {
                        contains = "rooms";
                        break;
                    }
                    case persist::asset_type::ROW:
                    {
                        contains = "rows";
                        break;
                    }
                    case persist::asset_type::RACK:
                    {
                        contains = "racks";
                        break;
                    }
                    case persist::asset_type::GROUP:
                    {
                        contains = "groups";
                        break;
                    }
                    case persist::asset_type::DEVICE:
                    {
                        contains = "devices";
                        break;
                    }
                    default:
                    {
                        log_error ("Unexpected asset type received in the response");
                        LOG_END;
                        http_die("internal-error");
                    }
                }

                if (zmsg_size (asset_msg_msg (asset_msg)) != 0) {
                    _scoped_zmsg_t *inner = asset_msg_get_msg (asset_msg);
                    asset_msg_destroy (&asset_msg);
                    asset_msg = asset_msg_decode (&inner);

                    if (asset_msg == NULL) {
                        if (inner != NULL) {
                            zmsg_destroy (&inner);
                        }
                        log_error ("asset_msg_decode() failed");
                        LOG_END;
                        http_die("internal-error");
                    }

                    go = true;
                } else {
                    asset_msg_destroy (&asset_msg);
                    go = false;
                }
            } while (go == true);

            // Now go from top -> down
            int counter = 0;
            int indent = 0;
            std::string json = "{\n";

            while ( !stack.empty() ) {
                // <checked_to, type, contains, name, type_name>
                std::tuple<int, int, std::string, std::string, std::string> row = stack.top();
                stack.pop();

                indent++;
                if (!std::get<2>(row).empty()) {
                    counter++;
                    for (int i = 0; i < indent; i++) {
                        json.append ("\t");
                    }
                    json.append("\"name\" : \"")
                        .append(utils::json::escape (std::get<3>(row)))
                        .append("\",\n");
                    for (int i = 0; i < indent; i++) {
                        json.append ("\t");
                    }
                    json.append("\"id\" : \"")
                        .append(std::to_string(std::get<0>(row)))
                        .append("\",\n");
                    if (std::get<4>(row) != "N_A") { // magic constant from initdb.sql
                        for (int i = 0; i < indent; i++) {
                            json.append ("\t");
                        }
                        json.append("\"type\" : \"")
                            .append(std::get<4>(row))
                            .append("\"\n");
                    }
                    for (int i = 0; i < indent; i++) {
                        json.append ("\t");
                    }
                    json.append("\"contains\" : { \"")
                        .append(std::get<2>(row))
                        .append("\" : [{\n");
                } else {
                    for (int i = 0; i < indent; i++) {
                        json.append ("\t");
                    }
                    json.append("\"name\" : \"")
                        .append(utils::json::escape (std::get<3>(row)))
                        .append("\",\n");
                    for (int i = 0; i < indent; i++) {
                        json.append ("\t");
                    }
                    json.append("\"id\" : \"")
                        .append(std::to_string(std::get<0>(row)))
                        .append("\"");
                    json.append(",\n");
                    json += "\"type\" : \"" + persist::typeid_to_type(std::get<1>(row)) + "\",";
                    for (int i = 0; i < indent; i++) {
                        json.append ("\t");
                    }
                    json.append("\"sub_type\" : \"")
                        .append(std::get<4>(row))
                        .append("\"\n");
                }

            }
            for (int i = counter; i > 0; i--) {
                indent--;
                for (int j = 0; j < indent; j++) {
                    json.append ("\t");
                }
                json.append ("}]}\n");
            }
            json.append ("}");
</%cpp>
<$$ json $>
<%cpp>
        }
        else {
            log_error ("Unexpected asset_msg received. ID = %" PRIu32 , asset_msg_id (asset_msg));
            LOG_END;
            http_die("internal-error");
        }
    }
    else {
        log_error ("Unknown protocol");
        LOG_END;
        http_die("internal-error");

    }
}
</%cpp>
