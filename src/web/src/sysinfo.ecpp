<%pre>
#include <iostream>
#include <sstream>
#include <cxxtools/regex.h>
#include <cxxtools/jsondeserializer.h>
#include "subprocess.h"
#include <sys/utsname.h>
#include "config.h"

static std::string chomp(std::string data) {
	/* TODO: replace inner newlines by "\n" strings */
	data.resize( data.find_last_not_of('\n')+1 );
	return data;
}

static int output2(const shared::Argv& args, std::string& o, std::string& e) {
    int ret = shared::output(args, o, e);
    o = chomp(o);
    e = chomp(e);
    return ret;
}

</%pre>
<%request scope="global">
int8_t access_auth_level;
</%request>
<%cpp>

#ifdef DEBUG
	std::ostringstream os;
	os << "access_auth_level=\"" << access_auth_level << "\"";
	reply.setHeader( (std::string)"X-Auth-Require: ", os.str() );
#endif

</%cpp>
{
  "operating-system" : {
<%cpp>
	std::string cmdout;
	std::string cmderr;
	static const std::string UNKNOWN = "unknown";
	static const std::string UNAUTHORIZED = "unauthorized";
	static const std::string AVAILABLE = "available";
	int ret;

</%cpp>
<%cpp>
	/* TODO: This currently relies on "systemd-detect-virt" - what about OSes that do not have it? */

	/* Detect container virtualization */
    ret = output2({"/usr/bin/systemd-detect-virt", "-c"}, cmdout, cmderr);
</%cpp>
    "container": "<$ ret == 0 ? cmdout : UNKNOWN $>",
<%cpp>
	/* Detect VM virtualization */
    ret = output2({"/usr/bin/systemd-detect-virt", "-v"}, cmdout, cmderr);
</%cpp>
    "hypervisor": "<$ ret == 0 ? cmdout : UNKNOWN $>",
    "uname": {
<%cpp>
    struct utsname u;
    ret = uname(&u);
    if (ret == -1) {
        return HTTP_INTERNAL_SERVER_ERROR;
    }
</%cpp>
      "sysname": "<$ (char*) u.sysname $>",
      "nodename" : "<$ (char*) u.nodename $>",
      "release": "<$ (access_auth_level<1) ? UNAUTHORIZED : (char*) u.release $>",
      "version": "<$ (access_auth_level<1) ? UNAUTHORIZED : (char*) u.version $>",
      "machine": "<$ (char*) u.machine $>"
    }
  },
  "$BIOS": {
    "packages": [
      { "package-name": "<$ PACKAGE $>",
        "package-version": "<$ PACKAGE_VERSION $>",
        "package-bugreport": "<$ PACKAGE_BUGREPORT $>",
        "package-url": "<$ PACKAGE_URL $>",
        "vendor": "Eaton"
<%cpp>
      if (access_auth_level>1) {
#ifdef HAVE_PACKAGE_GIT
</%cpp>
      , "source-repo": {
          "scm": "git",
          "origin": "<$ PACKAGE_GIT_ORIGIN_ESCAPED $>",
          "branch": "<$ PACKAGE_GIT_BRANCH_ESCAPED $>",
          "commit": "<$ PACKAGE_GIT_HASH_L_ESCAPED $>",
          "commit-timestamp": "<$ PACKAGE_GIT_TSTAMP_ESCAPED $>",
          "status": "<$$ PACKAGE_GIT_STATUS_ESCAPED $>"
        }
<%cpp>
#endif // HAVE_PACKAGE_GIT
#if defined(HAVE_PACKAGE_BUILD_HOST) || defined(HAVE_PACKAGE_BUILD_TSTAMP)
</%cpp>
      , "build-info": {
<%cpp>
# ifdef HAVE_PACKAGE_BUILD_HOST
</%cpp>
          "build-host-name": "<$ PACKAGE_BUILD_HOST_NAME_ESCAPED $>",
          "build-host-os": "<$ PACKAGE_BUILD_HOST_OS_ESCAPED $>",
          "build-host-uname": "<$ PACKAGE_BUILD_HOST_UNAME_ESCAPED $>",
          "build-timestamp":
<%cpp>
# endif // HAVE_PACKAGE_BUILD_HOST
# if defined(HAVE_PACKAGE_BUILD_TSTAMP) && defined(PACKAGE_BUILD_TSTAMP)
</%cpp>
              "<$ PACKAGE_BUILD_TSTAMP_ESCAPED $>"
<%cpp>
# else // not HAVE_PACKAGE_BUILD_TSTAMP
</%cpp>
              "<$ UNKNOWN $>"
<%cpp>
# endif // HAVE_PACKAGE_BUILD_TSTAMP
</%cpp>
        }
<%cpp>
#endif // HAVE_PACKAGE_BUILD_*: HOST and/or TSTAMP
      } // if (access_auth_level>1)
</%cpp>
      }
    ],
    "main-process-status" :
<%cpp>
      if (access_auth_level<1) {
</%cpp>
        "<$ UNAUTHORIZED $>"
<%cpp>
      } else { // (access_auth_level>=1)
          /* The monster shell below should be parsable by about any POSIX shell
             I am less sure about capabilities of "ps" programs in constrained
             environments and/or other OSes... however for a predefined target
             platform this should do :) */

          // A glob usable by shell "case":
          std::string interesting_basenames;
          interesting_basenames = "mysqld|upsd|saslauthd|tntnet|simple|netmon|driver-nmap";
          //testing-hack// interesting_basenames = "abc";

          std::ostringstream psgrep;
          /* TODO: Consider escaping the $ARGS, possibly $CMD and maybe others */
          psgrep  << "/bin/ps -ewww -o pid,ppid,user,tty,state,time,command | "
                  << "( NF=\"\"; "
                  << "while read _P _PP _U _TTY _STATE _TIMECPU CMD ARGS; do "
                  << "case \"`basename \"$CMD\" 2>/dev/null`\" in "
                  << interesting_basenames <<") echo \"$NF\"\'{"
                  << "\"process\":\"\'\"$CMD\"\'\",\"args\":\"\'\"$ARGS\"\'\","
                  << "\"process-pid\":\'\"$_P\"\',\"parent-pid\":\'\"$_PP\"\',"
                  << "\"user-name\":\"\'\"$_U\"\'\",\"tty\":\"\'\"$_TTY\"\'\","
                  << "\"process-state\":\"\'\"$_STATE\"\'\","
                  << "\"process-time-cpu\":\"\'\"$_TIMECPU\"\'\""
                  << "}\'; NF=\",\"; esac; done )" ;

          ret = output2({"/bin/sh", "-c", psgrep.str()},
                        cmdout, cmderr);
          if (ret != 0 || cmdout == "") {
</%cpp>
        "<$ UNKNOWN $>"
<%cpp>
          } else { // ret == 0
</%cpp>
        "<$ AVAILABLE $>"
  , "main-process-details": [
<$$ cmdout $>
    ]
<%cpp>
          } // ret == 0
      } // if (access_auth_level>=1)
</%cpp>
  }
}
