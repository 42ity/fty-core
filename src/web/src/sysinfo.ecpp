<#
 #
 # Copyright (C) 2015 Eaton
 #
 # This program is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation; either version 2 of the License, or
 # (at your option) any later version.
 #
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License along
 # with this program; if not, write to the Free Software Foundation, Inc.,
 # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 #
 #><#
/*!
 * \file    sysinfo.ecpp
 * \author  Jim Klimov <EvgenyKlimov@Eaton.com>
 * \author  Michal Vyskocil <MichalVyskocil@Eaton.com>
 * \author  Karol Hrdina <KarolHrdina@Eaton.com>
 * \brief   This REST API call returns information about the OS
 * \details This REST API call returns information about the operating
 *          environment for the installed OS image, including packages
 *          and states of services related or important to BIOS project.
 *          Note that this no longer reports raw process information as
 *          might be relevant to a developer's workspace or to packaging
 *          in some OS other than the primary development target NFC OS.
 */
 #><%pre>
#include <vector>
#include <fstream>
#include <stdexcept>
#include <sys/utsname.h>
#include <tntdb/connect.h>
#include <cxxtools/split.h>
#include <cxxtools/regex.h>
#include "auth_levels.h"
#include "utils_web.h"
#include "subprocess.h"
#include "log.h"
#include "dbpath.h"
#include "assets.h"
#include "asset_types.h"
#include "utils.h"

// Magic numbers - systemctl fancy formatting du-jour
#ifndef SYSTEMCTL__LIST_UNITS__STRIP_HEADER
#define SYSTEMCTL__LIST_UNITS__STRIP_HEADER 1
#endif

#ifndef SYSTEMCTL__LIST_UNITS__STRIP_FOOTER
#define SYSTEMCTL__LIST_UNITS__STRIP_FOOTER 7
#endif

#ifndef DPKG__LIST__STRIP_HEADER
#define DPKG__LIST__STRIP_HEADER 5
#endif

#ifndef DPKG__LIST__COLUMN_PKGNAME
#define DPKG__LIST__COLUMN_PKGNAME 1
#endif

#ifndef DPKG__LIST__COLUMN_PKGVERSION
#define DPKG__LIST__COLUMN_PKGVERSION 2
#endif

</%pre>
<%request scope="global">
int8_t access_auth_level;
</%request>
{
    "operating-system" : {
<%cpp>
    std::string output, cmderr;

// Certain strings returned to caller in some cases
    static const std::string UNKNOWN = "unknown";
    static const std::string UNAUTHORIZED = "unauthorized";
    static const std::string AVAILABLE = "available";
    static const std::string NOTAVAILABLE = "N/A";
    static const std::string NOTLICENSEDYET = "License not accepted yet";

    int rv = shared::output ({"/usr/bin/systemd-detect-virt", "-c"}, output, cmderr);
    if (rv != 0) {
        output = NOTAVAILABLE;
    } else {
        size_t output_len = output.length();
        if (output_len>0 && output[output_len-1] == '\n') {
            output[output_len-1] = '\0';
        }
    }
</%cpp>
        <$$ utils::json::jsonify ("container", output.c_str()) $>,
<%cpp>
    rv = shared::output ({"/usr/bin/systemd-detect-virt", "-v"}, output, cmderr);
    if (rv != 0) {
        output = NOTAVAILABLE;
    } else {
        size_t output_len = output.length();
        if (output_len>0 && output[output_len-1] == '\n') {
            output[output_len-1] = '\0';
        }
    }
</%cpp>
        <$$ utils::json::jsonify ("hypervisor", output.c_str()) $>,
<%cpp>
    struct utsname u;
    if (uname (&u) == -1) {
        http_die ("internal-error", "uname() failed.");
    }
</%cpp>
        "uname": {
            <$$ utils::json::jsonify ("sysname", (char*) u.sysname) $>,
            <$$ utils::json::jsonify ("nodename", (char*) u.nodename) $>,
            <$$ utils::json::jsonify ("release", (access_auth_level<=AUTH_LEVEL_ANONYMOUS) ? UNAUTHORIZED : (char*) u.release) $>,
            <$$ utils::json::jsonify ("version", (access_auth_level<=AUTH_LEVEL_ANONYMOUS) ? UNAUTHORIZED : (char*) u.version) $>,
            <$$ utils::json::jsonify ("machine", (char*) u.machine) $>
        }
<%cpp>
    std::string installation_date = NOTLICENSEDYET;
    char *accepted_license = accepted_license_file ();
    if (accepted_license) {
        try {
            std::ifstream finput (accepted_license);
            if (finput.is_open () && finput.good ()) {
                // We assume the second line is license acceptance unix time
                std::getline (finput, installation_date);
                std::getline (finput, installation_date);
                int64_t i64 = std::stoll (installation_date);
                // TODO: we should probably check for time_t max/min, but hey!... ;)
                char chtmp[64];
                if (calendar_to_datetime ((time_t) i64, chtmp, 64) == -1) {
                    installation_date = "N/A - Error retrieveing installation date";
                    throw std::runtime_error ("calendar_to_datetime () failed.");
                }
                installation_date.assign (chtmp);
            }
            else {
                installation_date = NOTLICENSEDYET;
            }
        } catch (const std::exception& e) {
            log_error ("Exception caught: %s", e.what ());
        }
        free (accepted_license); accepted_license = NULL;
    }
</%cpp>
      , <$$ utils::json::jsonify ("installation-date", installation_date) $>
<%cpp>
    std::string location = "N/A - Error retrieving location";
    bool do_break = false;
    try {
        tntdb::Connection conn = tntdb::connectCached(url);
        db_reply <std::map <uint32_t, std::string>>
        elements = persist::select_short_elements (conn, persist::asset_type::DATACENTER, persist::asset_subtype::N_A);
        for (std::map<uint32_t, std::string>::const_iterator it = elements.item.cbegin(); it != elements.item.cend(); ++it) {
            // it->first is element_id
            std::map <std::string, std::pair<std::string, bool>> ext;
            int rv = persist::select_ext_attributes (conn, it->first, ext);
            if (rv == -1) {
                continue;
            }
            for (std::map <std::string, std::pair<std::string, bool>>::const_iterator it2 = ext.cbegin(); it2 != ext.cend (); ++it2) {
                if (it2->first.compare ("address") == 0) {
                    location = it2->second.first;
                    do_break = true;
                    break;
                }
            }
            if (do_break)
                break;
        }
    } catch (const std::exception& e) {
        log_error ("Exception caught: %s", e.what ());
    }
</%cpp>
      , <$$ utils::json::jsonify ("location", location) $>
    }
<%cpp>
    if (access_auth_level >= AUTH_LEVEL_POWERUSER) {
        rv = shared::output ({"dpkg", "--list"}, output, cmderr);
	if (!cmderr.empty()) {
            log_error("Calling 'dpkg --list' got exit-code %i and this stderr:\n-----\n%s-----\n\n", rv, cmderr.c_str());
        }
#ifdef DEBUG
        log_debug("Calling 'dpkg --list' got exit-code %i and this stdout:\n-----\n%s-----\n\n", rv, output.c_str());
#endif
        if (rv == 0 && !output.empty()) {
</%cpp>
,   "packages" : [
<%cpp>
            std::vector<std::string> tokens;
            cxxtools::split ("\n", output, std::back_inserter (tokens));
            // Strip first 5 lines
            for (int i = 0; i < DPKG__LIST__STRIP_HEADER; i++)
                tokens.erase (tokens.begin ());
            bool first = true;
            for (auto const& item : tokens) {
                if (item.empty ())
                    continue;
                std::vector <std::string> line_tokens;
                cxxtools::split (cxxtools::Regex("[ \t]+"), item, std::back_inserter (line_tokens));
                std::string pkgname, version, commit;
                pkgname = line_tokens.at (DPKG__LIST__COLUMN_PKGNAME);
                auto pos = line_tokens.at (DPKG__LIST__COLUMN_PKGVERSION).find ("~");
                if (pos != std::string::npos) {
                    version = line_tokens.at (DPKG__LIST__COLUMN_PKGVERSION).substr (0, pos);
                    commit = line_tokens.at (DPKG__LIST__COLUMN_PKGVERSION).substr (pos+1);
                }
                else {
                    version = line_tokens.at (DPKG__LIST__COLUMN_PKGVERSION);

                }
// Note: Shall we desire maintainers name etc...
//                rv = shared::output ({"dpkg", "status", pkgname.c_str ()}, output, cmderr);
//                if (rv == 0 && !output.empty()) {
//                      Parse `dpkg status <pkgname>` here
//                }
</%cpp>
%               if (first) {
            {
%                   first = false;
%               }
%               else {
          , {
%               }
                <$$ utils::json::jsonify ("package-name", pkgname) $>,
                <$$ utils::json::jsonify ("package-version", version) $>
%               if (pos != std::string::npos) {
              , <$$ utils::json::jsonify ("commit", commit) $>
%               }
            }
%           }
    ]
%       }
<%cpp>
// Note: Commands and unit names are constrained in tools/systemctl and web/systemctl.ecpp
// TODO: Maybe parsing 'systemctl show -l *' to get per-service info and apply
//   the filters defined for web/systemctl.ecpp would be more efficient than
//   calling the script dozens of times?
        rv = shared::output ({"sudo", "systemctl", "list-units", "--all", "--full"}, output, cmderr);
	if (!cmderr.empty()) {
            log_error("Calling 'systemctl list-units -a -l' got exit-code %i and this stderr:\n-----\n%s-----\n\n", rv, cmderr.c_str());
        }
#ifdef DEBUG
        log_debug("Calling 'systemctl list-units -a -l' got exit-code %i and this stdout:\n-----\n%s-----\n\n", rv, output.c_str());
#endif
        if (rv == 0 && !output.empty()) {
</%cpp>
,   "processes" : [
<%cpp>
            std::vector<std::string> tokens;
            cxxtools::split("\n", output, std::back_inserter (tokens));
            // Strip first 1 lines
            for (int i = 0; i < SYSTEMCTL__LIST_UNITS__STRIP_HEADER; i++)
                tokens.erase (tokens.begin ());
            // Strip last 7 lines
            for (int i = 0; i < SYSTEMCTL__LIST_UNITS__STRIP_FOOTER; i++)
                tokens.erase (tokens.end ());
            bool first = true;
            for (auto const& item : tokens) {
                int token_unitname=0;
                if (item.empty ())
                    continue;
                std::vector <std::string> line_tokens;
                cxxtools::split (" \t", item, std::back_inserter (line_tokens));
                // status
		if (line_tokens.at (0).compare ("*") == 0)
	            token_unitname=1;
		while (line_tokens.at (token_unitname).compare ("") == 0 ||
		       line_tokens.at (token_unitname).compare ({'\t'}) == 0 ||
		       line_tokens.at (token_unitname).compare (" ") == 0 )
	            token_unitname++;
		std::string unitname = line_tokens.at (token_unitname);
// Note: unitname must be the "$2" for our systemctl script
	        rv = shared::output ({"sudo", "systemctl", "show", unitname.c_str(), "--full"}, output, cmderr);

		if (!cmderr.empty() && !cmderr.compare("Action not allowed")) {
// Note: Here we filter by the stderr contents because it will be
// full of units we do not have right to access in our systemctl script
	            log_error("Calling 'systemctl show -l %s' got exit-code %i and this stderr:\n-----\n%s-----\n\n", unitname.c_str(), rv, cmderr.c_str());
        	}
#ifdef DEBUG
		if (output.empty() || (output[0]=='\n' && output[1]=='\0')) {
		    log_debug("Calling 'systemctl show -l %s' got exit-code %i and no stdout", unitname.c_str(), rv);
		} else {
		    log_debug("Calling 'systemctl show -l %s' got exit-code %i and this stdout:\n-----\n%s-----\n\n", unitname.c_str(), rv, output.c_str());
		}
#endif
                if (rv == 0 && !output.empty()) {
</%cpp>
%                   if (first) {
            {
%                       first = false;
%                   }
%                   else {
          , {
%                   }
                <$$ utils::json::jsonify ("unit", unitname) $>
<%cpp>
                    std::vector<std::string> status_tokens;
                    cxxtools::split("\n", output, std::back_inserter(status_tokens));
                    for (const auto& line : status_tokens) {
                        if (line.empty ())
                            continue;
                        std::size_t found = line.find ("=");
                        if (found == std::string::npos)
                            continue;
                        std::string key = line.substr (0, found);
                        std::string value  = line.substr (found+1, std::string::npos);
</%cpp>
%                       if (key.compare ("LoadState") == 0) {
              , <$$ utils::json::jsonify ("LoadState", value) $>
%                       }
%                       else if (key.compare ("ActiveState") == 0) {
              , <$$ utils::json::jsonify ("ActiveState", value) $>
%                       }
%                       else if (key.compare ("UnitFileState") == 0) {
              , <$$ utils::json::jsonify ("UnitFileState", value) $>
%                       }
%                       else if (key.compare ("SubState") == 0) {
              , <$$ utils::json::jsonify ("SubState", value) $>
%                       }
%                       // Note: We can parse out more info here
%                       // TODO: DECIDE if we want to parse out more info
%                   } // for line
            }
%               } // if (systemctl show) rv == 0
%           } // for auto
    ]
%       } // if (systemctl list-units) rv == 0
%   } // if (access_auth_level >= AUTH_LEVEL_POWERUSER)
}
