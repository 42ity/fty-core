<#
 #
 # Copyright (C) 2015 Eaton
 #
 # This program is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation; either version 2 of the License, or
 # (at your option) any later version.
 #
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License along
 # with this program; if not, write to the Free Software Foundation, Inc.,
 # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 #
 #><#
/*!
 * \file config.ecpp
 * \author Karol Hrdina <KarolHrdina@Eaton.com>
 * \brief  implementation for REST api call to manipulate with
 *         system configuration
 */
 #><%pre>
#include <czmq.h>
#include <string>
#include <exception>
#include <cstdlib>
#include <mutex>
#include <cxxtools/serializationinfo.h>
#include <cxxtools/jsondeserializer.h>
#include <cxxtools/jsonserializer.h>
#include <cxxtools/regex.h>
#include "helpers.h"
#include "log.h"

const char *
get_config_mapping (const std::string& key)
{
    const static std::map <const std::string, const std::string> config_mapping = {
        // general
        {"BIOS_SNMP_COMMUNITY_NAME",    "snmp/community"},
        // nut
        {"BIOS_NUT_POLLING_INTERVAL",   "nut/polling_interval"},
        // agent-smtp
        {"BIOS_SMTP_SERVER",            "smtp/server"},
        {"BIOS_SMTP_PORT",              "smtp/port"},
        {"BIOS_SMTP_ENCRYPT",           "smtp/encryption"},
        {"BIOS_SMTP_VERIFY_CA",         "smtp/verify_ca"},
        {"BIOS_SMTP_USER",              "smtp/user"},
        {"BIOS_SMTP_PASSWD",            "smtp/passwd"},
        {"BIOS_SMTP_FROM",              "smtp/from"},
        {"BIOS_SMTP_SMS_GATEWAY",       "smtp/smsgateway"},
        // agent-ms
        {"BIOS_METRIC_STORE_AGE_RT",    "store/rt"},
        {"BIOS_METRIC_STORE_AGE_15m",   "store/15m"},
        {"BIOS_METRIC_STORE_AGE_30m",   "store/30m"},
        {"BIOS_METRIC_STORE_AGE_1h",    "store/1h"},
        {"BIOS_METRIC_STORE_AGE_8h",    "store/8h"},
        {"BIOS_METRIC_STORE_AGE_24h",   "store/24h"},
        {"BIOS_METRIC_STORE_AGE_7d",    "store/7d"},
        {"BIOS_METRIC_STORE_AGE_30d",   "store/30d"}
    };
    if (config_mapping.find (key) == config_mapping.end ())
        return key.c_str ();
    return config_mapping.at (key).c_str (); 
}

const char *
get_config_path (const std::string& key)
{
    if (key.find ("BIOS_SMTP_") == 0) 
    {
        return "/etc/agent-smtp/bios-agent-smtp.cfg";
    }
    else
    if (key.find ("BIOS_METRIC_STORE_") == 0)
    {
        return "/etc/bios-agent-ms/bios-agent-ms.cfg";
    }
    else
    if (key.find ("BIOS_NUT_") == 0)
    {
        return "/etc/agent-nut/bios-agent-nut.cfg";
    }
    // general config file
    return "/etc/bios/general.cfg";
}


// define json serialization objects
struct Array
{
    struct Config
    {
        std::string key;
        std::vector <std::string> value;
    };
    Config config;
};

struct Value
{
    struct Config
    {
        std::string key;
        std::string value;
    };
    Config config;
};

void operator<<= (cxxtools::SerializationInfo& si, const Array::Config& config)
{
    si.addMember("key") <<= config.key;
    si.addMember("value") <<= config.value;
}
void operator<<= (cxxtools::SerializationInfo& si, const Array& array)
{
    si.addMember("config") <<= array.config;
}


void operator<<= (cxxtools::SerializationInfo& si, const Value::Config& config)
{
    si.addMember("key") <<= config.key;
    si.addMember("value") <<= config.value;
}
void operator<<= (cxxtools::SerializationInfo& si, const Value& value)
{
    si.addMember("config") <<= value.config;
}

zconfig_t *
load_config_file (const std::string& key)
{
    std::string file = get_config_path (key);
    zconfig_t *config = zconfig_load (file.c_str ());
    if (!config) {
        std::size_t last_slash = file.find_last_of ("/");
        int rv = zsys_dir_create ("%s", file.substr (0, last_slash).c_str ());
        if (rv != 0) {
            log_error ("zsys_dir_create (\"%s\") failed.", file.substr (0, last_slash).c_str ());
            return NULL;
        }
        return zconfig_new ("root", NULL);
    }
    return config;
}
</%pre>
<%application scope="page">
    std::mutex config_mux;
</%application>
<%request scope="global">
UserInfo user;
</%request>
<%cpp>
{
    // check user permissions
    static const std::map <BiosProfile, std::string> PERMISSIONS =
    {
        {BiosProfile::Admin,     "CR"}
    };
    CHECK_USER_PERMISSIONS_OR_DIE (PERMISSIONS);

    std::string key_format_string = "^[-._a-zA-Z0-9]+$";
    cxxtools::Regex key_format(key_format_string);
    std::string value_format_string = "^[[:blank:][:alnum:][:punct:]]*$";
    cxxtools::Regex value_format(value_format_string);

    ///////////////////
    ///     GET     ///
    ///////////////////
    if (request.isMethodGET ()) {
        std::string checked_key;
        {
            std::string key = qparam.param ("key");
            if (!key_format.match (key)) {
                std::string msg = "satisfy format " + key_format_string;
                http_die ("request-param-bad", "key", key.c_str(), msg.c_str() );
            }
            checked_key = std::move (key);
        }

        std::lock_guard<std::mutex> lock (config_mux);
        const char *config_file_name = get_config_path (checked_key);
        zconfig_t *root = zconfig_load (config_file_name);
        if (!root)
            http_die("internal-error", "Error loading configuration file '%s' for key '%s'.", config_file_name, checked_key);

        const char *config_key = get_config_mapping (checked_key);
        zconfig_t *item = zconfig_locate (root, config_key);
        if (!item) {
            zconfig_destroy (&root);
            http_die("element-not-found", checked_key.c_str ());
        }

        bool is_array = false;
        std::string value = zconfig_value (item);
        std::vector <std::string> array;
        zconfig_t *child = zconfig_child (item);
        if (child) {
            while (child) {
                if (!streq (zconfig_value (child), "")) {
                    is_array = true;
                    array.push_back (zconfig_value (child));
                }
                child = zconfig_next (child);
            }
        }
        zconfig_destroy (&root);

        cxxtools::JsonSerializer serializer (reply.out ());
        serializer.beautify (true);

        if (is_array) {
            Array json;
            json.config.key = checked_key;
            json.config.value = std::move (array);
            serializer.serialize (json).finish ();
        }
        else
        {
            Value json;
            json.config.key = checked_key;
            json.config.value = value;
            serializer.serialize (json).finish ();
        }
        return HTTP_OK;
    }

    ////////////////////
    ///     POST      //
    ////////////////////
    if (request.isMethodPOST ()) {
        std::string checked_key;
        std::string checked_value;
        std::vector <std::string> checked_values;
        bool is_array = false;

        try {
            std::stringstream input (request.getBody (), std::ios_base::in);
            cxxtools::JsonDeserializer deserializer (input);
            cxxtools::SerializationInfo request_doc;
            deserializer.deserialize (request_doc);
            if (request_doc.category () != cxxtools::SerializationInfo::Object) {
                http_die ("bad-request-document", "Root of json request document must be an object with property 'config'.");
            }

            std::string key;
            request_doc.getMember("config").getMember("key") >>= key;
            if (!key_format.match (key)) {
                std::string msg = "satisfy format " + key_format_string;
                http_die ("request-param-bad", "key", key.c_str(), msg.c_str() );
            }
            checked_key = std::move (key);
            log_debug ("key='%s'", checked_key.c_str());

            if (request_doc.getMember ("config").getMember ("value").category () == cxxtools::SerializationInfo::Category::Value) {
                std::string value;
                request_doc.getMember ("config").getMember ("value") >>= value;
                if (!value_format.match (value)) {
                    std::string msg = "satisfy format " + value_format_string;
                    http_die ("request-param-bad", "value", value.c_str(), msg.c_str() );
                }
                checked_value = std::move (value);
            }
            else
            if (request_doc.getMember ("config").getMember ("value").category () == cxxtools::SerializationInfo::Category::Array) {
                is_array = true;
                std::vector<std::string> values;
                request_doc.getMember ("config").getMember ("value") >>= values;
                for (const auto& i : values)  {
                    if (!value_format.match (i)) {
                        std::string msg = "satisfy format " + value_format_string;
                        http_die ("request-param-bad", "value", i.c_str(), msg.c_str() );
                    }
                    checked_values.push_back (i);
                }
            }
            else
            {
                http_die ("bad-request-document", "Value of property 'value' must be string or array of strings.");
            }
        }
        catch (const std::exception& e) {
            http_die ("bad-request-document", e.what ());
        }

        {
            std::lock_guard<std::mutex> lock (config_mux);
            zconfig_t *root = load_config_file (checked_key);
            if (!root)
                http_die ("internal-error", "...tbd...");

            const char *config_key = get_config_mapping (checked_key);
            if (is_array) {
                zconfig_put (root, config_key, NULL);
                int counter = 0;
                for (const auto& i : checked_values)  {
                    zconfig_put (root, std::string (config_key).append ("/").append (std::to_string (counter)).c_str (), i.c_str ());
                    counter++;
                }
            }
            else {
                zconfig_t *item = zconfig_locate (root, config_key);
                if (item && zconfig_child (item)) {
                    zconfig_t *child = zconfig_child (item);
                    while (child) {
                        zconfig_set_value (child, NULL);
                        child = zconfig_next (child);
                    }
                }
                zconfig_put (root, config_key, checked_value.c_str ());
            }
            int rv = zconfig_save (root, get_config_path (checked_key));
            zconfig_destroy (&root);
            if (rv == -1) {
                http_die ("internal-error", "...tbd...");
            }
        }

        cxxtools::JsonSerializer serializer(reply.out ());
        serializer.beautify (true);

        if (is_array) {
            Array json;
            json.config.key = checked_key;
            json.config.value = std::move (checked_values);
            serializer.serialize (json).finish ();
        }
        else
        {
            Value json;
            json.config.key = checked_key;
            json.config.value = checked_value;
            serializer.serialize (json).finish ();
        }
        return HTTP_OK;
    }
    http_die ("method-not-allowed");
}
</%cpp>
