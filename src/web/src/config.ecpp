<#
 #
 # Copyright (C) 2015 Eaton
 #
 # This program is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation; either version 2 of the License, or
 # (at your option) any later version.
 #
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License along
 # with this program; if not, write to the Free Software Foundation, Inc.,
 # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 #
 #><#
/*!
 * \file config.ecpp
 * \author Karol Hrdina <KarolHrdina@Eaton.com>
 * \brief  implementation for REST api call to manipulate with
 *         system configuration
 */
 #><%pre>
#include <string>
#include <exception>
#include <cstdlib>
#include <fstream>
#include <mutex>
#include <cxxtools/properties.h>
#include <cxxtools/propertiesdeserializer.h>
#include <cxxtools/jsondeserializer.h>
#include <cxxtools/serializationinfo.h>
#include <cxxtools/regex.h>
#include "utils_web.h"
#include "log.h"

#define PROPERTIES_FILE "/etc/default/bios"
#define MSG_METHOD_NOT_ALLOWED "Following HTTP methods are supported for 'admin/config': GET, POST."

void replace_all (std::string& string, const char* subject, const char* replacement) {
    if (!replacement || !subject || strlen (subject) == 0)
        return;
    std::string::size_type find = string.find (subject, 0),
                subject_len = strlen (subject), replacement_len = strlen (replacement);
    while (find != std::string::npos) {
        string.replace (find, subject_len, replacement);
        find = string.find (subject, find + replacement_len);
    }
}

void transform_for_json (std::string& string) {
    // <quote> The parser strips leading and trailing whitespace from the strings of assignments, unless you use double quotes ("). </quote>
    // We need to strip leading and trailing double quote character (") when both of them are present.
    if (string.at(0) == '"' && string.at(string.size () - 1) == '"') {
        string.erase (0, 1);
        string.erase (string.size () - 1, 1);
    }

    // <quote>A line ending with a backslash will be concatenated with the following one, allowing multiline variable definitions.</quote>
    // We need to revert this replacing each 2 consecutive characters '\' and '\n' in text with a single character '\n'
    replace_all (string, "\\\n", "\n");
}

void transform_for_conf (std::string& string) {
    // This is not perfect but for the moment it's ok
    replace_all (string, "\"", "");
    // <quote>A line ending with a backslash will be concatenated with the following one, allowing multiline variable definitions</quote>
    replace_all (string, "\n", "\\\n");
    // 1. empty string must be enclosed in ""
    // 2. <quote>The parser strips leading and trailing whitespace from the values of assignments, unless you use double quotes (").</quote>
    if (string.empty () ||
        (string.at (0) == ' ' || string.at (0) == '\t' || string.at (string.size () - 1) == ' ' || string.at (string.size () - 1) == '\t')) {
        string.insert (0, "\"");
        string.push_back ('"');
    }
}
</%pre>
<%application scope="page">
    std::mutex config_mux;
</%application>
<%cpp>
{
    // key restrictions
    std::string key_format_string = "^[.-_a-zA-Z0-9]+$";
    cxxtools::Regex key_format(key_format_string);

    // DISCLAIMER!!! PLEASE READ!!!
    //
    // Current status:
    // There is no backend (agent) available nor design "consideration" ready for configuration settings management at the moment.
    // Therefore this version will use cxxtools properties so that the rest api call can be really actually tested.
    //
    // Plan for next PR:
    // Replace cxxtools properties with something more suited for real-world deployment, probably zconfig or such...

    // Dummy implementation ahead using EnvironmentFile= section of http://www.freedesktop.org/software/systemd/man/systemd.exec.html

    cxxtools::SerializationInfo si;
    try {
        std::lock_guard<std::mutex> lock(config_mux);
        std::ifstream finput (PROPERTIES_FILE);
        if (finput.is_open () && finput.good ()) {
            cxxtools::PropertiesDeserializer deserializer (finput);
            deserializer.deserialize (si);
        }
    }
    catch (const std::exception& e) {
        std::string errmsg = "Error deserializing file ";
        errmsg += PROPERTIES_FILE;
        errmsg = errmsg + " : " + e.what();
        http_die ("internal-error", errmsg.c_str());
    }

    ///////////////////
    ///     GET     ///
    ///////////////////
    if (request.isMethodGET ()) {
        // sanity check
        std::string checked_key;
        {
            std::string key = qparam.param ("key");
            if (!key_format.match (key)) {
                std::string errmsg = "key doesn't satisfy format " + key_format_string;
                http_die ("request-param-bad", errmsg.c_str() );
            }
            checked_key = std::move (key);
        } // end sanity check
        std::string value;
        if ( !si.getMember (checked_key, value)) {
            http_die("element-not-found", checked_key.c_str());
        }
        // key is found
        transform_for_json (value);
</%cpp>
{
    "config": {
        "key" : "<$ checked_key $>",
        "value" : "<$ value $>"
    }
}
<%cpp>
        return HTTP_OK;
    }

    ////////////////////
    ///     POST      //
    ////////////////////
    if (request.isMethodPOST ()) {
        std::string rd_key, rd_value;
        try {
            std::stringstream input (request.getBody (), std::ios_base::in);
            cxxtools::JsonDeserializer deserializer (input);
            cxxtools::SerializationInfo request_doc;
            deserializer.deserialize (request_doc);
            if (request_doc.category () != cxxtools::SerializationInfo::Object) {
                http_die("bad-request-document", "Root of json request document must be an object with property 'config'.");
            }
            request_doc.getMember("config").getMember("key") >>= rd_key;
            request_doc.getMember("config").getMember("value") >>= rd_value;
        }
        catch (const std::exception& e) {
            LOG_END_ABNORMAL(e);
            http_die("bad-request-document", e.what());
        }

        // There are some restrictions regarding key format
        std::string key_format_string = "^[.-_a-zA-Z0-9]+$";
        static cxxtools::Regex key_format(key_format_string);
        if (!key_format.match (rd_key)) {
            std::string errmsg = "key doesn't satisfy format " + key_format_string;
            http_die ("request-param-bad", errmsg.c_str() );
        }

        try {
            auto p_si = si.findMember (rd_key);
            if (!p_si) {
                si.addValue (rd_key, rd_value);
            }
            else {
                p_si->setValue (rd_value);
            }
            std::lock_guard<std::mutex> lock(config_mux);
            std::ofstream foutput (PROPERTIES_FILE);
            if (!foutput.is_open () || !foutput.good()) {
                std::string errmsg = "Error writing file ";
                errmsg += PROPERTIES_FILE;
                http_die ("internal-error", errmsg.c_str());
            }

            for (auto it = si.begin (); it != si.end (); ++it) {
                std::string name = it->name ();
                std::string name_value;
                it->getValue (name_value);
                transform_for_conf (name_value);
                foutput << name  << "=" << name_value  << "\n";
            }
            foutput.flush ();
            foutput.close ();
        }
        catch (const std::exception& e) {
            LOG_END_ABNORMAL(e);
            http_die("internal-error");
        }
</%cpp>
{}
<%cpp>
        return HTTP_OK;
    }
    // other methods
    http_die("method-not-allowed");
}
</%cpp>


