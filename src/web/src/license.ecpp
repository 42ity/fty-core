<#
 #
 # Copyright (C) 2015 Eaton
 #
 # This program is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation; either version 2 of the License, or
 # (at your option) any later version.
 #
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License along
 # with this program; if not, write to the Free Software Foundation, Inc.,
 # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 #
 #><#
/*!
 * \file license.ecpp
 * \author Michal Hrusecky <MichalHrusecky@Eaton.com>
 * \author Jim Klimov <EvgenyKlimov@Eaton.com>
 * \brief Validates and manages license acceptance
 */
 #><%pre>

/** The GNU version of basename allocate the memory, while POSIX modify input
 * buffer. While POSIX behavior is weird, is already expected. This line tries
 * to avoid usage of GNU version of basename */
#undef _GNU_SOURCE

#include <unistd.h>
#include <iostream>
#include <stdio.h>
#include <fstream>
#include <cxxtools/regex.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <inttypes.h>
#include <string.h>
#include <stdlib.h>
#include <pwd.h>
#include <mutex>

#include "config.h"
#include "utils.h"
#include "cleanup.h"
#include "utils_web.h"
#include "log.h"

#define RETURN return

// drop the last / in a developer friendly way
// this is intended to fix issue we've on rhel
// "version" : "/usr/share/bios/license/1.0"
// if there's no / in inp, then it's noop
// if so, then it returns character AFTER last /
static const char*
basename2 (const char *inp)
{
    const char *sep = strrchr (inp, '/');
    if (!sep)
        return inp;
    return sep+1;
}

</%pre>
<%request scope="global">
long int uid = 0;
</%request>
<%cpp>
// Basic operations

_scoped_char *current_license = current_license_file ();
_scoped_char *accepted_license = accepted_license_file ();
#ifdef DEBUG
	log_debug("FYI:  current_license='%s'  accepted_license='%s'", current_license, accepted_license);
#endif
static cxxtools::Regex rex_lic("^.*/license$");
if(rex_lic.match(request.getUrl())) {
	if(request.isMethodGET()) {
		std::ifstream source(current_license, std::ios::binary);
		if(!source.good()) {
			log_debug("Error reading license acceptance from file '%s'", current_license);
			http_die("internal-error", "Error reading license file, check integrity of storage.");
		}
		reply.out() << source.rdbuf();
		RETURN HTTP_OK;
	}
	if(request.isMethodPOST()) {
		/* Read symlink, get license version number */
		char buff[512];
		memset(buff, 0, sizeof(buff));
		ssize_t reslink = readlink(current_license, buff, sizeof(buff)-1);
		if (reslink < 0 || buff[0] == 0) {
			if (reslink < 0) {
				char errbuff[512];
				memset(errbuff, 0, sizeof(errbuff));
				log_debug("Error reading symlink '%s' (%li), got errno=%i (%s)",
					current_license, (long)reslink, (int)errno,
					(char *)strerror_r(errno, errbuff, sizeof(errbuff)-1) );
			}
			if (buff[0] == 0)
				log_debug("Error reading license version number from symlink name '%s' (got empty buffer)", current_license);
			http_die("internal-error", "Error saving license acceptance or getting license version, check integrity of storage.");
		}

		/* Identify user */
		char *user = NULL;
		static std::mutex pw_lock;
		pw_lock.lock();
		struct passwd *pw = getpwuid(uid);
		if(pw != NULL) {
			user = strdup(pw->pw_name);
		}
		pw_lock.unlock();
		if(user == NULL) {
			std::string msg = "Can't get username for user with id " + std::to_string(uid);
			log_debug("Error: %s", msg.c_str());
			http_die("internal-error", msg.c_str());
		}

		/* Try to write license-acceptance file data */
		int dest = open(accepted_license, O_WRONLY | O_CREAT | O_TRUNC, 0644);
		uint64_t tme = time(NULL);
		int dpdest = -42;
		if(dest > 0)
			dpdest = dprintf(dest, "%s\n%" PRIu64 "\n%s\n", buff, tme, user);
		if(dest < 0 || dpdest < 4) {
			if (dest < 0)
				log_debug("Error opening license acceptance file '%s': got FD dest=%i", accepted_license, dest);
			if (dpdest < 4 && dpdest != -42)
				log_debug("Error saving license acceptance into file '%s': got dpdest=%i bytes written",
				accepted_license, dpdest);
#ifdef DEBUG
			log_debug("FYI: Tried to write version buff='%s', tme='%" PRIu64 "', user='%s' (uid='%li')",
				buff, tme, user, uid);
#endif
			if(dest > 0)
				close(dest);
			http_die("internal-error", "Error saving license acceptance or getting license version, check integrity of storage.");
		} else {
</%cpp>
{ "success" : "License version <$ buff $> accepted." }
<%cpp>
			close(dest);
			RETURN HTTP_OK;
		}
	}
	http_die("method-not-allowed", request.getMethod().c_str());
}

_scoped_char *buff_a = NULL;
_scoped_char *user = NULL;
char buff_r[512];
memset(buff_r, 0, sizeof(buff_r));
uint64_t tme;
readlink(current_license, buff_r, sizeof(buff_r));
FILE* src = fopen(accepted_license, "r");
if(src != NULL) {
	fscanf(src,"%ms\n%" SCNu64 "\n%ms", &buff_a, &tme, &user);
	fclose(src);
}
static cxxtools::Regex rex_st("^.*/license/status$");
if(rex_st.match(request.getUrl())) {
	if(!request.isMethodGET())
		http_die("method-not-allowed", request.getMethod().c_str());
</%cpp>
{
  "accepted" : "<$ (buff_a == NULL || strcmp(buff_a, buff_r) != 0) ? "no" : "yes" $>"
, "version" : "<$ basename2 (buff_r) $>"
% if(buff_a != NULL) {
, "accepted_version" : "<$ basename2 (buff_a) $>"
, "accepted_at" : "<$ tme $>"
% }
% if(user != NULL) {
, "accepted_by" : "<$ user $>"
% }
}
<%cpp>
	FREE0(buff_a);
	FREE0(user);
	RETURN HTTP_OK;
}
if(buff_a == NULL || strcmp(buff_a, buff_r) != 0) {
  if(buff_a == NULL) {
	http_die("action-forbidden", "REST API call", "Please accept license first.");
  } else {
	std::string msg = std::string{"License version changed (new is "} + buff_r + ", accepted is " + buff_a + "). Please accept new license first";
	FREE0(buff_a);
	FREE0(user);
	http_die("action-forbidden", "REST API call", msg.c_str());
  }
} else {
	FREE0(buff_a);
	FREE0(user);
	RETURN DECLINED;
}
</%cpp>
