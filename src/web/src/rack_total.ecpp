<#
 #
 # Copyright (C) 2015 Eaton
 #
 # This program is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation; either version 2 of the License, or
 # (at your option) any later version.
 #
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License along
 # with this program; if not, write to the Free Software Foundation, Inc.,
 # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 #
 #><#
/*!
 * \file rack_total.ecpp
 * \author Tomas Halman <TomasHalman@Eaton.com>
 * \author Michal Vyskocil <MichalVyskocil@Eaton.com>
 * \author Alena Chernikava <AlenaChernikava@Eaton.com>
 * \author Karol Hrdina <KarolHrdina@Eaton.com>
 * \brief Not yet documented file
 */
 #><%pre>
#include <czmq.h>
#include <cxxtools/split.h>
#include <cxxtools/regex.h>
#include <tntdb/error.h>
#include <exception>
#include <limits.h>

#include "assetcrud.h"
#include "data.h"
#include "calc_power.h"
#include "dbpath.h"
#include "db/measurements.h"
#include "cleanup.h"
#include "utils.h"
#include "utils++.h"
#include "utils_web.h"

static const std::map<std::string, const std::string> PARAM_TO_SRC = {
    {"total_power", "realpower.default"},
    {"avg_power_last_day", "realpower.default_arithmetic_mean_24h"},
    {"avg_power_last_week", "<zero>"},
    {"avg_power_last_month", "<zero>"},
    {"avg_power_last_year", "<zero>"}
};

float
total_rack_power(
    tntdb::Connection& conn,
    const std::string& src,
    a_elmnt_id_t id)
{

    if (src == "<zero>")
        return 0.0f;

    m_msrmnt_value_t value;
    m_msrmnt_scale_t scale;
    auto reply = persist::select_measurement_last_web_byElementId(conn, src, id, value, scale);

    if (reply.rv != 0)
        return 0.0f;

    return value * pow(10,scale);
}

static bool
s_is_valid_param(const std::string& p)
{
    return PARAM_TO_SRC.count(p) != 0;
}

</%pre>
<%args>
std::string arg1;
std::string arg2;
</%args>
<%thread scope="global">
asset_manager asset_mgr;
</%thread>
<%cpp>
    // Input arguments checks

    // arg1, arg2 are both mandatory
    if (arg1.empty ()) {
        http_die ("request-param-required", "arg1");
    }

    if (arg2.empty ()) {
        http_die ("request-param-required", "arg2");
    }

    http_errors_t errors;

    // arg2 is a single value OR a comma-separated list formed from a list of permissible values (PARAM_TO_SRC)
    std::vector <std::string> requestedParams;
    cxxtools::split (",", arg2, std::back_inserter (requestedParams));

    for (const std::string& param: requestedParams) {
        if (!s_is_valid_param (param)) {
            http_add_error (errors, "request-param-bad", "arg2",
                std::string ("value '").append (param).append ("'").c_str (),
                std::string ("one of the following values: [").append (utils::join_keys_map (PARAM_TO_SRC, ", ")).append ("].").c_str ());
        }
    }    
    if (!errors.errors.empty ()) {
        http_die_error (errors);
    }

    // arg1 is a single value OR a comma-separated list of element identifiers
    std::vector<std::string> racks; // list of ids of racks from argument string
    std::vector<std::string> rackNames;
    cxxtools::split(",", arg1, std::back_inserter(racks));

    // check that racks exists
    auto allRacksShort = asset_mgr.get_items1("rack", "");
    if ( allRacksShort.status == 0 ) {
        http_die ("internal-error", "Error while retrieving information about racks."); 
    }

    for (auto const& item : racks) {
        try {
            // id_asset_element is defined as 'INT UNSIGNED' in tools/initdb.sql
            static cxxtools::Regex regex_element ("^[1-9][0-9]*$");
            if (!regex_element.match (item)) {
                throw std::invalid_argument ("");
            } 
            unsigned long real_id_l = std::stoul (item);
            if (real_id_l == 0 || real_id_l > UINT_MAX) {
                throw std::out_of_range ("");
            }
            uint32_t real_id = static_cast<uint32_t> (real_id_l);

            auto it = allRacksShort.item.find(real_id);
            if (it == allRacksShort.item.end()) {
                throw std::runtime_error("");
            }
            rackNames.push_back (it->second);
        }
        catch (const std::out_of_range& e) {
            http_add_error (errors, "request-param-bad", "arg1",
                std::string ("value '").append (item).append ("'").append (" is out of range").c_str (),
                std::string ("value in range 1 to ").append (std::to_string (UINT_MAX)).append (".").c_str ());
        } 
        catch (const std::invalid_argument& e) {
            http_add_error (errors, "request-param-bad", "arg1",
                std::string ("value '").append (item).append ("'").append (" is not an element identifier").c_str (),
                std::string ("an unsigned integer in range 1 to ").append (std::to_string (UINT_MAX)).append (".").c_str ());
        }
        catch (const std::runtime_error& e) {
            http_add_error (errors, "request-param-bad", "arg1",
                std::string ("rack id value '").append (item).append ("'").append (" does NOT exist").c_str (),
                "existing rack identifier.");
        }
    }
    if (!errors.errors.empty ()) {
        http_die_error (errors);
    }

    std::stringstream json;

    try {
        tntdb::Connection conn = tntdb::connectCached (url);

        json <<
"{\n"
"\t\"rack_total\": [\n";

        for( size_t R = 0 ; R < racks.size(); R++ ) {
            json <<
"\t\t{\n"
"\t\t\t\"id\": \"" << racks[R] << "\",\n"
"\t\t\t\"name\": \"" << rackNames[R] << "\",\n";
            for(size_t P = 0; P < requestedParams.size(); P++ ) {
                const std::string& key = requestedParams[P];
                const std::string& val = PARAM_TO_SRC.at(key);   //XXX: operator[] does not work here!
                json << "\t\t\t\"" << key << "\": "<< total_rack_power (conn, val, std::stoi (racks[R]));
                json << ((P < requestedParams.size() - 1) ? "," : "" ) << "\n";
            };
            json << "\t\t}" << ( (R < racks.size() - 1) ? "," : "" ) << " \n";
        }
    json << "\t]\n}\n";
    }
    catch (const tntdb::Error& e) {
        http_die ("internal-error", std::string ("Error while connecting to database: ").append (e.what ()).c_str ());
    }
    catch (const std::exception& e) {
        http_die ("internal-error", e.what ());
    }
</%cpp>
<$$ json.str() $>
