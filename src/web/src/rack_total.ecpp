<%pre>
#include <czmq.h>
#include <cxxtools/split.h>

#include "asset_msg.h"
#include "assetcrud.h"
#include "data.h"
#include "calc_power.h"
#include "dbpath.h"

float total_rack_power(a_elmnt_id_t rack_element_id) {
    
    zmsg_t *msg = calc_total_rack_power(url.c_str(),rack_element_id);
    if( ! msg ) { throw "no message"; }
    if( ! is_compute_msg(msg) ) {
        zmsg_destroy(&msg);
        throw "invalid message type";
    }
    compute_msg_t* res_compute = compute_msg_decode (&msg);
    zmsg_destroy(&msg);
    compute_msg_print (res_compute);
    zhash_t* results = compute_msg_get_results (res_compute);

    m_msrmnt_value_t value;
    m_msrmnt_scale_t scale;
    a_elmnt_id_t num_missed;
    int rv0 = compute_result_value_get(results, &value);
    int rv1 = compute_result_scale_get(results, &scale);
    int rv2 = compute_result_num_missed_get(results, &num_missed);
    compute_msg_destroy(&res_compute);
    zhash_destroy(&results);
    if ( rv0 || rv1 || rv2 ) return 0.0;
    return value * pow(10,scale);
}

</%pre>
<%args>
std::string arg1;
std::string arg2;
</%args>
<%thread scope="global">
asset_manager asset_mgr;
</%thread>
<%cpp>
    // Check URL validity
    if( arg1 == "" || arg2 == "" ) {
</%cpp>
{ "error":"bad_input", "msg":"missing argument" }
<%cpp>
        return HTTP_BAD_REQUEST;
    }
    std::vector<std::string> racks;
    std::vector<std::string> rackNames;
    std::vector<std::string> requestedParams;
    static std::vector<std::string> validParams = {
        "total_power",
        "avg_power_last_day",
        "avg_power_last_week",
        "avg_power_last_month",
        "avg_power_last_year"
    };
    cxxtools::split(",", arg1, std::back_inserter(racks));
    // check that racks exists
for( size_t R = 0; R <racks.size() ; ++R ) {
    zmsg_t * msg = asset_mgr.get_item("rack",racks[R]);
    if ( is_asset_msg (msg) ) {
        asset_msg_t* element = asset_msg_decode (&msg);
        if ( asset_msg_id( element ) == ASSET_MSG_ELEMENT ) {
            rackNames.push_back(asset_msg_name(element));
        } else {
</%cpp>
{ "error":"bad_input", "msg":"invalid rack id"}
<%cpp>
            asset_msg_destroy (&element);
            zmsg_destroy(&msg);
            return HTTP_BAD_REQUEST;

        }
        asset_msg_destroy (&element);
    } else {
</%cpp>
{"error":"bad_input", "msg":"invalid rack id"}
<%cpp>
        zmsg_destroy(&msg);
        return HTTP_BAD_REQUEST;
    }
    zmsg_destroy(&msg);
}
    cxxtools::split(",", arg2, std::back_inserter(requestedParams));
    for(std::string &param: requestedParams) {
        if( std::find( validParams.begin(), validParams.end(), param ) == validParams.end() ) {
</%cpp>
{ "error":"bad_input", "msg":"invalid_parameter" }
<%cpp>
           return HTTP_BAD_REQUEST;
       }
   }
   std::stringstream json;
try {
   json << "{\n  \"rack_total\": [\n";
   for( size_t R = 0 ; R < racks.size(); R++ ) {
       json   << "    {\n"
              << "      \"id\":   \"" << racks[R] << "\",\n"
              << "      \"name\": \"" << rackNames[R] << "\",\n";
       for(size_t P = 0; P < requestedParams.size(); P++ ) {
           if( requestedParams[P] == "total_power" ) {
               json << "      \"total_power\": "<< total_rack_power( atoi( racks[R].c_str() ) );
           } else {
               json << "      \"" << requestedParams[P] << "\": " << (800.0 + (std::rand() % 2000)/10.0 );
           }
           json <<  ( ( P < requestedParams.size() - 1 ) ? "," : "" ) << "\n";
       };
       json << "    }" << ( (R < racks.size() - 1) ? "," : "" ) << " \n";
   }
   json << "  ]\n}\n";
} catch ( const std::exception& e ) {
</%cpp>
<h1>internal server error</h1>
<$ e.what() $>
<%cpp>      
      return HTTP_INTERNAL_SERVER_ERROR;   
}
</%cpp>
<$$ json.str() $>
