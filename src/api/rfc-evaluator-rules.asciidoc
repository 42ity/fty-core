
RFC-Evaluator-Rules  -  Evaluator rules protocol
================================================
Connects USER peer to EVALUATOR peer.

The USER peer sends one of the following messages using MAILBOX SEND to
EVALUATOR peer:

1) LIST/type - request list of rule names of specified 'type'
2) GET/name - request detail of rule 'name'
3) ADD/json[/old_name] - create new rule or update existing rule. If optional
part 'old_name' is specified, perform additional rename of rule name
'old_name' to name specified in json property "rule_name" : "<new_name>".

where '/' indicates a multipart string message, 'json' is valid json
document(1), 'type' is one of [ all | threshold | pattern | single ], 'name',
'old_name' is rule name and 'subject' of the message is
"rfc-evaluator-rules".

The EVALUATOR peer MUST send the appropriate message back to USER peer
using MAILBOX SEND.

For message 1) EVALUTATOR peer MUST respond with one of the following messages:
a) LIST/type/rule_1[/rule_2]...[/rule_N]
c) ERROR/reason


For messages 2) and 3) EVALUATOR peer MUST respond with one of the following messages:
b) OK/json
c) ERROR/reason

where '/' indicates a multipart string message, 'json' is valid json
document(1), 'reason' is error string, 'type' is one of [ all | threshold |
pattern | single ] and its value MUST be the same as the value of 'type'
received in 1) message, 'subject' of the message is "rfc-evaluator-rules".

For messages 1), 2), 3) if the requested 'type', 'name' or 'old_name' does not
exist the EVALUATOR peer MUST assign NOT_FOUND string as reason.

For message 3) if 'json' is not a valid json or does not adhere to rules schema
the EVALUATOR peer MUST assing BAD_JSON string as reason.



(1)
There are three different json formats that are accepted

{
    "threshold" : {
        "rule_name"     :   "<rule_name>",
        "target"        :   <topic_specification>,
        "element"       :   "<element_name>",
        "values"        :   [ { "low_critical"  : "<value>" },
                              { "low_warning"   : "<value>" },
                              { "high_warning"  : "<value>" },
                              { "high_critical" : "<value>" } ],
        "results"       :   [ { "low_critical"  : { "action" : ["<action_1>", ..., "<action_N>"], "severity" : "<severity>", "description" : "<description>" }},
                              { "low_warning"   : { "action" : ["<action_1>", ..., "<action_N>"], "severity" : "<severity>", "description" : "<description>" }},
                              { "high_warning"  : { "action" : ["<action_1>", ..., "<action_N>"], "severity" : "<severity>", "description" : "<description>" }},
                              { "high_critical" : { "action" : ["<action_1>", ..., "<action_N>"], "severity" : "<severity>", "description" : "<description>" }} ],
        "evaluation"    :   "<lua_function>"
    }
}

{
    "pattern" : {
        "rule_name"     :   "<rule_name>",
        "target"        :   "<regex>",
        "values"        :   [ { "<value_name_1>"  : "<value>" },
                               ...,
                              { "<value_name_N>"  : "<value>" } ],
        "results"       :   [ { "<result_name_1>"  : { "action" : ["<action_1>", ..., "<action_N>"], "severity" : "<severity>", "description" : "<description>" }},
                              ...
                              { "<result_name_N>" : { "action" : ["<action_1>", ..., "<action_N>"], "severity" : "<severity>", "description" : "<description>" }} ],
        "evaluation"    :   "<lua_function>",
    }
}

{
    "single" : {
        "rule_name"     :   "<rule_name>",
        "target"        :   [ "<topic_1>", ... , "<topic_N>"],
        "values"        :   [ { "<value_name_1>"  : "<value>" },
                               ...,
                              { "<value_name_N>"  : "<value>" } ],
        "element"       :   "<element_name>",
        "results"       :   [ { "<result_name_1>"  : { "action" : ["<action_1>", ..., "<action_N>"], "severity" : "<severity>", "description" : "<description>" }},
                              ...
                              { "<result_name_N>" : { "action" : ["<action_1>", ..., "<action_N>"], "severity" : "<severity>", "description" : "<description>" }} ],
        "evaluation"    :   "<lua_function>",
    }
}

where
    * <rule_name>       unique rule name, CASE SENSITIVE
    * <topic_specification>       string value representing topic OR array of topics
    * <element_name>    name of element
    * <value>           number (integer, floating-point)
    * <action_X>        one of [ EMAIL | SMS ] and determines the resulting alert action
    * <severity>        one of [ INFO | WARNING | CRITICAL ] and determines the resulting alert severity
    * <lua_function>    lua function that evaluates trigger conditions
    * <topic_X>         metric topic
    * <regex>           regular expression
    * <value_name_X>    unique name (identifier) of value within given rule definition.
    * <result_name_X>   unique name (identifier) of result within given rule definition (any string except "ok", it is reserved)


For threshold rule:
If <topic_specification> is single string value then property "evaluation" :
"<lua_function>" is ignored. If <topic_specification> is array then property "evaluation" :
"<lua_function>" is mandatory. For further details please consult the
section describing semantics.


The semantics is as follows (WIP):

THRESHOLD:
    There are four predefined values: "low_critical", "low_warning", "high_critical", "high_warning".
There are four predefined results: "low_critical", "low_warning", "high_critical", "high_warning".
There are two types of threshold rules: Simple and Complex.
    Simple one is used, if threshold should be specified for only
one metric known for the system. Then in "target" only one topic should be specified. Rule would be
evaluated and automatically take in account predefined values (if they were specified). Alerts
would be generated according predefined results.
When metric would return into normal value interval, evaluation would trigger the same alert with state RESOLVED.
    Complex rule is used, if threshold should be evaluated for compound metric, that our system doesn't calculate
automatically. So you still need to use predefined value names and predefined result names, but additionally
you should specify "target" as array of topics and provide evaluation function as "evaluation".
When metric would return into normal value interval, evaluation would trigger the same alert with state RESOLVED.

PATTERN:
    As "target" you should specify a regular expression <regex>. Evaluation of the rule would
be triggered for any metric, whose topic matches this regular expression. Then this metric becomes
input to <lua_function> that triggers alert for element that was matched by <regex>.
When the condition no longer holds true, trigger the same alert with state RESOLVED.

SINGLE:
    Every value of any metric defined among <topic_1>, ..., <topic_N> becomes
input to <lua_function> that triggers alert for element <element_name>. Results comming from evaluation
are described in "resilts". When the condition no longer holds true, trigger the same alert with state RESOVED.

